/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Transforms-5b74e989","./Matrix3-2955527a","./ComponentDatatype-f9ac3ed8","./defaultValue-ebbd2e4d","./EllipseGeometryLibrary-b919d7ec","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryOffsetAttribute-739bec2c","./IndexDatatype-7ccfd280","./Math-1fe079f3"],function(I,G,r,L,a,O,g,k,D,T,V){"use strict";const B=new r.Cartesian3;let b=new r.Cartesian3;const S=new G.BoundingSphere,v=new G.BoundingSphere;function x(e){const i=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).center,t=a.defaultValue(e.ellipsoid,r.Ellipsoid.WGS84),C=e.semiMajorAxis,h=e.semiMinorAxis,l=a.defaultValue(e.granularity,V.CesiumMath.RADIANS_PER_DEGREE),n=a.defaultValue(e.height,0),s=a.defaultValue(e.extrudedHeight,n);this._center=r.Cartesian3.clone(i),this._semiMajorAxis=C,this._semiMinorAxis=h,this._ellipsoid=r.Ellipsoid.clone(t),this._rotation=a.defaultValue(e.rotation,0),this._height=Math.max(s,n),this._granularity=l,this._extrudedHeight=Math.min(s,n),this._numberOfVerticalLines=Math.max(a.defaultValue(e.numberOfVerticalLines,16),0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}x.packedLength=r.Cartesian3.packedLength+r.Ellipsoid.packedLength+8,x.pack=function(e,i,t){return t=a.defaultValue(t,0),r.Cartesian3.pack(e._center,i,t),t+=r.Cartesian3.packedLength,r.Ellipsoid.pack(e._ellipsoid,i,t),t+=r.Ellipsoid.packedLength,i[t++]=e._semiMajorAxis,i[t++]=e._semiMinorAxis,i[t++]=e._rotation,i[t++]=e._height,i[t++]=e._granularity,i[t++]=e._extrudedHeight,i[t++]=e._numberOfVerticalLines,i[t]=a.defaultValue(e._offsetAttribute,-1),i};const j=new r.Cartesian3,H=new r.Ellipsoid,p={center:j,ellipsoid:H,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};x.unpack=function(e,i,t){i=a.defaultValue(i,0);const C=r.Cartesian3.unpack(e,i,j);i+=r.Cartesian3.packedLength;const h=r.Ellipsoid.unpack(e,i,H);i+=r.Ellipsoid.packedLength;const l=e[i++],n=e[i++],s=e[i++],m=e[i++],y=e[i++],f=e[i++],d=e[i++],u=e[i];return a.defined(t)?(t._center=r.Cartesian3.clone(C,t._center),t._ellipsoid=r.Ellipsoid.clone(h,t._ellipsoid),t._semiMajorAxis=l,t._semiMinorAxis=n,t._rotation=s,t._height=m,t._granularity=y,t._extrudedHeight=f,t._numberOfVerticalLines=d,t._offsetAttribute=u===-1?void 0:u,t):(p.height=m,p.extrudedHeight=f,p.granularity=y,p.rotation=s,p.semiMajorAxis=l,p.semiMinorAxis=n,p.numberOfVerticalLines=d,p.offsetAttribute=u===-1?void 0:u,new x(p))},x.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const i=e._height,t=e._extrudedHeight,C=!V.CesiumMath.equalsEpsilon(i,t,0,V.CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const h={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:i,granularity:e._granularity,numberOfVerticalLines:e._numberOfVerticalLines};let l;if(C)h.extrudedHeight=t,h.offsetAttribute=e._offsetAttribute,l=function(n){const s=n.center,m=n.ellipsoid,y=n.semiMajorAxis;let f=r.Cartesian3.multiplyByScalar(m.geodeticSurfaceNormal(s,B),n.height,B);S.center=r.Cartesian3.add(s,f,S.center),S.radius=y,f=r.Cartesian3.multiplyByScalar(m.geodeticSurfaceNormal(s,f),n.extrudedHeight,f),v.center=r.Cartesian3.add(s,f,v.center),v.radius=y;let d=O.EllipseGeometryLibrary.computeEllipsePositions(n,!1,!0).outerPositions;const u=new k.GeometryAttributes({position:new g.GeometryAttribute({componentDatatype:L.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O.EllipseGeometryLibrary.raisePositionsToHeight(d,n,!0)})});d=u.position.values;const w=G.BoundingSphere.union(S,v);let o=d.length/3;if(a.defined(n.offsetAttribute)){let _=new Uint8Array(o);if(n.offsetAttribute===D.GeometryOffsetAttribute.TOP)_=_.fill(1,0,o/2);else{const P=n.offsetAttribute===D.GeometryOffsetAttribute.NONE?0:1;_=_.fill(P)}u.applyOffset=new g.GeometryAttribute({componentDatatype:L.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:_})}let E=a.defaultValue(n.numberOfVerticalLines,16);E=V.CesiumMath.clamp(E,0,o/2);const A=T.IndexDatatype.createTypedArray(o,2*o+2*E);o/=2;let c,N,M=0;for(c=0;c<o;++c)A[M++]=c,A[M++]=(c+1)%o,A[M++]=c+o,A[M++]=(c+1)%o+o;if(E>0){const _=Math.min(E,o);N=Math.round(o/_);const P=Math.min(N*E,o);for(c=0;c<P;c+=N)A[M++]=c,A[M++]=c+o}return{boundingSphere:w,attributes:u,indices:A}}(h);else if(l=function(n){const s=n.center;b=r.Cartesian3.multiplyByScalar(n.ellipsoid.geodeticSurfaceNormal(s,b),n.height,b),b=r.Cartesian3.add(s,b,b);const m=new G.BoundingSphere(b,n.semiMajorAxis),y=O.EllipseGeometryLibrary.computeEllipsePositions(n,!1,!0).outerPositions,f=new k.GeometryAttributes({position:new g.GeometryAttribute({componentDatatype:L.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O.EllipseGeometryLibrary.raisePositionsToHeight(y,n,!1)})}),d=y.length/3,u=T.IndexDatatype.createTypedArray(d,2*d);let w=0;for(let o=0;o<d;++o)u[w++]=o,u[w++]=(o+1)%d;return{boundingSphere:m,attributes:f,indices:u}}(h),a.defined(e._offsetAttribute)){const n=l.attributes.position.values.length,s=e._offsetAttribute===D.GeometryOffsetAttribute.NONE?0:1,m=new Uint8Array(n/3).fill(s);l.attributes.applyOffset=new g.GeometryAttribute({componentDatatype:L.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:m})}return new g.Geometry({attributes:l.attributes,indices:l.indices,primitiveType:g.PrimitiveType.LINES,boundingSphere:l.boundingSphere,offsetAttribute:e._offsetAttribute})},I.EllipseOutlineGeometry=x});
