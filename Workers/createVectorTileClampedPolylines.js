/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./AttributeCompression-6f93ad0c","./Matrix3-2955527a","./combine-55e9f355","./IndexDatatype-7ccfd280","./Math-1fe079f3","./Matrix2-462b83d3","./createTaskProcessorWorker","./ComponentDatatype-f9ac3ed8","./defaultValue-ebbd2e4d","./WebGLConstants-544672c2","./RuntimeError-38a08050"],function(et,t,st,j,M,J,nt,yt,Nt,kt,xt){"use strict";const rt=Math.cos(M.CesiumMath.toRadians(150)),it=new t.Cartographic,ot=new t.Cartesian3,dt=new t.Cartographic,ct=new t.Cartographic;function K(l){const a=8*l,f=3*a,m=4*a;this.startEllipsoidNormals=new Float32Array(f),this.endEllipsoidNormals=new Float32Array(f),this.startPositionAndHeights=new Float32Array(m),this.startFaceNormalAndVertexCornerIds=new Float32Array(m),this.endPositionAndHeights=new Float32Array(m),this.endFaceNormalAndHalfWidths=new Float32Array(m),this.vertexBatchIds=new Uint16Array(a),this.indices=j.IndexDatatype.createTypedArray(a,36*l),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}const Q=new t.Cartesian3,lt=new t.Cartesian3;function X(l,a,f,m,r){const H=t.Cartesian3.subtract(f,a,lt);let b=t.Cartesian3.subtract(a,l,Q);return t.Cartesian3.normalize(H,H),t.Cartesian3.normalize(b,b),t.Cartesian3.dot(H,b)<rt&&(b=t.Cartesian3.multiplyByScalar(b,-1,Q)),t.Cartesian3.add(H,b,r),t.Cartesian3.equals(r,t.Cartesian3.ZERO)&&(r=t.Cartesian3.subtract(l,a)),t.Cartesian3.cross(r,m,r),t.Cartesian3.cross(m,r,r),t.Cartesian3.normalize(r,r),r}const $=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],tt=$.length,at=new t.Cartesian3,ft=new t.Cartesian3,ut=new t.Cartesian3,ht=new t.Cartesian3,Ct=new t.Cartesian3;K.prototype.addVolume=function(l,a,f,m,r,H,b,V,O,P){let A=t.Cartesian3.add(a,O,at);const S=P.geodeticSurfaceNormal(A,ft);A=t.Cartesian3.add(f,O,at);const R=P.geodeticSurfaceNormal(A,ht),e=X(l,a,f,S,ut),g=X(m,f,a,R,Ct),U=this.startEllipsoidNormals,T=this.endEllipsoidNormals,v=this.startPositionAndHeights,W=this.startFaceNormalAndVertexCornerIds,z=this.endPositionAndHeights,n=this.endFaceNormalAndHalfWidths,D=this.vertexBatchIds;let s,y=this.batchIdOffset,E=this.vec3Offset,u=this.vec4Offset;for(s=0;s<8;s++)t.Cartesian3.pack(S,U,E),t.Cartesian3.pack(R,T,E),t.Cartesian3.pack(a,v,u),v[u+3]=r,t.Cartesian3.pack(f,z,u),z[u+3]=H,t.Cartesian3.pack(e,W,u),W[u+3]=s,t.Cartesian3.pack(g,n,u),n[u+3]=b,D[y++]=V,E+=3,u+=4;this.batchIdOffset=y,this.vec3Offset=E,this.vec4Offset=u;const q=this.indices,o=this.volumeStartIndex,C=this.indexOffset;for(s=0;s<tt;s++)q[C+s]=$[s]+o;this.volumeStartIndex+=8,this.indexOffset+=tt};const pt=new J.Rectangle,mt=new t.Ellipsoid,bt=new t.Cartesian3,Z=new t.Cartesian3,At=new t.Cartesian3,wt=new t.Cartesian3,Y=new t.Cartesian3;return nt(function(l,a){const f=new Uint16Array(l.positions),m=new Uint16Array(l.widths),r=new Uint32Array(l.counts),H=new Uint16Array(l.batchIds),b=pt,V=mt,O=bt,P=new Float64Array(l.packedBuffer);let A=0;const S=P[A++],R=P[A++];let e;J.Rectangle.unpack(P,A,b),A+=J.Rectangle.packedLength,t.Ellipsoid.unpack(P,A,V),A+=t.Ellipsoid.packedLength,t.Cartesian3.unpack(P,A,O);let g=f.length/3;const U=f.subarray(0,g),T=f.subarray(g,2*g),v=f.subarray(2*g,3*g);et.AttributeCompression.zigZagDeltaDecode(U,T,v),function(o,C,N,d){const p=d.length,c=o.length,k=new Uint8Array(c),x=dt,I=ct;let h=0;for(let i=0;i<p;i++){const F=d[i];let B=F;for(let L=1;L<F;L++){const _=h+L,G=_-1;I.longitude=o[_],I.latitude=C[_],x.longitude=o[G],x.latitude=C[G],t.Cartographic.equals(I,x)&&(B--,k[G]=1)}d[i]=B,h+=F}let w=0;for(let i=0;i<c;i++)k[i]!==1&&(o[w]=o[i],C[w]=C[i],N[w]=N[i],w++)}(U,T,v,r);const W=r.length;let z=0;for(e=0;e<W;e++)z+=r[e]-1;const n=new K(z),D=function(o,C,N,d,p,c,k){const x=o.length,I=new Float64Array(3*x);for(let h=0;h<x;++h){const w=o[h],i=C[h],F=N[h],B=M.CesiumMath.lerp(d.west,d.east,w/32767),L=M.CesiumMath.lerp(d.south,d.north,i/32767),_=M.CesiumMath.lerp(p,c,F/32767),G=t.Cartographic.fromRadians(B,L,_,it),gt=k.cartographicToCartesian(G,ot);t.Cartesian3.pack(gt,I,3*h)}return I}(U,T,v,b,S,R,V);g=U.length;const s=new Float32Array(3*g);for(e=0;e<g;++e)s[3*e]=D[3*e]-O.x,s[3*e+1]=D[3*e+1]-O.y,s[3*e+2]=D[3*e+2]-O.z;let y=0,E=0;for(e=0;e<W;e++){const o=r[e]-1,C=.5*m[e],N=H[e],d=y;for(let p=0;p<o;p++){const c=t.Cartesian3.unpack(s,y,At),k=t.Cartesian3.unpack(s,y+3,wt);let x=v[E],I=v[E+1];x=M.CesiumMath.lerp(S,R,x/32767),I=M.CesiumMath.lerp(S,R,I/32767),E++;let h=Z,w=Y;if(p===0){const i=d+3*o,F=t.Cartesian3.unpack(s,i,Z);if(t.Cartesian3.equals(F,c))t.Cartesian3.unpack(s,i-3,h);else{const B=t.Cartesian3.subtract(c,k,Z);h=t.Cartesian3.add(B,c,Z)}}else t.Cartesian3.unpack(s,y-3,h);if(p===o-1){const i=t.Cartesian3.unpack(s,d,Y);if(t.Cartesian3.equals(i,k))t.Cartesian3.unpack(s,d+3,w);else{const F=t.Cartesian3.subtract(k,c,Y);w=t.Cartesian3.add(F,k,Y)}}else t.Cartesian3.unpack(s,y+6,w);n.addVolume(h,c,k,w,x,I,C,N,O,V),y+=3}y+=3,E++}const u=n.indices;a.push(n.startEllipsoidNormals.buffer),a.push(n.endEllipsoidNormals.buffer),a.push(n.startPositionAndHeights.buffer),a.push(n.startFaceNormalAndVertexCornerIds.buffer),a.push(n.endPositionAndHeights.buffer),a.push(n.endFaceNormalAndHalfWidths.buffer),a.push(n.vertexBatchIds.buffer),a.push(u.buffer);let q={indexDatatype:u.BYTES_PER_ELEMENT===2?j.IndexDatatype.UNSIGNED_SHORT:j.IndexDatatype.UNSIGNED_INT,startEllipsoidNormals:n.startEllipsoidNormals.buffer,endEllipsoidNormals:n.endEllipsoidNormals.buffer,startPositionAndHeights:n.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:n.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:n.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:n.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:n.vertexBatchIds.buffer,indices:u.buffer};if(l.keepDecodedPositions){const o=function(C){const N=C.length,d=new Uint32Array(N+1);let p=0;for(let c=0;c<N;++c)d[c]=p,p+=C[c];return d[N]=p,d}(r);a.push(D.buffer,o.buffer),q=st.combine(q,{decodedPositions:D.buffer,decodedPositionOffsets:o.buffer})}return q})});
