/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Matrix3-2955527a","./defaultValue-ebbd2e4d","./Math-1fe079f3"],function(w,p,P,a){"use strict";function V(t,i,h){if(t===0)return i*h;const s=t*t,o=s*s,n=o*s,l=n*s,d=l*s,u=d*s,r=h;return i*((1-s/4-3*o/64-5*n/256-175*l/16384-441*d/65536-4851*u/1048576)*r-(3*s/8+3*o/32+45*n/1024+105*l/4096+2205*d/131072+6237*u/524288)*Math.sin(2*r)+(15*o/256+45*n/1024+525*l/16384+1575*d/65536+155925*u/8388608)*Math.sin(4*r)-(35*n/3072+175*l/12288+3675*d/262144+13475*u/1048576)*Math.sin(6*r)+(315*l/131072+2205*d/524288+43659*u/8388608)*Math.sin(8*r)-(693*d/1310720+6237*u/5242880)*Math.sin(10*r)+1001*u/8388608*Math.sin(12*r))}function S(t,i){if(t===0)return Math.log(Math.tan(.5*(a.CesiumMath.PI_OVER_TWO+i)));const h=t*Math.sin(i);return Math.log(Math.tan(.5*(a.CesiumMath.PI_OVER_TWO+i)))-t/2*Math.log((1+h)/(1-h))}const x=new p.Cartesian3,b=new p.Cartesian3;function v(t,i,h,s){p.Cartesian3.normalize(s.cartographicToCartesian(i,b),x),p.Cartesian3.normalize(s.cartographicToCartesian(h,b),b);const o=s.maximumRadius,n=s.minimumRadius,l=o*o,d=n*n;t._ellipticitySquared=(l-d)/l,t._ellipticity=Math.sqrt(t._ellipticitySquared),t._start=p.Cartographic.clone(i,t._start),t._start.height=0,t._end=p.Cartographic.clone(h,t._end),t._end.height=0,t._heading=function(u,r,m,g,f){const E=S(u._ellipticity,m),W=S(u._ellipticity,f);return Math.atan2(a.CesiumMath.negativePiToPi(g-r),W-E)}(t,i.longitude,i.latitude,h.longitude,h.latitude),t._distance=function(u,r,m,g,f,E,W){const e=u._heading,c=E-g;let y=0;if(a.CesiumMath.equalsEpsilon(Math.abs(e),a.CesiumMath.PI_OVER_TWO,a.CesiumMath.EPSILON8))if(r===m)y=r*Math.cos(f)*a.CesiumMath.negativePiToPi(c);else{const I=Math.sin(f);y=r*Math.cos(f)*a.CesiumMath.negativePiToPi(c)/Math.sqrt(1-u._ellipticitySquared*I*I)}else{const I=V(u._ellipticity,r,f);y=(V(u._ellipticity,r,W)-I)/Math.cos(e)}return Math.abs(y)}(t,s.maximumRadius,s.minimumRadius,i.longitude,i.latitude,h.longitude,h.latitude)}function L(t,i,h,s,o,n){if(h===0)return p.Cartographic.clone(t,n);const l=o*o;let d,u,r;if(Math.abs(a.CesiumMath.PI_OVER_TWO-Math.abs(i))>a.CesiumMath.EPSILON8){u=function(f,E,W){const e=f/W;if(E===0)return e;const c=e*e,y=c*e,I=y*e,T=E*E,q=T*T,R=q*T,C=R*T,_=C*T,M=_*T,N=Math.sin(2*e),D=Math.cos(2*e),U=Math.sin(4*e),z=Math.cos(4*e),G=Math.sin(6*e),j=Math.cos(6*e),F=Math.sin(8*e),H=Math.cos(8*e),k=Math.sin(10*e);return e+e*T/4+7*e*q/64+15*e*R/256+579*e*C/16384+1515*e*_/65536+16837*e*M/1048576+(3*e*q/16+45*e*R/256-e*(32*c-561)*C/4096-e*(232*c-1677)*_/16384+e*(399985-90560*c+512*I)*M/5242880)*D+(21*e*R/256+483*e*C/4096-e*(224*c-1969)*_/16384-e*(33152*c-112599)*M/1048576)*z+(151*e*C/4096+4681*e*_/65536+1479*e*M/16384-453*y*M/32768)*j+(1097*e*_/65536+42783*e*M/1048576)*H+8011*e*M/1048576*Math.cos(10*e)+(3*T/8+3*q/16+213*R/2048-3*c*R/64+255*C/4096-33*c*C/512+20861*_/524288-33*c*_/512+I*_/1024+28273*M/1048576-471*c*M/8192+9*I*M/4096)*N+(21*q/256+21*R/256+533*C/8192-21*c*C/512+197*_/4096-315*c*_/4096+584039*M/16777216-12517*c*M/131072+7*I*M/2048)*U+(151*R/6144+151*C/4096+5019*_/131072-453*c*_/16384+26965*M/786432-8607*c*M/131072)*G+(1097*C/131072+1097*_/65536+225797*M/10485760-1097*c*M/65536)*F+(8011*_/2621440+8011*M/1048576)*k+293393*M/251658240*Math.sin(12*e)}(V(o,s,t.latitude)+h*Math.cos(i),o,s);const m=S(o,t.latitude),g=S(o,u);r=Math.tan(i)*(g-m),d=a.CesiumMath.negativePiToPi(t.longitude+r)}else{let m;if(u=t.latitude,o===0)m=s*Math.cos(t.latitude);else{const g=Math.sin(t.latitude);m=s*Math.cos(t.latitude)/Math.sqrt(1-l*g*g)}r=h/m,d=i>0?a.CesiumMath.negativePiToPi(t.longitude+r):a.CesiumMath.negativePiToPi(t.longitude-r)}return P.defined(n)?(n.longitude=d,n.latitude=u,n.height=0,n):new p.Cartographic(d,u,0)}function O(t,i,h){const s=P.defaultValue(h,p.Ellipsoid.WGS84);this._ellipsoid=s,this._start=new p.Cartographic,this._end=new p.Cartographic,this._heading=void 0,this._distance=void 0,this._ellipticity=void 0,this._ellipticitySquared=void 0,P.defined(t)&&P.defined(i)&&v(this,t,i,s)}Object.defineProperties(O.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},heading:{get:function(){return this._heading}}}),O.fromStartHeadingDistance=function(t,i,h,s,o){const n=P.defaultValue(s,p.Ellipsoid.WGS84),l=n.maximumRadius,d=n.minimumRadius,u=l*l,r=d*d,m=Math.sqrt((u-r)/u),g=L(t,i=a.CesiumMath.negativePiToPi(i),h,n.maximumRadius,m);return!P.defined(o)||P.defined(s)&&!s.equals(o.ellipsoid)?new O(t,g,n):(o.setEndPoints(t,g),o)},O.prototype.setEndPoints=function(t,i){v(this,t,i,this._ellipsoid)},O.prototype.interpolateUsingFraction=function(t,i){return this.interpolateUsingSurfaceDistance(t*this._distance,i)},O.prototype.interpolateUsingSurfaceDistance=function(t,i){return L(this._start,this._heading,t,this._ellipsoid.maximumRadius,this._ellipticity,i)},O.prototype.findIntersectionWithLongitude=function(t,i){const h=this._ellipticity,s=this._heading,o=Math.abs(s),n=this._start;if(t=a.CesiumMath.negativePiToPi(t),a.CesiumMath.equalsEpsilon(Math.abs(t),Math.PI,a.CesiumMath.EPSILON14)&&(t=a.CesiumMath.sign(n.longitude)*Math.PI),P.defined(i)||(i=new p.Cartographic),Math.abs(a.CesiumMath.PI_OVER_TWO-o)<=a.CesiumMath.EPSILON8)return i.longitude=t,i.latitude=n.latitude,i.height=0,i;if(a.CesiumMath.equalsEpsilon(Math.abs(a.CesiumMath.PI_OVER_TWO-o),a.CesiumMath.PI_OVER_TWO,a.CesiumMath.EPSILON8))return a.CesiumMath.equalsEpsilon(t,n.longitude,a.CesiumMath.EPSILON12)?void 0:(i.longitude=t,i.latitude=a.CesiumMath.PI_OVER_TWO*a.CesiumMath.sign(a.CesiumMath.PI_OVER_TWO-s),i.height=0,i);const l=n.latitude,d=h*Math.sin(l),u=Math.tan(.5*(a.CesiumMath.PI_OVER_TWO+l))*Math.exp((t-n.longitude)/Math.tan(s)),r=(1+d)/(1-d);let m,g=n.latitude;do{m=g;const f=h*Math.sin(m),E=(1+f)/(1-f);g=2*Math.atan(u*Math.pow(E/r,h/2))-a.CesiumMath.PI_OVER_TWO}while(!a.CesiumMath.equalsEpsilon(g,m,a.CesiumMath.EPSILON12));return i.longitude=t,i.latitude=g,i.height=0,i},O.prototype.findIntersectionWithLatitude=function(t,i){const h=this._ellipticity,s=this._heading,o=this._start;if(a.CesiumMath.equalsEpsilon(Math.abs(s),a.CesiumMath.PI_OVER_TWO,a.CesiumMath.EPSILON8))return;const n=S(h,o.latitude),l=S(h,t),d=Math.tan(s)*(l-n),u=a.CesiumMath.negativePiToPi(o.longitude+d);return P.defined(i)?(i.longitude=u,i.latitude=t,i.height=0,i):new p.Cartographic(u,t,0)},w.EllipsoidRhumbLine=O});
