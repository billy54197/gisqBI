/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Transforms-5b74e989","./Matrix2-462b83d3","./Matrix3-2955527a","./defaultValue-ebbd2e4d","./EllipsoidTangentPlane-da4fdd19","./Math-1fe079f3","./Plane-7e97483e"],function(H,I,O,a,g,J,U,R){"use strict";function u(t,e){this.center=a.Cartesian3.clone(g.defaultValue(t,a.Cartesian3.ZERO)),this.halfAxes=a.Matrix3.clone(g.defaultValue(e,a.Matrix3.ZERO))}u.packedLength=a.Cartesian3.packedLength+a.Matrix3.packedLength,u.pack=function(t,e,i){return i=g.defaultValue(i,0),a.Cartesian3.pack(t.center,e,i),a.Matrix3.pack(t.halfAxes,e,i+a.Cartesian3.packedLength),e},u.unpack=function(t,e,i){return e=g.defaultValue(e,0),g.defined(i)||(i=new u),a.Cartesian3.unpack(t,e,i.center),a.Matrix3.unpack(t,e+a.Cartesian3.packedLength,i.halfAxes),i};const K=new a.Cartesian3,Q=new a.Cartesian3,$=new a.Cartesian3,aa=new a.Cartesian3,ea=new a.Cartesian3,ta=new a.Cartesian3,ra=new a.Matrix3,ia={unitary:new a.Matrix3,diagonal:new a.Matrix3};u.fromPoints=function(t,e){if(g.defined(e)||(e=new u),!g.defined(t)||t.length===0)return e.halfAxes=a.Matrix3.ZERO,e.center=a.Cartesian3.ZERO,e;let i;const c=t.length,n=a.Cartesian3.clone(t[0],K);for(i=1;i<c;i++)a.Cartesian3.add(n,t[i],n);const o=1/c;a.Cartesian3.multiplyByScalar(n,o,n);let s,m=0,d=0,h=0,M=0,r=0,l=0;for(i=0;i<c;i++)s=a.Cartesian3.subtract(t[i],n,Q),m+=s.x*s.x,d+=s.x*s.y,h+=s.x*s.z,M+=s.y*s.y,r+=s.y*s.z,l+=s.z*s.z;m*=o,d*=o,h*=o,M*=o,r*=o,l*=o;const C=ra;C[0]=m,C[1]=d,C[2]=h,C[3]=d,C[4]=M,C[5]=r,C[6]=h,C[7]=r,C[8]=l;const w=a.Matrix3.computeEigenDecomposition(C,ia),b=a.Matrix3.clone(w.unitary,e.halfAxes);let p=a.Matrix3.getColumn(b,0,aa),f=a.Matrix3.getColumn(b,1,ea),x=a.Matrix3.getColumn(b,2,ta),N=-Number.MAX_VALUE,y=-Number.MAX_VALUE,E=-Number.MAX_VALUE,A=Number.MAX_VALUE,S=Number.MAX_VALUE,T=Number.MAX_VALUE;for(i=0;i<c;i++)s=t[i],N=Math.max(a.Cartesian3.dot(p,s),N),y=Math.max(a.Cartesian3.dot(f,s),y),E=Math.max(a.Cartesian3.dot(x,s),E),A=Math.min(a.Cartesian3.dot(p,s),A),S=Math.min(a.Cartesian3.dot(f,s),S),T=Math.min(a.Cartesian3.dot(x,s),T);p=a.Cartesian3.multiplyByScalar(p,.5*(A+N),p),f=a.Cartesian3.multiplyByScalar(f,.5*(S+y),f),x=a.Cartesian3.multiplyByScalar(x,.5*(T+E),x);const L=a.Cartesian3.add(p,f,e.center);a.Cartesian3.add(L,x,L);const P=$;return P.x=N-A,P.y=y-S,P.z=E-T,a.Cartesian3.multiplyByScalar(P,.5,P),a.Matrix3.multiplyByScale(e.halfAxes,P,e.halfAxes),e};const k=new a.Cartesian3,sa=new a.Cartesian3;function W(t,e,i,c,n,o,s,m,d,h,M){g.defined(M)||(M=new u);const r=M.halfAxes;a.Matrix3.setColumn(r,0,e,r),a.Matrix3.setColumn(r,1,i,r),a.Matrix3.setColumn(r,2,c,r);let l=k;l.x=(n+o)/2,l.y=(s+m)/2,l.z=(d+h)/2;const C=sa;C.x=(o-n)/2,C.y=(m-s)/2,C.z=(h-d)/2;const w=M.center;return l=a.Matrix3.multiplyByVector(r,l,l),a.Cartesian3.add(t,l,w),a.Matrix3.multiplyByScale(r,C,r),M}const X=new a.Cartographic,na=new a.Cartesian3,oa=new a.Cartographic,Ca=new a.Cartographic,ca=new a.Cartographic,ua=new a.Cartographic,la=new a.Cartographic,da=new a.Cartesian3,q=new a.Cartesian3,ha=new a.Cartesian3,D=new a.Cartesian3,xa=new a.Cartesian3,ma=new O.Cartesian2,Ma=new O.Cartesian2,fa=new O.Cartesian2,pa=new O.Cartesian2,wa=new O.Cartesian2,ga=new a.Cartesian3,ba=new a.Cartesian3,ya=new a.Cartesian3,Na=new a.Cartesian3,Ta=new O.Cartesian2,Oa=new a.Cartesian3,Aa=new a.Cartesian3,Pa=new a.Cartesian3,Ia=new R.Plane(a.Cartesian3.UNIT_X,0);u.fromRectangle=function(t,e,i,c,n){let o,s,m,d,h,M,r;if(e=g.defaultValue(e,0),i=g.defaultValue(i,0),c=g.defaultValue(c,a.Ellipsoid.WGS84),t.width<=U.CesiumMath.PI){const A=O.Rectangle.center(t,X),S=c.cartographicToCartesian(A,na),T=new J.EllipsoidTangentPlane(S,c);r=T.plane;const L=A.longitude,P=t.south<0&&t.north>0?0:A.latitude,ka=a.Cartographic.fromRadians(L,t.north,i,oa),z=a.Cartographic.fromRadians(t.west,t.north,i,Ca),Wa=a.Cartographic.fromRadians(t.west,P,i,ca),B=a.Cartographic.fromRadians(t.west,t.south,i,ua),Xa=a.Cartographic.fromRadians(L,t.south,i,la),qa=c.cartographicToCartesian(ka,da);let V=c.cartographicToCartesian(z,q);const Da=c.cartographicToCartesian(Wa,ha);let _=c.cartographicToCartesian(B,D);const ja=c.cartographicToCartesian(Xa,xa),Za=T.projectPointToNearestOnPlane(qa,ma),G=T.projectPointToNearestOnPlane(V,Ma),Ya=T.projectPointToNearestOnPlane(Da,fa),F=T.projectPointToNearestOnPlane(_,pa),va=T.projectPointToNearestOnPlane(ja,wa);return o=Math.min(G.x,Ya.x,F.x),s=-o,d=Math.max(G.y,Za.y),m=Math.min(F.y,va.y),z.height=B.height=e,V=c.cartographicToCartesian(z,q),_=c.cartographicToCartesian(B,D),h=Math.min(R.Plane.getPointDistance(r,V),R.Plane.getPointDistance(r,_)),M=i,W(T.origin,T.xAxis,T.yAxis,T.zAxis,o,s,m,d,h,M,n)}const l=t.south>0,C=t.north<0,w=l?t.south:C?t.north:0,b=O.Rectangle.center(t,X).longitude,p=a.Cartesian3.fromRadians(b,w,i,c,ga);p.z=0;const f=Math.abs(p.x)<U.CesiumMath.EPSILON10&&Math.abs(p.y)<U.CesiumMath.EPSILON10?a.Cartesian3.UNIT_X:a.Cartesian3.normalize(p,ba),x=a.Cartesian3.UNIT_Z,N=a.Cartesian3.cross(f,x,ya);r=R.Plane.fromPointNormal(p,f,Ia);const y=a.Cartesian3.fromRadians(b+U.CesiumMath.PI_OVER_TWO,w,i,c,Na);s=a.Cartesian3.dot(R.Plane.projectPointOntoPlane(r,y,Ta),N),o=-s,d=a.Cartesian3.fromRadians(0,t.north,C?e:i,c,Oa).z,m=a.Cartesian3.fromRadians(0,t.south,l?e:i,c,Aa).z;const E=a.Cartesian3.fromRadians(t.east,w,i,c,Pa);return h=R.Plane.getPointDistance(r,E),M=0,W(p,N,x,f,o,s,m,d,h,M,n)},u.fromTransformation=function(t,e){return g.defined(e)||(e=new u),e.center=O.Matrix4.getTranslation(t,e.center),e.halfAxes=O.Matrix4.getMatrix3(t,e.halfAxes),e.halfAxes=a.Matrix3.multiplyByScalar(e.halfAxes,.5,e.halfAxes),e},u.clone=function(t,e){if(g.defined(t))return g.defined(e)?(a.Cartesian3.clone(t.center,e.center),a.Matrix3.clone(t.halfAxes,e.halfAxes),e):new u(t.center,t.halfAxes)},u.intersectPlane=function(t,e){const i=t.center,c=e.normal,n=t.halfAxes,o=c.x,s=c.y,m=c.z,d=Math.abs(o*n[a.Matrix3.COLUMN0ROW0]+s*n[a.Matrix3.COLUMN0ROW1]+m*n[a.Matrix3.COLUMN0ROW2])+Math.abs(o*n[a.Matrix3.COLUMN1ROW0]+s*n[a.Matrix3.COLUMN1ROW1]+m*n[a.Matrix3.COLUMN1ROW2])+Math.abs(o*n[a.Matrix3.COLUMN2ROW0]+s*n[a.Matrix3.COLUMN2ROW1]+m*n[a.Matrix3.COLUMN2ROW2]),h=a.Cartesian3.dot(c,i)+e.distance;return h<=-d?I.Intersect.OUTSIDE:h>=d?I.Intersect.INSIDE:I.Intersect.INTERSECTING};const j=new a.Cartesian3,Z=new a.Cartesian3,Y=new a.Cartesian3,Ra=new a.Cartesian3,v=new a.Cartesian3,Ea=new a.Cartesian3;u.distanceSquaredTo=function(t,e){const i=a.Cartesian3.subtract(e,t.center,k),c=t.halfAxes;let n=a.Matrix3.getColumn(c,0,j),o=a.Matrix3.getColumn(c,1,Z),s=a.Matrix3.getColumn(c,2,Y);const m=a.Cartesian3.magnitude(n),d=a.Cartesian3.magnitude(o),h=a.Cartesian3.magnitude(s);let M=!0,r=!0,l=!0;m>0?a.Cartesian3.divideByScalar(n,m,n):M=!1,d>0?a.Cartesian3.divideByScalar(o,d,o):r=!1,h>0?a.Cartesian3.divideByScalar(s,h,s):l=!1;const C=!M+!r+!l;let w,b,p;if(C===1){let y=n;w=o,b=s,r?l||(y=s,b=n):(y=o,w=n),p=a.Cartesian3.cross(w,b,v),y===n?n=p:y===o?o=p:y===s&&(s=p)}else if(C===2){w=n,r?w=o:l&&(w=s);let y=a.Cartesian3.UNIT_Y;y.equalsEpsilon(w,U.CesiumMath.EPSILON3)&&(y=a.Cartesian3.UNIT_X),b=a.Cartesian3.cross(w,y,Ra),a.Cartesian3.normalize(b,b),p=a.Cartesian3.cross(w,b,v),a.Cartesian3.normalize(p,p),w===n?(o=b,s=p):w===o?(s=b,n=p):w===s&&(n=b,o=p)}else C===3&&(n=a.Cartesian3.UNIT_X,o=a.Cartesian3.UNIT_Y,s=a.Cartesian3.UNIT_Z);const f=Ea;f.x=a.Cartesian3.dot(i,n),f.y=a.Cartesian3.dot(i,o),f.z=a.Cartesian3.dot(i,s);let x,N=0;return f.x<-m?(x=f.x+m,N+=x*x):f.x>m&&(x=f.x-m,N+=x*x),f.y<-d?(x=f.y+d,N+=x*x):f.y>d&&(x=f.y-d,N+=x*x),f.z<-h?(x=f.z+h,N+=x*x):f.z>h&&(x=f.z-h,N+=x*x),N};const Sa=new a.Cartesian3,Ua=new a.Cartesian3;u.computePlaneDistances=function(t,e,i,c){g.defined(c)||(c=new I.Interval);let n=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;const s=t.center,m=t.halfAxes,d=a.Matrix3.getColumn(m,0,j),h=a.Matrix3.getColumn(m,1,Z),M=a.Matrix3.getColumn(m,2,Y),r=a.Cartesian3.add(d,h,Sa);a.Cartesian3.add(r,M,r),a.Cartesian3.add(r,s,r);const l=a.Cartesian3.subtract(r,e,Ua);let C=a.Cartesian3.dot(i,l);return n=Math.min(C,n),o=Math.max(C,o),a.Cartesian3.add(s,d,r),a.Cartesian3.add(r,h,r),a.Cartesian3.subtract(r,M,r),a.Cartesian3.subtract(r,e,l),C=a.Cartesian3.dot(i,l),n=Math.min(C,n),o=Math.max(C,o),a.Cartesian3.add(s,d,r),a.Cartesian3.subtract(r,h,r),a.Cartesian3.add(r,M,r),a.Cartesian3.subtract(r,e,l),C=a.Cartesian3.dot(i,l),n=Math.min(C,n),o=Math.max(C,o),a.Cartesian3.add(s,d,r),a.Cartesian3.subtract(r,h,r),a.Cartesian3.subtract(r,M,r),a.Cartesian3.subtract(r,e,l),C=a.Cartesian3.dot(i,l),n=Math.min(C,n),o=Math.max(C,o),a.Cartesian3.subtract(s,d,r),a.Cartesian3.add(r,h,r),a.Cartesian3.add(r,M,r),a.Cartesian3.subtract(r,e,l),C=a.Cartesian3.dot(i,l),n=Math.min(C,n),o=Math.max(C,o),a.Cartesian3.subtract(s,d,r),a.Cartesian3.add(r,h,r),a.Cartesian3.subtract(r,M,r),a.Cartesian3.subtract(r,e,l),C=a.Cartesian3.dot(i,l),n=Math.min(C,n),o=Math.max(C,o),a.Cartesian3.subtract(s,d,r),a.Cartesian3.subtract(r,h,r),a.Cartesian3.add(r,M,r),a.Cartesian3.subtract(r,e,l),C=a.Cartesian3.dot(i,l),n=Math.min(C,n),o=Math.max(C,o),a.Cartesian3.subtract(s,d,r),a.Cartesian3.subtract(r,h,r),a.Cartesian3.subtract(r,M,r),a.Cartesian3.subtract(r,e,l),C=a.Cartesian3.dot(i,l),n=Math.min(C,n),o=Math.max(C,o),c.start=n,c.stop=o,c};const La=new a.Cartesian3,za=new a.Cartesian3,Ba=new a.Cartesian3;u.computeCorners=function(t,e){g.defined(e)||(e=[new a.Cartesian3,new a.Cartesian3,new a.Cartesian3,new a.Cartesian3,new a.Cartesian3,new a.Cartesian3,new a.Cartesian3,new a.Cartesian3]);const i=t.center,c=t.halfAxes,n=a.Matrix3.getColumn(c,0,La),o=a.Matrix3.getColumn(c,1,za),s=a.Matrix3.getColumn(c,2,Ba);return a.Cartesian3.clone(i,e[0]),a.Cartesian3.subtract(e[0],n,e[0]),a.Cartesian3.subtract(e[0],o,e[0]),a.Cartesian3.subtract(e[0],s,e[0]),a.Cartesian3.clone(i,e[1]),a.Cartesian3.subtract(e[1],n,e[1]),a.Cartesian3.subtract(e[1],o,e[1]),a.Cartesian3.add(e[1],s,e[1]),a.Cartesian3.clone(i,e[2]),a.Cartesian3.subtract(e[2],n,e[2]),a.Cartesian3.add(e[2],o,e[2]),a.Cartesian3.subtract(e[2],s,e[2]),a.Cartesian3.clone(i,e[3]),a.Cartesian3.subtract(e[3],n,e[3]),a.Cartesian3.add(e[3],o,e[3]),a.Cartesian3.add(e[3],s,e[3]),a.Cartesian3.clone(i,e[4]),a.Cartesian3.add(e[4],n,e[4]),a.Cartesian3.subtract(e[4],o,e[4]),a.Cartesian3.subtract(e[4],s,e[4]),a.Cartesian3.clone(i,e[5]),a.Cartesian3.add(e[5],n,e[5]),a.Cartesian3.subtract(e[5],o,e[5]),a.Cartesian3.add(e[5],s,e[5]),a.Cartesian3.clone(i,e[6]),a.Cartesian3.add(e[6],n,e[6]),a.Cartesian3.add(e[6],o,e[6]),a.Cartesian3.subtract(e[6],s,e[6]),a.Cartesian3.clone(i,e[7]),a.Cartesian3.add(e[7],n,e[7]),a.Cartesian3.add(e[7],o,e[7]),a.Cartesian3.add(e[7],s,e[7]),e};const Va=new a.Matrix3;u.computeTransformation=function(t,e){g.defined(e)||(e=new O.Matrix4);const i=t.center,c=a.Matrix3.multiplyByUniformScale(t.halfAxes,2,Va);return O.Matrix4.fromRotationTranslation(c,i,e)};const _a=new I.BoundingSphere;u.isOccluded=function(t,e){const i=I.BoundingSphere.fromOrientedBoundingBox(t,_a);return!e.isBoundingSphereVisible(i)},u.prototype.intersectPlane=function(t){return u.intersectPlane(this,t)},u.prototype.distanceSquaredTo=function(t){return u.distanceSquaredTo(this,t)},u.prototype.computePlaneDistances=function(t,e,i){return u.computePlaneDistances(this,t,e,i)},u.prototype.computeCorners=function(t){return u.computeCorners(this,t)},u.prototype.computeTransformation=function(t){return u.computeTransformation(this,t)},u.prototype.isOccluded=function(t){return u.isOccluded(this,t)},u.equals=function(t,e){return t===e||g.defined(t)&&g.defined(e)&&a.Cartesian3.equals(t.center,e.center)&&a.Matrix3.equals(t.halfAxes,e.halfAxes)},u.prototype.clone=function(t){return u.clone(this,t)},u.prototype.equals=function(t){return u.equals(this,t)},H.OrientedBoundingBox=u});
