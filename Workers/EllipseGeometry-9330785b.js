/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Transforms-5b74e989","./Matrix2-462b83d3","./Matrix3-2955527a","./ComponentDatatype-f9ac3ed8","./defaultValue-ebbd2e4d","./EllipseGeometryLibrary-b919d7ec","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryInstance-4ef1b8a5","./GeometryOffsetAttribute-739bec2c","./GeometryPipeline-3cfa9822","./IndexDatatype-7ccfd280","./Math-1fe079f3","./VertexFormat-5b02b45a"],function(ke,z,Z,o,N,y,le,f,we,Me,ue,Be,ce,j,k){"use strict";const ie=new o.Cartesian3,ge=new o.Cartesian3,_e=new o.Cartesian3,Ee=new o.Cartesian3,x=new Z.Cartesian2,Ie=new o.Matrix3,Ye=new o.Matrix3,be=new z.Quaternion,Te=new o.Cartesian3,Ge=new o.Cartesian3,Ne=new o.Cartesian3,pe=new o.Cartographic,Pe=new o.Cartesian3,ve=new Z.Cartesian2,Ve=new Z.Cartesian2;function Fe(e,t,n){const r=t.vertexFormat,a=t.center,s=t.semiMajorAxis,u=t.semiMinorAxis,i=t.ellipsoid,h=t.stRotation,C=n?e.length/3*2:e.length/3,d=t.shadowVolume,m=r.st?new Float32Array(2*C):void 0,w=r.normal?new Float32Array(3*C):void 0,b=r.tangent?new Float32Array(3*C):void 0,F=r.bitangent?new Float32Array(3*C):void 0,oe=d?new Float32Array(3*C):void 0;let ae=0,P=Te,D=Ge,R=Ne;const M=new z.GeographicProjection(i),A=M.project(i.cartesianToCartographic(a,pe),Pe),c=i.scaleToGeodeticSurface(a,ie);i.geodeticSurfaceNormal(c,c);let v=Ie,L=Ye;if(h!==0){let l=z.Quaternion.fromAxisAngle(c,h,be);v=o.Matrix3.fromQuaternion(l,v),l=z.Quaternion.fromAxisAngle(c,-h,be),L=o.Matrix3.fromQuaternion(l,L)}else v=o.Matrix3.clone(o.Matrix3.IDENTITY,v),L=o.Matrix3.clone(o.Matrix3.IDENTITY,L);const O=Z.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,ve),I=Z.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Ve);let H=e.length;const T=n?H:0,fe=T/3*2;for(let l=0;l<H;l+=3){const g=l+1,V=l+2,U=o.Cartesian3.fromArray(e,l,ie);if(r.st){const W=o.Matrix3.multiplyByVector(v,U,ge),K=M.project(i.cartesianToCartographic(W,pe),_e);o.Cartesian3.subtract(K,A,K),x.x=(K.x+s)/(2*s),x.y=(K.y+u)/(2*u),O.x=Math.min(x.x,O.x),O.y=Math.min(x.y,O.y),I.x=Math.max(x.x,I.x),I.y=Math.max(x.y,I.y),n&&(m[ae+fe]=x.x,m[ae+1+fe]=x.y),m[ae++]=x.x,m[ae++]=x.y}(r.normal||r.tangent||r.bitangent||d)&&(P=i.geodeticSurfaceNormal(U,P),d&&(oe[l+T]=-P.x,oe[g+T]=-P.y,oe[V+T]=-P.z),(r.normal||r.tangent||r.bitangent)&&((r.tangent||r.bitangent)&&(D=o.Cartesian3.normalize(o.Cartesian3.cross(o.Cartesian3.UNIT_Z,P,D),D),o.Matrix3.multiplyByVector(L,D,D)),r.normal&&(w[l]=P.x,w[g]=P.y,w[V]=P.z,n&&(w[l+T]=-P.x,w[g+T]=-P.y,w[V+T]=-P.z)),r.tangent&&(b[l]=D.x,b[g]=D.y,b[V]=D.z,n&&(b[l+T]=-D.x,b[g+T]=-D.y,b[V+T]=-D.z)),r.bitangent&&(R=o.Cartesian3.normalize(o.Cartesian3.cross(P,D,R),R),F[l]=R.x,F[g]=R.y,F[V]=R.z,n&&(F[l+T]=R.x,F[g+T]=R.y,F[V+T]=R.z))))}if(r.st){H=m.length;for(let l=0;l<H;l+=2)m[l]=(m[l]-O.x)/(I.x-O.x),m[l+1]=(m[l+1]-O.y)/(I.y-O.y)}const G=new we.GeometryAttributes;if(r.position){const l=le.EllipseGeometryLibrary.raisePositionsToHeight(e,t,n);G.position=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:l})}if(r.st&&(G.st=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:m})),r.normal&&(G.normal=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:w})),r.tangent&&(G.tangent=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:b})),r.bitangent&&(G.bitangent=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:F})),d&&(G.extrudeDirection=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:oe})),n&&y.defined(t.offsetAttribute)){let l=new Uint8Array(C);if(t.offsetAttribute===ue.GeometryOffsetAttribute.TOP)l=l.fill(1,0,C/2);else{const g=t.offsetAttribute===ue.GeometryOffsetAttribute.NONE?0:1;l=l.fill(g)}G.applyOffset=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:l})}return G}function De(e){const t=new Array(e*(e+1)*12-6);let n,r,a,s,u,i=0;for(n=0,a=1,s=0;s<3;s++)t[i++]=a++,t[i++]=n,t[i++]=a;for(s=2;s<e+1;++s){for(a=s*(s+1)-1,n=(s-1)*s-1,t[i++]=a++,t[i++]=n,t[i++]=a,r=2*s,u=0;u<r-1;++u)t[i++]=a,t[i++]=n++,t[i++]=n,t[i++]=a++,t[i++]=n,t[i++]=a;t[i++]=a++,t[i++]=n,t[i++]=a}for(r=2*e,++a,++n,s=0;s<r-1;++s)t[i++]=a,t[i++]=n++,t[i++]=n,t[i++]=a++,t[i++]=n,t[i++]=a;for(t[i++]=a,t[i++]=n++,t[i++]=n,t[i++]=a++,t[i++]=n++,t[i++]=n,++n,s=e-1;s>1;--s){for(t[i++]=n++,t[i++]=n,t[i++]=a,r=2*s,u=0;u<r-1;++u)t[i++]=a,t[i++]=n++,t[i++]=n,t[i++]=a++,t[i++]=n,t[i++]=a;t[i++]=n++,t[i++]=n++,t[i++]=a++}for(s=0;s<3;s++)t[i++]=n++,t[i++]=n,t[i++]=a;return t}let ne=new o.Cartesian3;const ye=new z.BoundingSphere,de=new z.BoundingSphere;function He(e){const t=e.center,n=e.ellipsoid,r=e.semiMajorAxis;let a=o.Cartesian3.multiplyByScalar(n.geodeticSurfaceNormal(t,ie),e.height,ie);ye.center=o.Cartesian3.add(t,a,ye.center),ye.radius=r,a=o.Cartesian3.multiplyByScalar(n.geodeticSurfaceNormal(t,a),e.extrudedHeight,a),de.center=o.Cartesian3.add(t,a,de.center),de.radius=r;const s=le.EllipseGeometryLibrary.computeEllipsePositions(e,!0,!0),u=s.positions,i=s.numPts,h=s.outerPositions,C=z.BoundingSphere.union(ye,de),d=Fe(u,e,!0);let m=De(i);const w=m.length;m.length=2*w;const b=u.length/3;for(let M=0;M<w;M+=3)m[M+w]=m[M+2]+b,m[M+1+w]=m[M+1]+b,m[M+2+w]=m[M]+b;const F=ce.IndexDatatype.createTypedArray(2*b/3,m),oe=new f.Geometry({attributes:d,indices:F,primitiveType:f.PrimitiveType.TRIANGLES}),ae=function(M,A){const c=A.vertexFormat,v=A.center,L=A.semiMajorAxis,O=A.semiMinorAxis,I=A.ellipsoid,H=A.height,T=A.extrudedHeight,fe=A.stRotation,G=M.length/3*2,l=new Float64Array(3*G),g=c.st?new Float32Array(2*G):void 0,V=c.normal?new Float32Array(3*G):void 0,U=c.tangent?new Float32Array(3*G):void 0,W=c.bitangent?new Float32Array(3*G):void 0,K=A.shadowVolume,Ae=K?new Float32Array(3*G):void 0;let xe=0,E=Te,J=Ge,q=Ne;const je=new z.GeographicProjection(I),Ue=je.project(I.cartesianToCartographic(v,pe),Pe),Ce=I.scaleToGeodeticSurface(v,ie);I.geodeticSurfaceNormal(Ce,Ce);const Qe=z.Quaternion.fromAxisAngle(Ce,fe,be),We=o.Matrix3.fromQuaternion(Qe,Ie),X=Z.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,ve),re=Z.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Ve);let _=M.length;const ze=_/3*2;for(let p=0;p<_;p+=3){const Q=p+1,ee=p+2;let te,S=o.Cartesian3.fromArray(M,p,ie);if(c.st){const me=o.Matrix3.multiplyByVector(We,S,ge),se=je.project(I.cartesianToCartographic(me,pe),_e);o.Cartesian3.subtract(se,Ue,se),x.x=(se.x+L)/(2*L),x.y=(se.y+O)/(2*O),X.x=Math.min(x.x,X.x),X.y=Math.min(x.y,X.y),re.x=Math.max(x.x,re.x),re.y=Math.max(x.y,re.y),g[xe+ze]=x.x,g[xe+1+ze]=x.y,g[xe++]=x.x,g[xe++]=x.y}S=I.scaleToGeodeticSurface(S,S),te=o.Cartesian3.clone(S,ge),E=I.geodeticSurfaceNormal(S,E),K&&(Ae[p+_]=-E.x,Ae[Q+_]=-E.y,Ae[ee+_]=-E.z);let he=o.Cartesian3.multiplyByScalar(E,H,Ee);if(S=o.Cartesian3.add(S,he,S),he=o.Cartesian3.multiplyByScalar(E,T,he),te=o.Cartesian3.add(te,he,te),c.position&&(l[p+_]=te.x,l[Q+_]=te.y,l[ee+_]=te.z,l[p]=S.x,l[Q]=S.y,l[ee]=S.z),c.normal||c.tangent||c.bitangent){q=o.Cartesian3.clone(E,q);const me=o.Cartesian3.fromArray(M,(p+3)%_,Ee);o.Cartesian3.subtract(me,S,me);const se=o.Cartesian3.subtract(te,S,_e);E=o.Cartesian3.normalize(o.Cartesian3.cross(se,me,E),E),c.normal&&(V[p]=E.x,V[Q]=E.y,V[ee]=E.z,V[p+_]=E.x,V[Q+_]=E.y,V[ee+_]=E.z),c.tangent&&(J=o.Cartesian3.normalize(o.Cartesian3.cross(q,E,J),J),U[p]=J.x,U[Q]=J.y,U[ee]=J.z,U[p+_]=J.x,U[p+1+_]=J.y,U[p+2+_]=J.z),c.bitangent&&(W[p]=q.x,W[Q]=q.y,W[ee]=q.z,W[p+_]=q.x,W[Q+_]=q.y,W[ee+_]=q.z)}}if(c.st){_=g.length;for(let p=0;p<_;p+=2)g[p]=(g[p]-X.x)/(re.x-X.x),g[p+1]=(g[p+1]-X.y)/(re.y-X.y)}const $=new we.GeometryAttributes;if(c.position&&($.position=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:l})),c.st&&($.st=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:g})),c.normal&&($.normal=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),c.tangent&&($.tangent=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:U})),c.bitangent&&($.bitangent=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:W})),K&&($.extrudeDirection=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Ae})),y.defined(A.offsetAttribute)){let p=new Uint8Array(G);if(A.offsetAttribute===ue.GeometryOffsetAttribute.TOP)p=p.fill(1,0,G/2);else{const Q=A.offsetAttribute===ue.GeometryOffsetAttribute.NONE?0:1;p=p.fill(Q)}$.applyOffset=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:p})}return $}(h,e);m=function(M){const A=M.length/3,c=ce.IndexDatatype.createTypedArray(A,6*A);let v=0;for(let L=0;L<A;L++){const O=L,I=L+A,H=(O+1)%A,T=H+A;c[v++]=O,c[v++]=I,c[v++]=H,c[v++]=H,c[v++]=I,c[v++]=T}return c}(h);const P=ce.IndexDatatype.createTypedArray(2*h.length/3,m),D=new f.Geometry({attributes:ae,indices:P,primitiveType:f.PrimitiveType.TRIANGLES}),R=Be.GeometryPipeline.combineInstances([new Me.GeometryInstance({geometry:oe}),new Me.GeometryInstance({geometry:D})]);return{boundingSphere:C,attributes:R[0].attributes,indices:R[0].indices}}function Oe(e,t,n,r,a,s,u){const i=le.EllipseGeometryLibrary.computeEllipsePositions({center:e,semiMajorAxis:t,semiMinorAxis:n,rotation:r,granularity:a},!1,!0).outerPositions,h=i.length/3,C=new Array(h);for(let m=0;m<h;++m)C[m]=o.Cartesian3.fromArray(i,3*m);const d=Z.Rectangle.fromCartesianArray(C,s,u);return d.width>j.CesiumMath.PI&&(d.north=d.north>0?j.CesiumMath.PI_OVER_TWO-j.CesiumMath.EPSILON7:d.north,d.south=d.south<0?j.CesiumMath.EPSILON7-j.CesiumMath.PI_OVER_TWO:d.south,d.east=j.CesiumMath.PI,d.west=-j.CesiumMath.PI),d}function B(e){const t=(e=y.defaultValue(e,y.defaultValue.EMPTY_OBJECT)).center,n=y.defaultValue(e.ellipsoid,o.Ellipsoid.WGS84),r=e.semiMajorAxis,a=e.semiMinorAxis,s=y.defaultValue(e.granularity,j.CesiumMath.RADIANS_PER_DEGREE),u=y.defaultValue(e.vertexFormat,k.VertexFormat.DEFAULT),i=y.defaultValue(e.height,0),h=y.defaultValue(e.extrudedHeight,i);this._center=o.Cartesian3.clone(t),this._semiMajorAxis=r,this._semiMinorAxis=a,this._ellipsoid=o.Ellipsoid.clone(n),this._rotation=y.defaultValue(e.rotation,0),this._stRotation=y.defaultValue(e.stRotation,0),this._height=Math.max(h,i),this._granularity=s,this._vertexFormat=k.VertexFormat.clone(u),this._extrudedHeight=Math.min(h,i),this._shadowVolume=y.defaultValue(e.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=e.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}B.packedLength=o.Cartesian3.packedLength+o.Ellipsoid.packedLength+k.VertexFormat.packedLength+9,B.pack=function(e,t,n){return n=y.defaultValue(n,0),o.Cartesian3.pack(e._center,t,n),n+=o.Cartesian3.packedLength,o.Ellipsoid.pack(e._ellipsoid,t,n),n+=o.Ellipsoid.packedLength,k.VertexFormat.pack(e._vertexFormat,t,n),n+=k.VertexFormat.packedLength,t[n++]=e._semiMajorAxis,t[n++]=e._semiMinorAxis,t[n++]=e._rotation,t[n++]=e._stRotation,t[n++]=e._height,t[n++]=e._granularity,t[n++]=e._extrudedHeight,t[n++]=e._shadowVolume?1:0,t[n]=y.defaultValue(e._offsetAttribute,-1),t};const Se=new o.Cartesian3,Le=new o.Ellipsoid,Re=new k.VertexFormat,Y={center:Se,ellipsoid:Le,vertexFormat:Re,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};B.unpack=function(e,t,n){t=y.defaultValue(t,0);const r=o.Cartesian3.unpack(e,t,Se);t+=o.Cartesian3.packedLength;const a=o.Ellipsoid.unpack(e,t,Le);t+=o.Ellipsoid.packedLength;const s=k.VertexFormat.unpack(e,t,Re);t+=k.VertexFormat.packedLength;const u=e[t++],i=e[t++],h=e[t++],C=e[t++],d=e[t++],m=e[t++],w=e[t++],b=e[t++]===1,F=e[t];return y.defined(n)?(n._center=o.Cartesian3.clone(r,n._center),n._ellipsoid=o.Ellipsoid.clone(a,n._ellipsoid),n._vertexFormat=k.VertexFormat.clone(s,n._vertexFormat),n._semiMajorAxis=u,n._semiMinorAxis=i,n._rotation=h,n._stRotation=C,n._height=d,n._granularity=m,n._extrudedHeight=w,n._shadowVolume=b,n._offsetAttribute=F===-1?void 0:F,n):(Y.height=d,Y.extrudedHeight=w,Y.granularity=m,Y.stRotation=C,Y.rotation=h,Y.semiMajorAxis=u,Y.semiMinorAxis=i,Y.shadowVolume=b,Y.offsetAttribute=F===-1?void 0:F,new B(Y))},B.computeRectangle=function(e,t){const n=(e=y.defaultValue(e,y.defaultValue.EMPTY_OBJECT)).center,r=y.defaultValue(e.ellipsoid,o.Ellipsoid.WGS84),a=e.semiMajorAxis,s=e.semiMinorAxis,u=y.defaultValue(e.granularity,j.CesiumMath.RADIANS_PER_DEGREE);return Oe(n,a,s,y.defaultValue(e.rotation,0),u,r,t)},B.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const t=e._height,n=e._extrudedHeight,r=!j.CesiumMath.equalsEpsilon(t,n,0,j.CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const a={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:t,granularity:e._granularity,vertexFormat:e._vertexFormat,stRotation:e._stRotation};let s;if(r)a.extrudedHeight=n,a.shadowVolume=e._shadowVolume,a.offsetAttribute=e._offsetAttribute,s=He(a);else if(s=function(u){const i=u.center;ne=o.Cartesian3.multiplyByScalar(u.ellipsoid.geodeticSurfaceNormal(i,ne),u.height,ne),ne=o.Cartesian3.add(i,ne,ne);const h=new z.BoundingSphere(ne,u.semiMajorAxis),C=le.EllipseGeometryLibrary.computeEllipsePositions(u,!0,!1),d=C.positions,m=C.numPts,w=Fe(d,u,!1);let b=De(m);return b=ce.IndexDatatype.createTypedArray(d.length/3,b),{boundingSphere:h,attributes:w,indices:b}}(a),y.defined(e._offsetAttribute)){const u=s.attributes.position.values.length,i=e._offsetAttribute===ue.GeometryOffsetAttribute.NONE?0:1,h=new Uint8Array(u/3).fill(i);s.attributes.applyOffset=new f.GeometryAttribute({componentDatatype:N.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:h})}return new f.Geometry({attributes:s.attributes,indices:s.indices,primitiveType:f.PrimitiveType.TRIANGLES,boundingSphere:s.boundingSphere,offsetAttribute:e._offsetAttribute})},B.createShadowVolume=function(e,t,n){const r=e._granularity,a=e._ellipsoid,s=t(r,a),u=n(r,a);return new B({center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:a,rotation:e._rotation,stRotation:e._stRotation,granularity:r,extrudedHeight:s,height:u,vertexFormat:k.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(B.prototype,{rectangle:{get:function(){return y.defined(this._rectangle)||(this._rectangle=Oe(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return y.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){const t=-e._stRotation;if(t===0)return[0,0,0,1,1,0];const n=le.EllipseGeometryLibrary.computeEllipsePositions({center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,rotation:e._rotation,granularity:e._granularity},!1,!0).outerPositions,r=n.length/3,a=new Array(r);for(let i=0;i<r;++i)a[i]=o.Cartesian3.fromArray(n,3*i);const s=e._ellipsoid,u=e.rectangle;return f.Geometry._textureCoordinateRotationPoints(a,t,s,u)}(this)),this._textureCoordinateRotationPoints}}}),ke.EllipseGeometry=B});
