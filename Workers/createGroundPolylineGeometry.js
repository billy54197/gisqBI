/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./Transforms-5b74e989","./Matrix2-462b83d3","./Matrix3-2955527a","./defaultValue-ebbd2e4d","./Math-1fe079f3","./ArcType-efd92361","./arrayRemoveDuplicates-cadb0e8e","./ComponentDatatype-f9ac3ed8","./EllipsoidGeodesic-7acc6014","./EllipsoidRhumbLine-8bc8a516","./EncodedCartesian3-d4159969","./GeometryAttribute-9c756444","./IntersectionTests-2a07bba4","./Plane-7e97483e","./WebMercatorProjection-3d5b0545","./combine-55e9f355","./RuntimeError-38a08050","./WebGLConstants-544672c2"],function(M,N,e,h,c,oe,Mn,Ke,Tn,Ot,Ve,Be,bt,et,En,mi,wi,yi){"use strict";function ne(t){t=h.defaultValue(t,h.defaultValue.EMPTY_OBJECT),this._ellipsoid=h.defaultValue(t.ellipsoid,e.Ellipsoid.WGS84),this._rectangle=h.defaultValue(t.rectangle,N.Rectangle.MAX_VALUE),this._projection=new M.GeographicProjection(this._ellipsoid),this._numberOfLevelZeroTilesX=h.defaultValue(t.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=h.defaultValue(t.numberOfLevelZeroTilesY,1)}Object.defineProperties(ne.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),ne.prototype.getNumberOfXTilesAtLevel=function(t){return this._numberOfLevelZeroTilesX<<t},ne.prototype.getNumberOfYTilesAtLevel=function(t){return this._numberOfLevelZeroTilesY<<t},ne.prototype.rectangleToNativeRectangle=function(t,a){const r=c.CesiumMath.toDegrees(t.west),n=c.CesiumMath.toDegrees(t.south),i=c.CesiumMath.toDegrees(t.east),l=c.CesiumMath.toDegrees(t.north);return h.defined(a)?(a.west=r,a.south=n,a.east=i,a.north=l,a):new N.Rectangle(r,n,i,l)},ne.prototype.tileXYToNativeRectangle=function(t,a,r,n){const i=this.tileXYToRectangle(t,a,r,n);return i.west=c.CesiumMath.toDegrees(i.west),i.south=c.CesiumMath.toDegrees(i.south),i.east=c.CesiumMath.toDegrees(i.east),i.north=c.CesiumMath.toDegrees(i.north),i},ne.prototype.tileXYToRectangle=function(t,a,r,n){const i=this._rectangle,l=this.getNumberOfXTilesAtLevel(r),o=this.getNumberOfYTilesAtLevel(r),C=i.width/l,u=t*C+i.west,s=(t+1)*C+i.west,f=i.height/o,_=i.north-a*f,m=i.north-(a+1)*f;return h.defined(n)||(n=new N.Rectangle(u,m,s,_)),n.west=u,n.south=m,n.east=s,n.north=_,n},ne.prototype.positionToTileXY=function(t,a,r){const n=this._rectangle;if(!N.Rectangle.contains(n,t))return;const i=this.getNumberOfXTilesAtLevel(a),l=this.getNumberOfYTilesAtLevel(a),o=n.width/i,C=n.height/l;let u=t.longitude;n.east<n.west&&(u+=c.CesiumMath.TWO_PI);let s=(u-n.west)/o|0;s>=i&&(s=i-1);let f=(n.north-t.latitude)/C|0;return f>=l&&(f=l-1),h.defined(r)?(r.x=s,r.y=f,r):new N.Cartesian2(s,f)};const Pt=new e.Cartesian3,At=new e.Cartesian3,kt=new e.Cartographic,tt=new e.Cartesian3,_n=new e.Cartesian3,Lt=new M.BoundingSphere,On=new ne,Le=[new e.Cartographic,new e.Cartographic,new e.Cartographic,new e.Cartographic],Se=new N.Cartesian2,g={};function St(t){e.Cartographic.fromRadians(t.east,t.north,0,Le[0]),e.Cartographic.fromRadians(t.west,t.north,0,Le[1]),e.Cartographic.fromRadians(t.east,t.south,0,Le[2]),e.Cartographic.fromRadians(t.west,t.south,0,Le[3]);let a=0,r=0,n=0,i=0;const l=g._terrainHeightsMaxLevel;let o;for(o=0;o<=l;++o){let C=!1;for(let u=0;u<4;++u){const s=Le[u];if(On.positionToTileXY(s,o,Se),u===0)n=Se.x,i=Se.y;else if(n!==Se.x||i!==Se.y){C=!0;break}}if(C)break;a=n,r=i}if(o!==0)return{x:a,y:r,level:o>l?l:o-1}}g.initialize=function(){let t=g._initPromise;return h.defined(t)||(t=M.Resource.fetchJson(M.buildModuleUrl("Assets/approximateTerrainHeights.json")).then(function(a){g._terrainHeights=a}),g._initPromise=t),t},g.getMinimumMaximumHeights=function(t,a){a=h.defaultValue(a,e.Ellipsoid.WGS84);const r=St(t);let n=g._defaultMinTerrainHeight,i=g._defaultMaxTerrainHeight;if(h.defined(r)){const l=`${r.level}-${r.x}-${r.y}`,o=g._terrainHeights[l];h.defined(o)&&(n=o[0],i=o[1]),a.cartographicToCartesian(N.Rectangle.northeast(t,kt),Pt),a.cartographicToCartesian(N.Rectangle.southwest(t,kt),At),e.Cartesian3.midpoint(At,Pt,tt);const C=a.scaleToGeodeticSurface(tt,_n);if(h.defined(C)){const u=e.Cartesian3.distance(tt,C);n=Math.min(n,-u)}else n=g._defaultMinTerrainHeight}return n=Math.max(g._defaultMinTerrainHeight,n),{minimumTerrainHeight:n,maximumTerrainHeight:i}},g.getBoundingSphere=function(t,a){a=h.defaultValue(a,e.Ellipsoid.WGS84);const r=St(t);let n=g._defaultMaxTerrainHeight;if(h.defined(r)){const l=`${r.level}-${r.x}-${r.y}`,o=g._terrainHeights[l];h.defined(o)&&(n=o[1])}const i=M.BoundingSphere.fromRectangle3D(t,a,0);return M.BoundingSphere.fromRectangle3D(t,a,n,Lt),M.BoundingSphere.union(i,Lt,i)},g._terrainHeightsMaxLevel=6,g._defaultMaxTerrainHeight=9e3,g._defaultMinTerrainHeight=-1e5,g._terrainHeights=void 0,g._initPromise=void 0,Object.defineProperties(g,{initialized:{get:function(){return h.defined(g._terrainHeights)}}});var xt=g;const nt=[M.GeographicProjection,En.WebMercatorProjection],bn=nt.length,It=Math.cos(c.CesiumMath.toRadians(30)),Rt=Math.cos(c.CesiumMath.toRadians(150));function H(t){const a=(t=h.defaultValue(t,h.defaultValue.EMPTY_OBJECT)).positions;this.width=h.defaultValue(t.width,1),this._positions=a,this.granularity=h.defaultValue(t.granularity,9999),this.loop=h.defaultValue(t.loop,!1),this.arcType=h.defaultValue(t.arcType,oe.ArcType.GEODESIC),this._ellipsoid=e.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(H.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+e.Ellipsoid.packedLength+1+1}}}),H.setProjectionAndEllipsoid=function(t,a){let r=0;for(let n=0;n<bn;n++)if(a instanceof nt[n]){r=n;break}t._projectionIndex=r,t._ellipsoid=a.ellipsoid};const Pn=new e.Cartesian3,Nt=new e.Cartesian3,Dt=new e.Cartesian3;function it(t,a,r,n,i){const l=T(n,t,0,Pn),o=T(n,t,r,Nt),C=T(n,a,0,Dt),u=V(o,l,Nt),s=V(C,l,Dt);return e.Cartesian3.cross(s,u,i),e.Cartesian3.normalize(i,i)}const An=new e.Cartographic,kn=new e.Cartesian3,Ln=new e.Cartesian3,Sn=new e.Cartesian3;function at(t,a,r,n,i,l,o,C,u,s,f){if(i===0)return;let _;l===oe.ArcType.GEODESIC?_=new Tn.EllipsoidGeodesic(t,a,o):l===oe.ArcType.RHUMB&&(_=new Ot.EllipsoidRhumbLine(t,a,o));const m=_.surfaceDistance;if(m<i)return;const O=it(t,a,n,o,Sn),le=Math.ceil(m/i),ce=m/le;let ue=ce;const p=le-1;let B=C.length;for(let Ce=0;Ce<p;Ce++){const P=_.interpolateUsingSurfaceDistance(ue,An),D=T(o,P,r,kn),y=T(o,P,n,Ln);e.Cartesian3.pack(O,C,B),e.Cartesian3.pack(D,u,B),e.Cartesian3.pack(y,s,B),f.push(P.latitude),f.push(P.longitude),B+=3,ue+=ce}}const rt=new e.Cartographic;function T(t,a,r,n){return e.Cartographic.clone(a,rt),rt.height=r,e.Cartographic.toCartesian(rt,t,n)}function V(t,a,r){return e.Cartesian3.subtract(t,a,r),e.Cartesian3.normalize(r,r),r}function vt(t,a,r,n){return n=V(t,a,n),n=e.Cartesian3.cross(n,r,n),n=e.Cartesian3.normalize(n,n),n=e.Cartesian3.cross(r,n,n)}H.pack=function(t,a,r){let n=h.defaultValue(r,0);const i=t._positions,l=i.length;a[n++]=l;for(let o=0;o<l;++o){const C=i[o];e.Cartesian3.pack(C,a,n),n+=3}return a[n++]=t.granularity,a[n++]=t.loop?1:0,a[n++]=t.arcType,e.Ellipsoid.pack(t._ellipsoid,a,n),n+=e.Ellipsoid.packedLength,a[n++]=t._projectionIndex,a[n++]=t._scene3DOnly?1:0,a},H.unpack=function(t,a,r){let n=h.defaultValue(a,0);const i=t[n++],l=new Array(i);for(let m=0;m<i;m++)l[m]=e.Cartesian3.unpack(t,n),n+=3;const o=t[n++],C=t[n++]===1,u=t[n++],s=e.Ellipsoid.unpack(t,n);n+=e.Ellipsoid.packedLength;const f=t[n++],_=t[n++]===1;return h.defined(r)||(r=new H({positions:l})),r._positions=l,r.granularity=o,r.loop=C,r.arcType=u,r._ellipsoid=s,r._projectionIndex=f,r._scene3DOnly=_,r};const xn=new e.Cartesian3,In=new e.Cartesian3,Rn=new e.Cartesian3,zt=new e.Cartesian3;function st(t,a,r,n,i){const l=V(r,a,zt),o=vt(t,a,l,xn),C=vt(n,a,l,In);if(c.CesiumMath.equalsEpsilon(e.Cartesian3.dot(o,C),-1,c.CesiumMath.EPSILON5))return i=e.Cartesian3.cross(l,o,i),i=e.Cartesian3.normalize(i,i);i=e.Cartesian3.add(C,o,i),i=e.Cartesian3.normalize(i,i);const u=e.Cartesian3.cross(l,i,Rn);return e.Cartesian3.dot(C,u)<0&&(i=e.Cartesian3.negate(i,i)),i}const je=et.Plane.fromPointNormal(e.Cartesian3.ZERO,e.Cartesian3.UNIT_Y),Nn=new e.Cartesian3,Dn=new e.Cartesian3,vn=new e.Cartesian3,zn=new e.Cartesian3,Hn=new e.Cartesian3,Ge=new e.Cartesian3,Ye=new e.Cartographic,Ht=new e.Cartographic,Vt=new e.Cartographic;H.createGeometry=function(t){const a=!t._scene3DOnly;let r=t.loop;const n=t._ellipsoid,i=t.granularity,l=t.arcType,o=new nt[t._projectionIndex](n),C=1e3;let u,s;const f=t._positions,_=f.length;let m,O,le,ce;_===2&&(r=!1);const ue=new Ot.EllipsoidRhumbLine(void 0,void 0,n);let p,B,Ce;const P=[f[0]];for(s=0;s<_-1;s++)m=f[s],O=f[s+1],p=bt.IntersectionTests.lineSegmentPlane(m,O,je,Ge),!h.defined(p)||e.Cartesian3.equalsEpsilon(p,m,c.CesiumMath.EPSILON7)||e.Cartesian3.equalsEpsilon(p,O,c.CesiumMath.EPSILON7)||(t.arcType===oe.ArcType.GEODESIC?P.push(e.Cartesian3.clone(p)):t.arcType===oe.ArcType.RHUMB&&(Ce=n.cartesianToCartographic(p,Ye).longitude,le=n.cartesianToCartographic(m,Ye),ce=n.cartesianToCartographic(O,Ht),ue.setEndPoints(le,ce),B=ue.findIntersectionWithLongitude(Ce,Vt),p=n.cartographicToCartesian(B,Ge),!h.defined(p)||e.Cartesian3.equalsEpsilon(p,m,c.CesiumMath.EPSILON7)||e.Cartesian3.equalsEpsilon(p,O,c.CesiumMath.EPSILON7)||P.push(e.Cartesian3.clone(p)))),P.push(O);r&&(m=f[_-1],O=f[0],p=bt.IntersectionTests.lineSegmentPlane(m,O,je,Ge),!h.defined(p)||e.Cartesian3.equalsEpsilon(p,m,c.CesiumMath.EPSILON7)||e.Cartesian3.equalsEpsilon(p,O,c.CesiumMath.EPSILON7)||(t.arcType===oe.ArcType.GEODESIC?P.push(e.Cartesian3.clone(p)):t.arcType===oe.ArcType.RHUMB&&(Ce=n.cartesianToCartographic(p,Ye).longitude,le=n.cartesianToCartographic(m,Ye),ce=n.cartesianToCartographic(O,Ht),ue.setEndPoints(le,ce),B=ue.findIntersectionWithLongitude(Ce,Vt),p=n.cartographicToCartesian(B,Ge),!h.defined(p)||e.Cartesian3.equalsEpsilon(p,m,c.CesiumMath.EPSILON7)||e.Cartesian3.equalsEpsilon(p,O,c.CesiumMath.EPSILON7)||P.push(e.Cartesian3.clone(p)))));let D=P.length,y=new Array(D);for(s=0;s<D;s++){const v=e.Cartographic.fromCartesian(P[s],n);v.height=0,y[s]=v}if(y=Mn.arrayRemoveDuplicates(y,e.Cartographic.equalsEpsilon),D=y.length,D<2)return;const A=[],k=[],j=[],G=[];let Y=Nn,b=Dn,I=vn,q=zn,R=Hn;const F=y[0],ut=y[1];for(Y=T(n,y[D-1],0,Y),q=T(n,ut,0,q),b=T(n,F,0,b),I=T(n,F,C,I),R=r?st(Y,b,I,q,R):it(F,ut,C,n,R),e.Cartesian3.pack(R,k,0),e.Cartesian3.pack(b,j,0),e.Cartesian3.pack(I,G,0),A.push(F.latitude),A.push(F.longitude),at(F,ut,0,C,i,l,n,k,j,G,A),s=1;s<D-1;++s){Y=e.Cartesian3.clone(b,Y),b=e.Cartesian3.clone(q,b);const v=y[s];T(n,v,C,I),T(n,y[s+1],0,q),st(Y,b,I,q,R),u=k.length,e.Cartesian3.pack(R,k,u),e.Cartesian3.pack(b,j,u),e.Cartesian3.pack(I,G,u),A.push(v.latitude),A.push(v.longitude),at(y[s],y[s+1],0,C,i,l,n,k,j,G,A)}const me=y[D-1],nn=y[D-2];if(b=T(n,me,0,b),I=T(n,me,C,I),r){const v=y[0];Y=T(n,nn,0,Y),q=T(n,v,0,q),R=st(Y,b,I,q,R)}else R=it(nn,me,C,n,R);if(u=k.length,e.Cartesian3.pack(R,k,u),e.Cartesian3.pack(b,j,u),e.Cartesian3.pack(I,G,u),A.push(me.latitude),A.push(me.longitude),r){for(at(me,F,0,C,i,l,n,k,j,G,A),u=k.length,s=0;s<3;++s)k[u+s]=k[s],j[u+s]=j[s],G[u+s]=G[s];A.push(F.latitude),A.push(F.longitude)}return function(v,X,we,ye,an,U,Me){let L,w;const ui=X._ellipsoid,Ie=we.length/3-1,Fe=8*Ie,ae=4*Fe,rn=36*Ie,sn=Fe>65535?new Uint32Array(rn):new Uint16Array(rn),W=new Float64Array(3*Fe),Ct=new Float32Array(ae),ht=new Float32Array(ae),pt=new Float32Array(ae),dt=new Float32Array(ae),gt=new Float32Array(ae);let Te,Ee,_e,Xe;Me&&(Te=new Float32Array(ae),Ee=new Float32Array(ae),_e=new Float32Array(ae),Xe=new Float32Array(2*Fe));const Ci=U.length/2;let ft=0;const S=Ft;S.height=0;const x=Xt;x.height=0;let Oe=Ut,Z=ot;if(Me)for(w=0,L=1;L<Ci;L++)S.latitude=U[w],S.longitude=U[w+1],x.latitude=U[w+2],x.longitude=U[w+3],Oe=X.project(S,Oe),Z=X.project(x,Z),ft+=e.Cartesian3.distance(Oe,Z),w+=2;const hi=ye.length/3;Z=e.Cartesian3.unpack(ye,0,Z);let E,mt=0;for(w=3,L=1;L<hi;L++)Oe=e.Cartesian3.clone(Z,Oe),Z=e.Cartesian3.unpack(ye,w,Z),mt+=e.Cartesian3.distance(Oe,Z),w+=3;w=3;let Re=0,on=0,$=0,ln=0,cn=!1,he=e.Cartesian3.unpack(we,0,Zt),pe=e.Cartesian3.unpack(ye,0,ot),z=e.Cartesian3.unpack(an,0,$t);v&&Bt(z,e.Cartesian3.unpack(we,we.length-6,Wt),he,pe)&&(z=e.Cartesian3.negate(z,z));let un=0,Cn=0,wt=0;for(L=0;L<Ie;L++){const De=e.Cartesian3.clone(he,Wt),Mt=e.Cartesian3.clone(pe,Ut);let de,be,re,se,Pe=e.Cartesian3.clone(z,Xn);if(cn&&(Pe=e.Cartesian3.negate(Pe,Pe)),he=e.Cartesian3.unpack(we,w,Zt),pe=e.Cartesian3.unpack(ye,w,ot),z=e.Cartesian3.unpack(an,w,$t),cn=Bt(z,De,he,pe),S.latitude=U[Re],S.longitude=U[Re+1],x.latitude=U[Re+2],x.longitude=U[Re+3],Me){const d=Fn(S,x);de=X.project(S,Kn),be=X.project(x,ei);const ke=V(be,de,Qt);ke.y=Math.abs(ke.y),re=lt,se=ct,d===0||e.Cartesian3.dot(ke,e.Cartesian3.UNIT_Y)>It?(re=xe(X,S,Pe,de,lt),se=xe(X,x,z,be,ct)):d===1?(se=xe(X,x,z,be,ct),re.x=0,re.y=c.CesiumMath.sign(S.longitude-Math.abs(x.longitude)),re.z=0):(re=xe(X,S,Pe,de,lt),se.x=0,se.y=c.CesiumMath.sign(S.longitude-x.longitude),se.z=0)}const dn=e.Cartesian3.distance(Mt,pe),gn=Ve.EncodedCartesian3.fromCartesian(De,si),Ue=e.Cartesian3.subtract(he,De,ti),pi=e.Cartesian3.normalize(Ue,Jt);let ve=e.Cartesian3.subtract(Mt,De,ni);ve=e.Cartesian3.normalize(ve,ve);let Ae=e.Cartesian3.cross(pi,ve,Jt);Ae=e.Cartesian3.normalize(Ae,Ae);let We=e.Cartesian3.cross(ve,Pe,ai);We=e.Cartesian3.normalize(We,We);let Ze=e.Cartesian3.subtract(pe,he,ii);Ze=e.Cartesian3.normalize(Ze,Ze);let $e=e.Cartesian3.cross(z,Ze,ri);$e=e.Cartesian3.normalize($e,$e);const di=dn/mt,gi=un/mt;let ze,Je,ge,Tt=0,fn=0,mn=0;if(Me){Tt=e.Cartesian3.distance(de,be),ze=Ve.EncodedCartesian3.fromCartesian(de,oi),Je=e.Cartesian3.subtract(be,de,Qt),ge=e.Cartesian3.normalize(Je,li);const d=ge.x;ge.x=ge.y,ge.y=-d,fn=Tt/ft,mn=Cn/ft}for(E=0;E<8;E++){const d=ln+4*E,ke=on+2*E,He=d+3,yn=E<4?1:-1,Qe=E===2||E===3||E===6||E===7?1:-1;e.Cartesian3.pack(gn.high,Ct,d),Ct[He]=Ue.x,e.Cartesian3.pack(gn.low,ht,d),ht[He]=Ue.y,e.Cartesian3.pack(We,pt,d),pt[He]=Ue.z,e.Cartesian3.pack($e,dt,d),dt[He]=di*yn,e.Cartesian3.pack(Ae,gt,d);let fe=gi*Qe;fe===0&&Qe<0&&(fe=9),gt[He]=fe,Me&&(Te[d]=ze.high.x,Te[d+1]=ze.high.y,Te[d+2]=ze.low.x,Te[d+3]=ze.low.y,_e[d]=-re.y,_e[d+1]=re.x,_e[d+2]=se.y,_e[d+3]=-se.x,Ee[d]=Je.x,Ee[d+1]=Je.y,Ee[d+2]=ge.x,Ee[d+3]=ge.y,Xe[ke]=fn*yn,fe=mn*Qe,fe===0&&Qe<0&&(fe=9),Xe[ke+1]=fe)}const J=Jn,Q=Qn,K=Zn,ee=$n,fi=N.Rectangle.fromCartographicArray(Un,Wn),wn=xt.getMinimumMaximumHeights(fi,ui),Et=wn.minimumTerrainHeight,_t=wn.maximumTerrainHeight;wt+=Et,wt+=_t,qt(De,Mt,Et,_t,J,K),qt(he,pe,Et,_t,Q,ee);let te=e.Cartesian3.multiplyByScalar(Ae,c.CesiumMath.EPSILON5,Kt);e.Cartesian3.add(J,te,J),e.Cartesian3.add(Q,te,Q),e.Cartesian3.add(K,te,K),e.Cartesian3.add(ee,te,ee),qe(J,Q),qe(K,ee),e.Cartesian3.pack(J,W,$),e.Cartesian3.pack(Q,W,$+3),e.Cartesian3.pack(ee,W,$+6),e.Cartesian3.pack(K,W,$+9),te=e.Cartesian3.multiplyByScalar(Ae,-2*c.CesiumMath.EPSILON5,Kt),e.Cartesian3.add(J,te,J),e.Cartesian3.add(Q,te,Q),e.Cartesian3.add(K,te,K),e.Cartesian3.add(ee,te,ee),qe(J,Q),qe(K,ee),e.Cartesian3.pack(J,W,$+12),e.Cartesian3.pack(Q,W,$+15),e.Cartesian3.pack(ee,W,$+18),e.Cartesian3.pack(K,W,$+21),Re+=2,w+=3,on+=16,$+=24,ln+=32,un+=dn,Cn+=Tt}w=0;let hn=0;for(L=0;L<Ie;L++){for(E=0;E<tn;E++)sn[w+E]=en[E]+hn;hn+=8,w+=tn}const yt=ci;M.BoundingSphere.fromVertices(we,e.Cartesian3.ZERO,3,yt[0]),M.BoundingSphere.fromVertices(ye,e.Cartesian3.ZERO,3,yt[1]);const pn=M.BoundingSphere.fromBoundingSpheres(yt);pn.radius+=wt/(2*Ie);const Ne={position:new Be.GeometryAttribute({componentDatatype:Ke.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:W}),startHiAndForwardOffsetX:ie(Ct),startLoAndForwardOffsetY:ie(ht),startNormalAndForwardOffsetZ:ie(pt),endNormalAndTextureCoordinateNormalizationX:ie(dt),rightNormalAndTextureCoordinateNormalizationY:ie(gt)};return Me&&(Ne.startHiLo2D=ie(Te),Ne.offsetAndRight2D=ie(Ee),Ne.startEndNormals2D=ie(_e),Ne.texcoordNormalization2D=new Be.GeometryAttribute({componentDatatype:Ke.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:Xe})),new Be.Geometry({attributes:Ne,indices:sn,boundingSphere:pn})}(r,o,j,G,k,A,a)};const Vn=new e.Cartesian3,Bn=new e.Matrix3,jn=new M.Quaternion;function Bt(t,a,r,n){const i=V(r,a,Vn),l=e.Cartesian3.dot(i,t);if(l>It||l<Rt){const o=V(n,r,zt),C=l<Rt?c.CesiumMath.PI_OVER_TWO:-c.CesiumMath.PI_OVER_TWO,u=M.Quaternion.fromAxisAngle(o,C,jn),s=e.Matrix3.fromQuaternion(u,Bn);return e.Matrix3.multiplyByVector(s,t,t),!0}return!1}const jt=new e.Cartographic,Gn=new e.Cartesian3,Gt=new e.Cartesian3;function xe(t,a,r,n,i){const l=e.Cartographic.toCartesian(a,t._ellipsoid,Gn);let o=e.Cartesian3.add(l,r,Gt),C=!1;const u=t._ellipsoid;let s=u.cartesianToCartographic(o,jt);Math.abs(a.longitude-s.longitude)>c.CesiumMath.PI_OVER_TWO&&(C=!0,o=e.Cartesian3.subtract(l,r,Gt),s=u.cartesianToCartographic(o,jt)),s.height=0;const f=t.project(s,i);return(i=e.Cartesian3.subtract(f,n,i)).z=0,i=e.Cartesian3.normalize(i,i),C&&e.Cartesian3.negate(i,i),i}const Yn=new e.Cartesian3,Yt=new e.Cartesian3;function qt(t,a,r,n,i,l){const o=e.Cartesian3.subtract(a,t,Yn);e.Cartesian3.normalize(o,o);const C=r-0;let u=e.Cartesian3.multiplyByScalar(o,C,Yt);e.Cartesian3.add(t,u,i);const s=n-1e3;u=e.Cartesian3.multiplyByScalar(o,s,Yt),e.Cartesian3.add(a,u,l)}const qn=new e.Cartesian3;function qe(t,a){const r=et.Plane.getPointDistance(je,t),n=et.Plane.getPointDistance(je,a);let i=qn;c.CesiumMath.equalsEpsilon(r,0,c.CesiumMath.EPSILON2)?(i=V(a,t,i),e.Cartesian3.multiplyByScalar(i,c.CesiumMath.EPSILON2,i),e.Cartesian3.add(t,i,t)):c.CesiumMath.equalsEpsilon(n,0,c.CesiumMath.EPSILON2)&&(i=V(t,a,i),e.Cartesian3.multiplyByScalar(i,c.CesiumMath.EPSILON2,i),e.Cartesian3.add(a,i,a))}function Fn(t,a){const r=Math.abs(t.longitude),n=Math.abs(a.longitude);if(c.CesiumMath.equalsEpsilon(r,c.CesiumMath.PI,c.CesiumMath.EPSILON11)){const i=c.CesiumMath.sign(a.longitude);return t.longitude=i*(r-c.CesiumMath.EPSILON11),1}if(c.CesiumMath.equalsEpsilon(n,c.CesiumMath.PI,c.CesiumMath.EPSILON11)){const i=c.CesiumMath.sign(t.longitude);return a.longitude=i*(n-c.CesiumMath.EPSILON11),2}return 0}const Ft=new e.Cartographic,Xt=new e.Cartographic,Ut=new e.Cartesian3,ot=new e.Cartesian3,Wt=new e.Cartesian3,Zt=new e.Cartesian3,Xn=new e.Cartesian3,$t=new e.Cartesian3,Un=[Ft,Xt],Wn=new N.Rectangle,Zn=new e.Cartesian3,$n=new e.Cartesian3,Jn=new e.Cartesian3,Qn=new e.Cartesian3,Kn=new e.Cartesian3,ei=new e.Cartesian3,lt=new e.Cartesian3,ct=new e.Cartesian3,ti=new e.Cartesian3,ni=new e.Cartesian3,ii=new e.Cartesian3,Jt=new e.Cartesian3,ai=new e.Cartesian3,ri=new e.Cartesian3,si=new Ve.EncodedCartesian3,oi=new Ve.EncodedCartesian3,Qt=new e.Cartesian3,li=new e.Cartesian3,Kt=new e.Cartesian3,ci=[new M.BoundingSphere,new M.BoundingSphere],en=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],tn=en.length;function ie(t){return new Be.GeometryAttribute({componentDatatype:Ke.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:t})}return H._projectNormal=xe,function(t,a){return xt.initialize().then(function(){return h.defined(a)&&(t=H.unpack(t,a)),H.createGeometry(t)})}});
