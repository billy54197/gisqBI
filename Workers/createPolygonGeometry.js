/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./defaultValue-ebbd2e4d","./Matrix3-2955527a","./ArcType-efd92361","./BoundingRectangle-3be07fe8","./Transforms-5b74e989","./Matrix2-462b83d3","./ComponentDatatype-f9ac3ed8","./EllipsoidGeodesic-7acc6014","./EllipsoidTangentPlane-da4fdd19","./GeometryAttribute-9c756444","./GeometryInstance-4ef1b8a5","./GeometryOffsetAttribute-739bec2c","./GeometryPipeline-3cfa9822","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolygonGeometryLibrary-e1e72ec4","./PolygonPipeline-4fdc8b4f","./VertexFormat-5b02b45a","./combine-55e9f355","./RuntimeError-38a08050","./WebGLConstants-544672c2","./AxisAlignedBoundingBox-a26a3fb6","./IntersectionTests-2a07bba4","./Plane-7e97483e","./AttributeCompression-6f93ad0c","./EncodedCartesian3-d4159969","./arrayRemoveDuplicates-cadb0e8e","./EllipsoidRhumbLine-8bc8a516","./GeometryAttributes-ca309b71"],function(p,n,ee,pe,J,z,j,re,te,B,X,oe,de,ne,N,L,Q,M,De,Ne,Fe,Re,Me,Se,Be,ke,ze,We,Ye){"use strict";const ye=new n.Cartographic,ie=new n.Cartographic;function me(e,t,o,s){const a=s.cartesianToCartographic(e,ye).height,f=s.cartesianToCartographic(t,ie);f.height=a,s.cartographicToCartesian(f,t);const l=s.cartesianToCartographic(o,ie);l.height=a-100,s.cartographicToCartesian(l,o)}const ge=new pe.BoundingRectangle,he=new n.Cartesian3,fe=new n.Cartesian3,be=new n.Cartesian3,_e=new n.Cartesian3,Pe=new n.Cartesian3,Ce=new n.Cartesian3;let $=new n.Cartesian3,S=new n.Cartesian3,K=new n.Cartesian3;const xe=new z.Cartesian2,we=new z.Cartesian2,Te=new n.Cartesian3,se=new J.Quaternion,Ie=new n.Matrix3,Ae=new n.Matrix3;function ae(e){const t=e.vertexFormat,o=e.geometry,s=e.shadowVolume,a=o.attributes.position.values,f=p.defined(o.attributes.st)?o.attributes.st.values:void 0;let l=a.length;const h=e.wall,d=e.top||h,m=e.bottom||h;if(t.st||t.normal||t.tangent||t.bitangent||s){const g=e.boundingRectangle,r=e.tangentPlane,_=e.ellipsoid,v=e.stRotation,V=e.perPositionHeight,H=xe;H.x=g.x,H.y=g.y;const E=t.st?new Float32Array(l/3*2):void 0;let P;t.normal&&(P=V&&d&&!h?o.attributes.normal.values:new Float32Array(l));const c=t.tangent?new Float32Array(l):void 0,T=t.bitangent?new Float32Array(l):void 0,I=s?new Float32Array(l):void 0;let A=0,i=0,u=fe,y=be,w=_e,R=!0,x=Ie,C=Ae;if(v!==0){let D=J.Quaternion.fromAxisAngle(r._plane.normal,v,se);x=n.Matrix3.fromQuaternion(D,x),D=J.Quaternion.fromAxisAngle(r._plane.normal,-v,se),C=n.Matrix3.fromQuaternion(D,C)}else x=n.Matrix3.clone(n.Matrix3.IDENTITY,x),C=n.Matrix3.clone(n.Matrix3.IDENTITY,C);let b=0,k=0;d&&m&&(b=l/2,k=l/3,l/=2);for(let D=0;D<l;D+=3){const Y=n.Cartesian3.fromArray(a,D,Te);if(t.st&&!p.defined(f)){let G=n.Matrix3.multiplyByVector(x,Y,he);G=_.scaleToGeodeticSurface(G,G);const O=r.projectPointOntoPlane(G,we);z.Cartesian2.subtract(O,H,O);const U=N.CesiumMath.clamp(O.x/g.width,0,1),q=N.CesiumMath.clamp(O.y/g.height,0,1);m&&(E[A+k]=U,E[A+1+k]=q),d&&(E[A]=U,E[A+1]=q),A+=2}if(t.normal||t.tangent||t.bitangent||s){const G=i+1,O=i+2;if(h){if(D+3<l){const U=n.Cartesian3.fromArray(a,D+3,Pe);if(R){const q=n.Cartesian3.fromArray(a,D+l,Ce);V&&me(Y,U,q,_),n.Cartesian3.subtract(U,Y,U),n.Cartesian3.subtract(q,Y,q),u=n.Cartesian3.normalize(n.Cartesian3.cross(q,U,u),u),R=!1}n.Cartesian3.equalsEpsilon(U,Y,N.CesiumMath.EPSILON10)&&(R=!0)}(t.tangent||t.bitangent)&&(w=_.geodeticSurfaceNormal(Y,w),t.tangent&&(y=n.Cartesian3.normalize(n.Cartesian3.cross(w,u,y),y)))}else u=_.geodeticSurfaceNormal(Y,u),(t.tangent||t.bitangent)&&(V&&($=n.Cartesian3.fromArray(P,i,$),S=n.Cartesian3.cross(n.Cartesian3.UNIT_Z,$,S),S=n.Cartesian3.normalize(n.Matrix3.multiplyByVector(C,S,S),S),t.bitangent&&(K=n.Cartesian3.normalize(n.Cartesian3.cross($,S,K),K))),y=n.Cartesian3.cross(n.Cartesian3.UNIT_Z,u,y),y=n.Cartesian3.normalize(n.Matrix3.multiplyByVector(C,y,y),y),t.bitangent&&(w=n.Cartesian3.normalize(n.Cartesian3.cross(u,y,w),w)));t.normal&&(e.wall?(P[i+b]=u.x,P[G+b]=u.y,P[O+b]=u.z):m&&(P[i+b]=-u.x,P[G+b]=-u.y,P[O+b]=-u.z),(d&&!V||h)&&(P[i]=u.x,P[G]=u.y,P[O]=u.z)),s&&(h&&(u=_.geodeticSurfaceNormal(Y,u)),I[i+b]=-u.x,I[G+b]=-u.y,I[O+b]=-u.z),t.tangent&&(e.wall?(c[i+b]=y.x,c[G+b]=y.y,c[O+b]=y.z):m&&(c[i+b]=-y.x,c[G+b]=-y.y,c[O+b]=-y.z),d&&(V?(c[i]=S.x,c[G]=S.y,c[O]=S.z):(c[i]=y.x,c[G]=y.y,c[O]=y.z))),t.bitangent&&(m&&(T[i+b]=w.x,T[G+b]=w.y,T[O+b]=w.z),d&&(V?(T[i]=K.x,T[G]=K.y,T[O]=K.z):(T[i]=w.x,T[G]=w.y,T[O]=w.z))),i+=3}}t.st&&!p.defined(f)&&(o.attributes.st=new B.GeometryAttribute({componentDatatype:j.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:E})),t.normal&&(o.attributes.normal=new B.GeometryAttribute({componentDatatype:j.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:P})),t.tangent&&(o.attributes.tangent=new B.GeometryAttribute({componentDatatype:j.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:c})),t.bitangent&&(o.attributes.bitangent=new B.GeometryAttribute({componentDatatype:j.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),s&&(o.attributes.extrudeDirection=new B.GeometryAttribute({componentDatatype:j.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:I}))}if(e.extrude&&p.defined(e.offsetAttribute)){const g=a.length/3;let r=new Uint8Array(g);if(e.offsetAttribute===oe.GeometryOffsetAttribute.TOP)d&&m||h?r=r.fill(1,0,g/2):d&&(r=r.fill(1));else{const _=e.offsetAttribute===oe.GeometryOffsetAttribute.NONE?0:1;r=r.fill(_)}o.attributes.applyOffset=new B.GeometryAttribute({componentDatatype:j.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return o}const ve=new n.Cartographic,Ee=new n.Cartographic,W={westOverIDL:0,eastOverIDL:0};let Z=new re.EllipsoidGeodesic;function le(e,t,o,s,a){if(a=p.defaultValue(a,new z.Rectangle),!p.defined(e)||e.length<3)return a.west=0,a.north=0,a.south=0,a.east=0,a;if(o===ee.ArcType.RHUMB)return z.Rectangle.fromCartesianArray(e,t,a);Z.ellipsoid.equals(t)||(Z=new re.EllipsoidGeodesic(void 0,void 0,t)),a.west=Number.POSITIVE_INFINITY,a.east=Number.NEGATIVE_INFINITY,a.south=Number.POSITIVE_INFINITY,a.north=Number.NEGATIVE_INFINITY,W.westOverIDL=Number.POSITIVE_INFINITY,W.eastOverIDL=Number.NEGATIVE_INFINITY;const f=1/N.CesiumMath.chordLength(s,t.maximumRadius),l=e.length;let h,d=t.cartesianToCartographic(e[0],Ee),m=ve;for(let g=1;g<l;g++)h=m,m=d,d=t.cartesianToCartographic(e[g],h),Z.setEndPoints(m,d),ue(Z,f,a,W);return h=m,m=d,d=t.cartesianToCartographic(e[0],h),Z.setEndPoints(m,d),ue(Z,f,a,W),a.east-a.west>W.eastOverIDL-W.westOverIDL&&(a.west=W.westOverIDL,a.east=W.eastOverIDL,a.east>N.CesiumMath.PI&&(a.east=a.east-N.CesiumMath.TWO_PI),a.west>N.CesiumMath.PI&&(a.west=a.west-N.CesiumMath.TWO_PI)),a}const Ge=new n.Cartographic;function ue(e,t,o,s){const a=e.surfaceDistance,f=Math.ceil(a*t),l=f>0?a/(f-1):Number.POSITIVE_INFINITY;let h=0;for(let d=0;d<f;d++){const m=e.interpolateUsingSurfaceDistance(h,Ge);h+=l;const g=m.longitude,r=m.latitude;o.west=Math.min(o.west,g),o.east=Math.max(o.east,g),o.south=Math.min(o.south,r),o.north=Math.max(o.north,r);const _=g>=0?g:g+N.CesiumMath.TWO_PI;s.westOverIDL=Math.min(s.westOverIDL,_),s.eastOverIDL=Math.max(s.eastOverIDL,_)}}const ce=[];function Oe(e,t,o,s,a,f,l,h,d,m){const g={walls:[]};let r;if(l||h){const c=L.PolygonGeometryLibrary.createGeometryFromPositions(e,t,o,s,f,d,m),T=c.attributes.position.values,I=c.indices;let A,i;if(l&&h){const u=T.concat(T);A=u.length/3,i=ne.IndexDatatype.createTypedArray(A,2*I.length),i.set(I);const y=I.length,w=A/2;for(r=0;r<y;r+=3){const R=i[r]+w,x=i[r+1]+w,C=i[r+2]+w;i[r+y]=C,i[r+1+y]=x,i[r+2+y]=R}if(c.attributes.position.values=u,f&&d.normal){const R=c.attributes.normal.values;c.attributes.normal.values=new Float32Array(u.length),c.attributes.normal.values.set(R)}if(d.st&&p.defined(o)){const R=c.attributes.st.values;c.attributes.st.values=new Float32Array(2*A),c.attributes.st.values=R.concat(R)}c.indices=i}else if(h){for(A=T.length/3,i=ne.IndexDatatype.createTypedArray(A,I.length),r=0;r<I.length;r+=3)i[r]=I[r+2],i[r+1]=I[r+1],i[r+2]=I[r];c.indices=i}g.topAndBottom=new X.GeometryInstance({geometry:c})}let _=a.outerRing,v=te.EllipsoidTangentPlane.fromPoints(_,e),V=v.projectPointsOntoPlane(_,ce),H=Q.PolygonPipeline.computeWindingOrder2D(V);H===Q.WindingOrder.CLOCKWISE&&(_=_.slice().reverse());let E=L.PolygonGeometryLibrary.computeWallGeometry(_,o,e,s,f,m);g.walls.push(new X.GeometryInstance({geometry:E}));const P=a.holes;for(r=0;r<P.length;r++){let c=P[r];v=te.EllipsoidTangentPlane.fromPoints(c,e),V=v.projectPointsOntoPlane(c,ce),H=Q.PolygonPipeline.computeWindingOrder2D(V),H===Q.WindingOrder.COUNTER_CLOCKWISE&&(c=c.slice().reverse()),E=L.PolygonGeometryLibrary.computeWallGeometry(c,o,e,s,f,m),g.walls.push(new X.GeometryInstance({geometry:E}))}return g}function F(e){const t=e.polygonHierarchy,o=p.defaultValue(e.vertexFormat,M.VertexFormat.DEFAULT),s=p.defaultValue(e.ellipsoid,n.Ellipsoid.WGS84),a=p.defaultValue(e.granularity,N.CesiumMath.RADIANS_PER_DEGREE),f=p.defaultValue(e.stRotation,0),l=e.textureCoordinates,h=p.defaultValue(e.perPositionHeight,!1),d=h&&p.defined(e.extrudedHeight);let m=p.defaultValue(e.height,0),g=p.defaultValue(e.extrudedHeight,m);if(!d){const r=Math.max(m,g);g=Math.min(m,g),m=r}this._vertexFormat=M.VertexFormat.clone(o),this._ellipsoid=n.Ellipsoid.clone(s),this._granularity=a,this._stRotation=f,this._height=m,this._extrudedHeight=g,this._closeTop=p.defaultValue(e.closeTop,!0),this._closeBottom=p.defaultValue(e.closeBottom,!0),this._polygonHierarchy=t,this._perPositionHeight=h,this._perPositionHeightExtrude=d,this._shadowVolume=p.defaultValue(e.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=e.offsetAttribute,this._arcType=p.defaultValue(e.arcType,ee.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=l,this.packedLength=L.PolygonGeometryLibrary.computeHierarchyPackedLength(t,n.Cartesian3)+n.Ellipsoid.packedLength+M.VertexFormat.packedLength+(l?L.PolygonGeometryLibrary.computeHierarchyPackedLength(l,z.Cartesian2):1)+12}F.fromPositions=function(e){return new F({polygonHierarchy:{positions:(e=p.defaultValue(e,p.defaultValue.EMPTY_OBJECT)).positions},height:e.height,extrudedHeight:e.extrudedHeight,vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,closeTop:e.closeTop,closeBottom:e.closeBottom,offsetAttribute:e.offsetAttribute,arcType:e.arcType,textureCoordinates:e.textureCoordinates})},F.pack=function(e,t,o){return o=p.defaultValue(o,0),o=L.PolygonGeometryLibrary.packPolygonHierarchy(e._polygonHierarchy,t,o,n.Cartesian3),n.Ellipsoid.pack(e._ellipsoid,t,o),o+=n.Ellipsoid.packedLength,M.VertexFormat.pack(e._vertexFormat,t,o),o+=M.VertexFormat.packedLength,t[o++]=e._height,t[o++]=e._extrudedHeight,t[o++]=e._granularity,t[o++]=e._stRotation,t[o++]=e._perPositionHeightExtrude?1:0,t[o++]=e._perPositionHeight?1:0,t[o++]=e._closeTop?1:0,t[o++]=e._closeBottom?1:0,t[o++]=e._shadowVolume?1:0,t[o++]=p.defaultValue(e._offsetAttribute,-1),t[o++]=e._arcType,p.defined(e._textureCoordinates)?o=L.PolygonGeometryLibrary.packPolygonHierarchy(e._textureCoordinates,t,o,z.Cartesian2):t[o++]=-1,t[o++]=e.packedLength,t};const Le=n.Ellipsoid.clone(n.Ellipsoid.UNIT_SPHERE),Ve=new M.VertexFormat,He={polygonHierarchy:{}};return F.unpack=function(e,t,o){t=p.defaultValue(t,0);const s=L.PolygonGeometryLibrary.unpackPolygonHierarchy(e,t,n.Cartesian3);t=s.startingIndex,delete s.startingIndex;const a=n.Ellipsoid.unpack(e,t,Le);t+=n.Ellipsoid.packedLength;const f=M.VertexFormat.unpack(e,t,Ve);t+=M.VertexFormat.packedLength;const l=e[t++],h=e[t++],d=e[t++],m=e[t++],g=e[t++]===1,r=e[t++]===1,_=e[t++]===1,v=e[t++]===1,V=e[t++]===1,H=e[t++],E=e[t++],P=e[t]===-1?void 0:L.PolygonGeometryLibrary.unpackPolygonHierarchy(e,t,z.Cartesian2);p.defined(P)?(t=P.startingIndex,delete P.startingIndex):t++;const c=e[t++];return p.defined(o)||(o=new F(He)),o._polygonHierarchy=s,o._ellipsoid=n.Ellipsoid.clone(a,o._ellipsoid),o._vertexFormat=M.VertexFormat.clone(f,o._vertexFormat),o._height=l,o._extrudedHeight=h,o._granularity=d,o._stRotation=m,o._perPositionHeightExtrude=g,o._perPositionHeight=r,o._closeTop=_,o._closeBottom=v,o._shadowVolume=V,o._offsetAttribute=H===-1?void 0:H,o._arcType=E,o._textureCoordinates=P,o.packedLength=c,o},F.computeRectangle=function(e,t){const o=p.defaultValue(e.granularity,N.CesiumMath.RADIANS_PER_DEGREE),s=p.defaultValue(e.arcType,ee.ArcType.GEODESIC),a=e.polygonHierarchy,f=p.defaultValue(e.ellipsoid,n.Ellipsoid.WGS84);return le(a.positions,f,s,o,t)},F.createGeometry=function(e){const t=e._vertexFormat,o=e._ellipsoid,s=e._granularity,a=e._stRotation,f=e._polygonHierarchy,l=e._perPositionHeight,h=e._closeTop,d=e._closeBottom,m=e._arcType,g=e._textureCoordinates,r=p.defined(g);let _=f.positions;if(_.length<3)return;const v=te.EllipsoidTangentPlane.fromPoints(_,o),V=L.PolygonGeometryLibrary.polygonsFromHierarchy(f,r,v.projectPointsOntoPlane.bind(v),!l,o),H=V.hierarchy,E=V.polygons,P=r?L.PolygonGeometryLibrary.polygonsFromHierarchy(g,!0,function(x){return x},!1).polygons:void 0;if(H.length===0)return;_=H[0].outerRing;const c=L.PolygonGeometryLibrary.computeBoundingRectangle(v.plane.normal,v.projectPointOntoPlane.bind(v),_,a,ge),T=[],I=e._height,A=e._extrudedHeight,i={perPositionHeight:l,vertexFormat:t,geometry:void 0,tangentPlane:v,boundingRectangle:c,ellipsoid:o,stRotation:a,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:m};let u;if(e._perPositionHeightExtrude||!N.CesiumMath.equalsEpsilon(I,A,0,N.CesiumMath.EPSILON2))for(i.extrude=!0,i.top=h,i.bottom=d,i.shadowVolume=e._shadowVolume,i.offsetAttribute=e._offsetAttribute,u=0;u<E.length;u++){const x=Oe(o,E[u],r?P[u]:void 0,s,H[u],l,h,d,t,m);let C;h&&d?(C=x.topAndBottom,i.geometry=L.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(C.geometry,I,A,o,l)):h?(C=x.topAndBottom,C.geometry.attributes.position.values=Q.PolygonPipeline.scaleToGeodeticHeight(C.geometry.attributes.position.values,I,o,!l),i.geometry=C.geometry):d&&(C=x.topAndBottom,C.geometry.attributes.position.values=Q.PolygonPipeline.scaleToGeodeticHeight(C.geometry.attributes.position.values,A,o,!0),i.geometry=C.geometry),(h||d)&&(i.wall=!1,C.geometry=ae(i),T.push(C));const b=x.walls;i.wall=!0;for(let k=0;k<b.length;k++){const D=b[k];i.geometry=L.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(D.geometry,I,A,o,l),D.geometry=ae(i),T.push(D)}}else for(u=0;u<E.length;u++){const x=new X.GeometryInstance({geometry:L.PolygonGeometryLibrary.createGeometryFromPositions(o,E[u],r?P[u]:void 0,s,l,t,m)});if(x.geometry.attributes.position.values=Q.PolygonPipeline.scaleToGeodeticHeight(x.geometry.attributes.position.values,I,o,!l),i.geometry=x.geometry,x.geometry=ae(i),p.defined(e._offsetAttribute)){const C=x.geometry.attributes.position.values.length,b=e._offsetAttribute===oe.GeometryOffsetAttribute.NONE?0:1,k=new Uint8Array(C/3).fill(b);x.geometry.attributes.applyOffset=new B.GeometryAttribute({componentDatatype:j.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:k})}T.push(x)}const y=de.GeometryPipeline.combineInstances(T)[0];y.attributes.position.values=new Float64Array(y.attributes.position.values),y.indices=ne.IndexDatatype.createTypedArray(y.attributes.position.values.length/3,y.indices);const w=y.attributes,R=J.BoundingSphere.fromVertices(w.position.values);return t.position||delete w.position,new B.Geometry({attributes:w,indices:y.indices,primitiveType:y.primitiveType,boundingSphere:R,offsetAttribute:e._offsetAttribute})},F.createShadowVolume=function(e,t,o){const s=e._granularity,a=e._ellipsoid,f=t(s,a),l=o(s,a);return new F({polygonHierarchy:e._polygonHierarchy,ellipsoid:a,stRotation:e._stRotation,granularity:s,perPositionHeight:!1,extrudedHeight:f,height:l,vertexFormat:M.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(F.prototype,{rectangle:{get:function(){if(!p.defined(this._rectangle)){const e=this._polygonHierarchy.positions;this._rectangle=le(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return p.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){const t=-e._stRotation;if(t===0)return[0,0,0,1,1,0];const o=e._ellipsoid,s=e._polygonHierarchy.positions,a=e.rectangle;return B.Geometry._textureCoordinateRotationPoints(s,t,o,a)}(this)),this._textureCoordinateRotationPoints}}}),function(e,t){return p.defined(t)&&(e=F.unpack(e,t)),e._ellipsoid=n.Ellipsoid.clone(e._ellipsoid),F.createGeometry(e)}});
