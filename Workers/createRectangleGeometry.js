/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./defaultValue-ebbd2e4d","./Matrix3-2955527a","./Matrix2-462b83d3","./Transforms-5b74e989","./ComponentDatatype-f9ac3ed8","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryInstance-4ef1b8a5","./GeometryOffsetAttribute-739bec2c","./GeometryPipeline-3cfa9822","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolygonPipeline-4fdc8b4f","./RectangleGeometryLibrary-a4beb9d0","./VertexFormat-5b02b45a","./RuntimeError-38a08050","./combine-55e9f355","./WebGLConstants-544672c2","./AttributeCompression-6f93ad0c","./EncodedCartesian3-d4159969","./IntersectionTests-2a07bba4","./Plane-7e97483e","./EllipsoidRhumbLine-8bc8a516"],function(x,o,b,ot,X,k,Zt,St,wt,Kt,Pt,Z,Vt,tt,Q,me,pe,de,ye,ge,fe,he,be){"use strict";const Lt=new o.Cartesian3,It=new o.Cartesian3,kt=new o.Cartesian3,Ht=new o.Cartesian3,zt=new b.Rectangle,$t=new b.Cartesian2,te=new ot.BoundingSphere,ee=new ot.BoundingSphere;function Bt(t,a){const e=new k.Geometry({attributes:new Zt.GeometryAttributes,primitiveType:k.PrimitiveType.TRIANGLES});return e.attributes.position=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a.positions}),t.normal&&(e.attributes.normal=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:a.normals})),t.tangent&&(e.attributes.tangent=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:a.tangents})),t.bitangent&&(e.attributes.bitangent=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:a.bitangents})),e}const Dt=new o.Cartesian3,Ut=new o.Cartesian3;function Yt(t,a){const e=t._vertexFormat,s=t._ellipsoid,i=a.height,u=a.width,f=a.northCap,v=a.southCap;let C=0,P=i,n=i,r=0;f&&(C=1,n-=1,r+=1),v&&(P-=1,n-=1,r+=1),r+=u*n;const c=e.position?new Float64Array(3*r):void 0,l=e.st?new Float32Array(2*r):void 0;let m=0,z=0;const G=Lt,A=$t;let B=Number.MAX_VALUE,U=Number.MAX_VALUE,J=-Number.MAX_VALUE,V=-Number.MAX_VALUE;for(let _=C;_<P;++_)for(let h=0;h<u;++h)tt.RectangleGeometryLibrary.computePosition(a,s,e.st,_,h,G,A),c[m++]=G.x,c[m++]=G.y,c[m++]=G.z,e.st&&(l[z++]=A.x,l[z++]=A.y,B=Math.min(B,A.x),U=Math.min(U,A.y),J=Math.max(J,A.x),V=Math.max(V,A.y));if(f&&(tt.RectangleGeometryLibrary.computePosition(a,s,e.st,0,0,G,A),c[m++]=G.x,c[m++]=G.y,c[m++]=G.z,e.st&&(l[z++]=A.x,l[z++]=A.y,B=A.x,U=A.y,J=A.x,V=A.y)),v&&(tt.RectangleGeometryLibrary.computePosition(a,s,e.st,i-1,0,G,A),c[m++]=G.x,c[m++]=G.y,c[m]=G.z,e.st&&(l[z++]=A.x,l[z]=A.y,B=Math.min(B,A.x),U=Math.min(U,A.y),J=Math.max(J,A.x),V=Math.max(V,A.y))),e.st&&(B<0||U<0||J>1||V>1))for(let _=0;_<l.length;_+=2)l[_]=(l[_]-B)/(J-B),l[_+1]=(l[_+1]-U)/(V-U);const p=function(_,h,I,H){const j=_.length,K=h.normal?new Float32Array(j):void 0,st=h.tangent?new Float32Array(j):void 0,lt=h.bitangent?new Float32Array(j):void 0;let Y=0;const R=Ht,g=kt;let L=It;if(h.normal||h.tangent||h.bitangent)for(let D=0;D<j;D+=3){const et=o.Cartesian3.fromArray(_,D,Lt),T=Y+1,O=Y+2;L=I.geodeticSurfaceNormal(et,L),(h.tangent||h.bitangent)&&(o.Cartesian3.cross(o.Cartesian3.UNIT_Z,L,g),o.Matrix3.multiplyByVector(H,g,g),o.Cartesian3.normalize(g,g),h.bitangent&&o.Cartesian3.normalize(o.Cartesian3.cross(L,g,R),R)),h.normal&&(K[Y]=L.x,K[T]=L.y,K[O]=L.z),h.tangent&&(st[Y]=g.x,st[T]=g.y,st[O]=g.z),h.bitangent&&(lt[Y]=R.x,lt[T]=R.y,lt[O]=R.z),Y+=3}return Bt(h,{positions:_,normals:K,tangents:st,bitangents:lt})}(c,e,s,a.tangentRotationMatrix);let rt=6*(u-1)*(n-1);f&&(rt+=3*(u-1)),v&&(rt+=3*(u-1));const F=Pt.IndexDatatype.createTypedArray(r,rt);let N,S=0,M=0;for(N=0;N<n-1;++N){for(let _=0;_<u-1;++_){const h=S,I=h+u,H=I+1,j=h+1;F[M++]=h,F[M++]=I,F[M++]=j,F[M++]=j,F[M++]=I,F[M++]=H,++S}++S}if(f||v){let _=r-1;const h=r-1;let I,H;if(f&&v&&(_=r-2),S=0,f)for(N=0;N<u-1;N++)I=S,H=I+1,F[M++]=_,F[M++]=I,F[M++]=H,++S;if(v)for(S=(n-1)*u,N=0;N<u-1;N++)I=S,H=I+1,F[M++]=I,F[M++]=h,F[M++]=H,++S}return p.indices=F,e.st&&(p.attributes.st=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:l})),p}function gt(t,a,e,s,i){return t[a++]=s[e],t[a++]=s[e+1],t[a++]=s[e+2],t[a++]=i[e],t[a++]=i[e+1],t[a]=i[e+2],t}function ft(t,a,e,s){return t[a++]=s[e],t[a++]=s[e+1],t[a++]=s[e],t[a]=s[e+1],t}const Mt=new Q.VertexFormat;function ae(t,a){const e=t._shadowVolume,s=t._offsetAttribute,i=t._vertexFormat,u=t._extrudedHeight,f=t._surfaceHeight,v=t._ellipsoid,C=a.height,P=a.width;let n;if(e){const y=Q.VertexFormat.clone(i,Mt);y.normal=!0,t._vertexFormat=y}const r=Yt(t,a);e&&(t._vertexFormat=i);let c=Vt.PolygonPipeline.scaleToGeodeticHeight(r.attributes.position.values,f,v,!1);c=new Float64Array(c);let l=c.length;const m=2*l,z=new Float64Array(m);z.set(c);const G=Vt.PolygonPipeline.scaleToGeodeticHeight(r.attributes.position.values,u,v);z.set(G,l),r.attributes.position.values=z;const A=i.normal?new Float32Array(m):void 0,B=i.tangent?new Float32Array(m):void 0,U=i.bitangent?new Float32Array(m):void 0,J=i.st?new Float32Array(m/3*2):void 0;let V,p,rt;if(i.normal){for(p=r.attributes.normal.values,A.set(p),n=0;n<l;n++)p[n]=-p[n];A.set(p,l),r.attributes.normal.values=A}if(e){p=r.attributes.normal.values,i.normal||(r.attributes.normal=void 0);const y=new Float32Array(m);for(n=0;n<l;n++)p[n]=-p[n];y.set(p,l),r.attributes.extrudeDirection=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:y})}const F=x.defined(s);if(F){const y=l/3*2;let E=new Uint8Array(y);s===wt.GeometryOffsetAttribute.TOP?E=E.fill(1,0,y/2):(rt=s===wt.GeometryOffsetAttribute.NONE?0:1,E=E.fill(rt)),r.attributes.applyOffset=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:E})}if(i.tangent){const y=r.attributes.tangent.values;for(B.set(y),n=0;n<l;n++)y[n]=-y[n];B.set(y,l),r.attributes.tangent.values=B}if(i.bitangent){const y=r.attributes.bitangent.values;U.set(y),U.set(y,l),r.attributes.bitangent.values=U}i.st&&(V=r.attributes.st.values,J.set(V),J.set(V,l/3*2),r.attributes.st.values=J);const N=r.indices,S=N.length,M=l/3,_=Pt.IndexDatatype.createTypedArray(m/3,2*S);for(_.set(N),n=0;n<S;n+=3)_[n+S]=N[n+2]+M,_[n+1+S]=N[n+1]+M,_[n+2+S]=N[n]+M;r.indices=_;const h=a.northCap,I=a.southCap;let H=C,j=2,K=0,st=4,lt=4;h&&(j-=1,H-=1,K+=1,st-=2,lt-=1),I&&(j-=1,H-=1,K+=1,st-=2,lt-=1),K+=j*P+2*H-st;const Y=2*(K+lt);let R=new Float64Array(3*Y);const g=e?new Float32Array(3*Y):void 0;let L=F?new Uint8Array(Y):void 0,D=i.st?new Float32Array(2*Y):void 0;const et=s===wt.GeometryOffsetAttribute.TOP;F&&!et&&(rt=s===wt.GeometryOffsetAttribute.ALL?1:0,L=L.fill(rt));let T=0,O=0,w=0,q=0;const ut=P*H;let d;for(n=0;n<ut;n+=P)d=3*n,R=gt(R,T,d,c,G),T+=6,i.st&&(D=ft(D,O,2*n,V),O+=4),e&&(w+=3,g[w++]=p[d],g[w++]=p[d+1],g[w++]=p[d+2]),et&&(L[q++]=1,q+=1);if(I){const y=h?ut+1:ut;for(d=3*y,n=0;n<2;n++)R=gt(R,T,d,c,G),T+=6,i.st&&(D=ft(D,O,2*y,V),O+=4),e&&(w+=3,g[w++]=p[d],g[w++]=p[d+1],g[w++]=p[d+2]),et&&(L[q++]=1,q+=1)}else for(n=ut-P;n<ut;n++)d=3*n,R=gt(R,T,d,c,G),T+=6,i.st&&(D=ft(D,O,2*n,V),O+=4),e&&(w+=3,g[w++]=p[d],g[w++]=p[d+1],g[w++]=p[d+2]),et&&(L[q++]=1,q+=1);for(n=ut-1;n>0;n-=P)d=3*n,R=gt(R,T,d,c,G),T+=6,i.st&&(D=ft(D,O,2*n,V),O+=4),e&&(w+=3,g[w++]=p[d],g[w++]=p[d+1],g[w++]=p[d+2]),et&&(L[q++]=1,q+=1);if(h){const y=ut;for(d=3*y,n=0;n<2;n++)R=gt(R,T,d,c,G),T+=6,i.st&&(D=ft(D,O,2*y,V),O+=4),e&&(w+=3,g[w++]=p[d],g[w++]=p[d+1],g[w++]=p[d+2]),et&&(L[q++]=1,q+=1)}else for(n=P-1;n>=0;n--)d=3*n,R=gt(R,T,d,c,G),T+=6,i.st&&(D=ft(D,O,2*n,V),O+=4),e&&(w+=3,g[w++]=p[d],g[w++]=p[d+1],g[w++]=p[d+2]),et&&(L[q++]=1,q+=1);let ct=function(y,E,ce){const bt=y.length,pt=E.normal?new Float32Array(bt):void 0,dt=E.tangent?new Float32Array(bt):void 0,yt=E.bitangent?new Float32Array(bt):void 0;let _t=0,At=0,xt=0,Ot=!0,at=Ht,nt=kt,$=It;if(E.normal||E.tangent||E.bitangent)for(let vt=0;vt<bt;vt+=6){const Gt=o.Cartesian3.fromArray(y,vt,Lt),Ft=o.Cartesian3.fromArray(y,(vt+6)%bt,Dt);if(Ot){const Nt=o.Cartesian3.fromArray(y,(vt+3)%bt,Ut);o.Cartesian3.subtract(Ft,Gt,Ft),o.Cartesian3.subtract(Nt,Gt,Nt),$=o.Cartesian3.normalize(o.Cartesian3.cross(Nt,Ft,$),$),Ot=!1}o.Cartesian3.equalsEpsilon(Ft,Gt,Z.CesiumMath.EPSILON10)&&(Ot=!0),(E.tangent||E.bitangent)&&(at=ce.geodeticSurfaceNormal(Gt,at),E.tangent&&(nt=o.Cartesian3.normalize(o.Cartesian3.cross(at,$,nt),nt))),E.normal&&(pt[_t++]=$.x,pt[_t++]=$.y,pt[_t++]=$.z,pt[_t++]=$.x,pt[_t++]=$.y,pt[_t++]=$.z),E.tangent&&(dt[At++]=nt.x,dt[At++]=nt.y,dt[At++]=nt.z,dt[At++]=nt.x,dt[At++]=nt.y,dt[At++]=nt.z),E.bitangent&&(yt[xt++]=at.x,yt[xt++]=at.y,yt[xt++]=at.z,yt[xt++]=at.x,yt[xt++]=at.y,yt[xt++]=at.z)}return Bt(E,{positions:y,normals:pt,tangents:dt,bitangents:yt})}(R,i,v);i.st&&(ct.attributes.st=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:D})),e&&(ct.attributes.extrudeDirection=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:g})),F&&(ct.attributes.applyOffset=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:L}));const mt=Pt.IndexDatatype.createTypedArray(Y,6*K);let Ct,Rt,jt,Et;l=R.length/3;let ht=0;for(n=0;n<l-1;n+=2){Ct=n,Et=(Ct+2)%l;const y=o.Cartesian3.fromArray(R,3*Ct,Dt),E=o.Cartesian3.fromArray(R,3*Et,Ut);o.Cartesian3.equalsEpsilon(y,E,Z.CesiumMath.EPSILON10)||(Rt=(Ct+1)%l,jt=(Rt+2)%l,mt[ht++]=Ct,mt[ht++]=Rt,mt[ht++]=Et,mt[ht++]=Et,mt[ht++]=Rt,mt[ht++]=jt)}return ct.indices=mt,ct=Kt.GeometryPipeline.combineInstances([new St.GeometryInstance({geometry:r}),new St.GeometryInstance({geometry:ct})]),ct[0]}const ne=[new o.Cartesian3,new o.Cartesian3,new o.Cartesian3,new o.Cartesian3],qt=new o.Cartographic,oe=new o.Cartographic;function Tt(t,a,e,s,i){if(e===0)return b.Rectangle.clone(t,i);const u=tt.RectangleGeometryLibrary.computeOptions(t,a,e,0,zt,qt),f=u.height,v=u.width,C=ne;return tt.RectangleGeometryLibrary.computePosition(u,s,!1,0,0,C[0]),tt.RectangleGeometryLibrary.computePosition(u,s,!1,0,v-1,C[1]),tt.RectangleGeometryLibrary.computePosition(u,s,!1,f-1,0,C[2]),tt.RectangleGeometryLibrary.computePosition(u,s,!1,f-1,v-1,C[3]),b.Rectangle.fromCartesianArray(C,s,i)}function W(t){const a=(t=x.defaultValue(t,x.defaultValue.EMPTY_OBJECT)).rectangle,e=x.defaultValue(t.height,0),s=x.defaultValue(t.extrudedHeight,e);this._rectangle=b.Rectangle.clone(a),this._granularity=x.defaultValue(t.granularity,Z.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=o.Ellipsoid.clone(x.defaultValue(t.ellipsoid,o.Ellipsoid.WGS84)),this._surfaceHeight=Math.max(e,s),this._rotation=x.defaultValue(t.rotation,0),this._stRotation=x.defaultValue(t.stRotation,0),this._vertexFormat=Q.VertexFormat.clone(x.defaultValue(t.vertexFormat,Q.VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(e,s),this._shadowVolume=x.defaultValue(t.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=t.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}W.packedLength=b.Rectangle.packedLength+o.Ellipsoid.packedLength+Q.VertexFormat.packedLength+7,W.pack=function(t,a,e){return e=x.defaultValue(e,0),b.Rectangle.pack(t._rectangle,a,e),e+=b.Rectangle.packedLength,o.Ellipsoid.pack(t._ellipsoid,a,e),e+=o.Ellipsoid.packedLength,Q.VertexFormat.pack(t._vertexFormat,a,e),e+=Q.VertexFormat.packedLength,a[e++]=t._granularity,a[e++]=t._surfaceHeight,a[e++]=t._rotation,a[e++]=t._stRotation,a[e++]=t._extrudedHeight,a[e++]=t._shadowVolume?1:0,a[e]=x.defaultValue(t._offsetAttribute,-1),a};const Xt=new b.Rectangle,Qt=o.Ellipsoid.clone(o.Ellipsoid.UNIT_SPHERE),it={rectangle:Xt,ellipsoid:Qt,vertexFormat:Mt,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};W.unpack=function(t,a,e){a=x.defaultValue(a,0);const s=b.Rectangle.unpack(t,a,Xt);a+=b.Rectangle.packedLength;const i=o.Ellipsoid.unpack(t,a,Qt);a+=o.Ellipsoid.packedLength;const u=Q.VertexFormat.unpack(t,a,Mt);a+=Q.VertexFormat.packedLength;const f=t[a++],v=t[a++],C=t[a++],P=t[a++],n=t[a++],r=t[a++]===1,c=t[a];return x.defined(e)?(e._rectangle=b.Rectangle.clone(s,e._rectangle),e._ellipsoid=o.Ellipsoid.clone(i,e._ellipsoid),e._vertexFormat=Q.VertexFormat.clone(u,e._vertexFormat),e._granularity=f,e._surfaceHeight=v,e._rotation=C,e._stRotation=P,e._extrudedHeight=n,e._shadowVolume=r,e._offsetAttribute=c===-1?void 0:c,e):(it.granularity=f,it.height=v,it.rotation=C,it.stRotation=P,it.extrudedHeight=n,it.shadowVolume=r,it.offsetAttribute=c===-1?void 0:c,new W(it))},W.computeRectangle=function(t,a){const e=(t=x.defaultValue(t,x.defaultValue.EMPTY_OBJECT)).rectangle,s=x.defaultValue(t.granularity,Z.CesiumMath.RADIANS_PER_DEGREE),i=x.defaultValue(t.ellipsoid,o.Ellipsoid.WGS84);return Tt(e,s,x.defaultValue(t.rotation,0),i,a)};const ie=new o.Matrix3,Wt=new ot.Quaternion,re=new o.Cartographic;W.createGeometry=function(t){if(Z.CesiumMath.equalsEpsilon(t._rectangle.north,t._rectangle.south,Z.CesiumMath.EPSILON10)||Z.CesiumMath.equalsEpsilon(t._rectangle.east,t._rectangle.west,Z.CesiumMath.EPSILON10))return;let a=t._rectangle;const e=t._ellipsoid,s=t._rotation,i=t._stRotation,u=t._vertexFormat,f=tt.RectangleGeometryLibrary.computeOptions(a,t._granularity,s,i,zt,qt,oe),v=ie;if(i!==0||s!==0){const l=b.Rectangle.center(a,re),m=e.geodeticSurfaceNormalCartographic(l,Dt);ot.Quaternion.fromAxisAngle(m,-i,Wt),o.Matrix3.fromQuaternion(Wt,v)}else o.Matrix3.clone(o.Matrix3.IDENTITY,v);const C=t._surfaceHeight,P=t._extrudedHeight,n=!Z.CesiumMath.equalsEpsilon(C,P,0,Z.CesiumMath.EPSILON2);let r,c;if(f.lonScalar=1/t._rectangle.width,f.latScalar=1/t._rectangle.height,f.tangentRotationMatrix=v,a=t._rectangle,n){r=ae(t,f);const l=ot.BoundingSphere.fromRectangle3D(a,e,C,ee),m=ot.BoundingSphere.fromRectangle3D(a,e,P,te);c=ot.BoundingSphere.union(l,m)}else{if(r=Yt(t,f),r.attributes.position.values=Vt.PolygonPipeline.scaleToGeodeticHeight(r.attributes.position.values,C,e,!1),x.defined(t._offsetAttribute)){const l=r.attributes.position.values.length,m=t._offsetAttribute===wt.GeometryOffsetAttribute.NONE?0:1,z=new Uint8Array(l/3).fill(m);r.attributes.applyOffset=new k.GeometryAttribute({componentDatatype:X.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:z})}c=ot.BoundingSphere.fromRectangle3D(a,e,C)}return u.position||delete r.attributes.position,new k.Geometry({attributes:r.attributes,indices:r.indices,primitiveType:r.primitiveType,boundingSphere:c,offsetAttribute:t._offsetAttribute})},W.createShadowVolume=function(t,a,e){const s=t._granularity,i=t._ellipsoid,u=a(s,i),f=e(s,i);return new W({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:i,stRotation:t._stRotation,granularity:s,extrudedHeight:f,height:u,vertexFormat:Q.VertexFormat.POSITION_ONLY,shadowVolume:!0})};const Jt=new b.Rectangle,se=[new b.Cartesian2,new b.Cartesian2,new b.Cartesian2],le=new b.Matrix2,ue=new o.Cartographic;return Object.defineProperties(W.prototype,{rectangle:{get:function(){return x.defined(this._rotatedRectangle)||(this._rotatedRectangle=Tt(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return x.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(t._stRotation===0)return[0,0,0,1,1,0];const a=b.Rectangle.clone(t._rectangle,Jt),e=t._granularity,s=t._ellipsoid,i=Tt(a,e,t._rotation-t._stRotation,s,Jt),u=se;u[0].x=i.west,u[0].y=i.south,u[1].x=i.west,u[1].y=i.north,u[2].x=i.east,u[2].y=i.south;const f=t.rectangle,v=b.Matrix2.fromRotation(t._stRotation,le),C=b.Rectangle.center(f,ue);for(let l=0;l<3;++l){const m=u[l];m.x-=C.longitude,m.y-=C.latitude,b.Matrix2.multiplyByVector(v,m,m),m.x+=C.longitude,m.y+=C.latitude,m.x=(m.x-f.west)/f.width,m.y=(m.y-f.south)/f.height}const P=u[0],n=u[1],r=u[2],c=new Array(6);return b.Cartesian2.pack(P,c),b.Cartesian2.pack(n,c,2),b.Cartesian2.pack(r,c,4),c}(this)),this._textureCoordinateRotationPoints}}}),function(t,a){return x.defined(a)&&(t=W.unpack(t,a)),t._ellipsoid=o.Ellipsoid.clone(t._ellipsoid),t._rectangle=b.Rectangle.clone(t._rectangle),W.createGeometry(t)}});
