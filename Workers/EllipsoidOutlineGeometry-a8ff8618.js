/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Transforms-5b74e989","./Matrix3-2955527a","./ComponentDatatype-f9ac3ed8","./defaultValue-ebbd2e4d","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryOffsetAttribute-739bec2c","./IndexDatatype-7ccfd280","./Math-1fe079f3"],function(Y,F,m,R,f,D,J,j,q,I){"use strict";const H=new m.Cartesian3(1,1,1),T=Math.cos,z=Math.sin;function v(i){i=f.defaultValue(i,f.defaultValue.EMPTY_OBJECT);const a=f.defaultValue(i.radii,H),t=f.defaultValue(i.innerRadii,a),h=f.defaultValue(i.minimumClock,0),k=f.defaultValue(i.maximumClock,I.CesiumMath.TWO_PI),d=f.defaultValue(i.minimumCone,0),y=f.defaultValue(i.maximumCone,I.CesiumMath.PI),r=Math.round(f.defaultValue(i.stackPartitions,10)),M=Math.round(f.defaultValue(i.slicePartitions,8)),n=Math.round(f.defaultValue(i.subdivisions,128));this._radii=m.Cartesian3.clone(a),this._innerRadii=m.Cartesian3.clone(t),this._minimumClock=h,this._maximumClock=k,this._minimumCone=d,this._maximumCone=y,this._stackPartitions=r,this._slicePartitions=M,this._subdivisions=n,this._offsetAttribute=i.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}v.packedLength=2*m.Cartesian3.packedLength+8,v.pack=function(i,a,t){return t=f.defaultValue(t,0),m.Cartesian3.pack(i._radii,a,t),t+=m.Cartesian3.packedLength,m.Cartesian3.pack(i._innerRadii,a,t),t+=m.Cartesian3.packedLength,a[t++]=i._minimumClock,a[t++]=i._maximumClock,a[t++]=i._minimumCone,a[t++]=i._maximumCone,a[t++]=i._stackPartitions,a[t++]=i._slicePartitions,a[t++]=i._subdivisions,a[t]=f.defaultValue(i._offsetAttribute,-1),a};const N=new m.Cartesian3,B=new m.Cartesian3,p={radii:N,innerRadii:B,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};v.unpack=function(i,a,t){a=f.defaultValue(a,0);const h=m.Cartesian3.unpack(i,a,N);a+=m.Cartesian3.packedLength;const k=m.Cartesian3.unpack(i,a,B);a+=m.Cartesian3.packedLength;const d=i[a++],y=i[a++],r=i[a++],M=i[a++],n=i[a++],u=i[a++],w=i[a++],l=i[a];return f.defined(t)?(t._radii=m.Cartesian3.clone(h,t._radii),t._innerRadii=m.Cartesian3.clone(k,t._innerRadii),t._minimumClock=d,t._maximumClock=y,t._minimumCone=r,t._maximumCone=M,t._stackPartitions=n,t._slicePartitions=u,t._subdivisions=w,t._offsetAttribute=l===-1?void 0:l,t):(p.minimumClock=d,p.maximumClock=y,p.minimumCone=r,p.maximumCone=M,p.stackPartitions=n,p.slicePartitions=u,p.subdivisions=w,p.offsetAttribute=l===-1?void 0:l,new v(p))},v.createGeometry=function(i){const a=i._radii;if(a.x<=0||a.y<=0||a.z<=0)return;const t=i._innerRadii;if(t.x<=0||t.y<=0||t.z<=0)return;const h=i._minimumClock,k=i._maximumClock,d=i._minimumCone,y=i._maximumCone,r=i._subdivisions,M=m.Ellipsoid.fromCartesian3(a);let n=i._slicePartitions+1,u=i._stackPartitions+1;n=Math.round(n*Math.abs(k-h)/I.CesiumMath.TWO_PI),u=Math.round(u*Math.abs(y-d)/I.CesiumMath.PI),n<2&&(n=2),u<2&&(u=2);let w=0,l=1;const G=t.x!==a.x||t.y!==a.y||t.z!==a.z;let S=!1,U=!1;G&&(l=2,d>0&&(S=!0,w+=n),y<Math.PI&&(U=!0,w+=n));const L=r*l*(u+n),c=new Float64Array(3*L),K=2*(L+w-(n+u)*l),C=q.IndexDatatype.createTypedArray(L,K);let e,o,V,g,s=0;const _=new Array(u),x=new Array(u);for(e=0;e<u;e++)g=d+e*(y-d)/(u-1),_[e]=z(g),x[e]=T(g);const A=new Array(r),P=new Array(r);for(e=0;e<r;e++)V=h+e*(k-h)/(r-1),A[e]=z(V),P[e]=T(V);for(e=0;e<u;e++)for(o=0;o<r;o++)c[s++]=a.x*_[e]*P[o],c[s++]=a.y*_[e]*A[o],c[s++]=a.z*x[e];if(G)for(e=0;e<u;e++)for(o=0;o<r;o++)c[s++]=t.x*_[e]*P[o],c[s++]=t.y*_[e]*A[o],c[s++]=t.z*x[e];for(_.length=r,x.length=r,e=0;e<r;e++)g=d+e*(y-d)/(r-1),_[e]=z(g),x[e]=T(g);for(A.length=n,P.length=n,e=0;e<n;e++)V=h+e*(k-h)/(n-1),A[e]=z(V),P[e]=T(V);for(e=0;e<r;e++)for(o=0;o<n;o++)c[s++]=a.x*_[e]*P[o],c[s++]=a.y*_[e]*A[o],c[s++]=a.z*x[e];if(G)for(e=0;e<r;e++)for(o=0;o<n;o++)c[s++]=t.x*_[e]*P[o],c[s++]=t.y*_[e]*A[o],c[s++]=t.z*x[e];for(s=0,e=0;e<u*l;e++){const b=e*r;for(o=0;o<r-1;o++)C[s++]=b+o,C[s++]=b+o+1}let E=u*r*l;for(e=0;e<n;e++)for(o=0;o<r-1;o++)C[s++]=E+e+o*n,C[s++]=E+e+(o+1)*n;if(G)for(E=u*r*l+n*r,e=0;e<n;e++)for(o=0;o<r-1;o++)C[s++]=E+e+o*n,C[s++]=E+e+(o+1)*n;if(G){let b=u*r*l,O=b+r*n;if(S)for(e=0;e<n;e++)C[s++]=b+e,C[s++]=O+e;if(U)for(b+=r*n-n,O+=r*n-n,e=0;e<n;e++)C[s++]=b+e,C[s++]=O+e}const W=new J.GeometryAttributes({position:new D.GeometryAttribute({componentDatatype:R.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})});if(f.defined(i._offsetAttribute)){const b=c.length,O=i._offsetAttribute===j.GeometryOffsetAttribute.NONE?0:1,Q=new Uint8Array(b/3).fill(O);W.applyOffset=new D.GeometryAttribute({componentDatatype:R.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:Q})}return new D.Geometry({attributes:W,indices:C,primitiveType:D.PrimitiveType.LINES,boundingSphere:F.BoundingSphere.fromEllipsoid(M),offsetAttribute:i._offsetAttribute})},Y.EllipsoidOutlineGeometry=v});
