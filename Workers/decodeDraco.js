/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./ComponentDatatype-f9ac3ed8","./defaultValue-ebbd2e4d","./IndexDatatype-7ccfd280","./RuntimeError-38a08050","./createTaskProcessorWorker","./WebGLConstants-544672c2","./Math-1fe079f3"],function(G,I,P,p,U,g,_){"use strict";let e;function T(d,i){const t=d.num_points(),f=d.num_faces(),o=new e.DracoInt32Array,u=3*f,r=P.IndexDatatype.createTypedArray(t,u);let y=0;for(let c=0;c<f;++c)i.GetFaceFromMesh(d,c,o),r[y+0]=o.GetValue(0),r[y+1]=o.GetValue(1),r[y+2]=o.GetValue(2),y+=3;return e.destroy(o),{typedArray:r,numberOfIndices:u}}function O(d,i,t){const f=d.num_points(),o=t.num_components();let u,r=new e.AttributeQuantizationTransform;if(r.InitFromAttribute(t)){const s=new Array(o);for(let n=0;n<o;++n)s[n]=r.min_value(n);u={quantizationBits:r.quantization_bits(),minValues:s,range:r.range(),octEncoded:!1}}e.destroy(r),r=new e.AttributeOctahedronTransform,r.InitFromAttribute(t)&&(u={quantizationBits:r.quantization_bits(),octEncoded:!0}),e.destroy(r);const y=f*o;let c;c=I.defined(u)?function(s,n,A,b,l){let a,m;b.quantizationBits<=8?(m=new e.DracoUInt8Array,a=new Uint8Array(l),n.GetAttributeUInt8ForAllPoints(s,A,m)):(m=new e.DracoUInt16Array,a=new Uint16Array(l),n.GetAttributeUInt16ForAllPoints(s,A,m));for(let D=0;D<l;++D)a[D]=m.GetValue(D);return e.destroy(m),a}(d,i,t,u,y):function(s,n,A,b){let l,a;switch(A.data_type()){case 1:case 11:a=new e.DracoInt8Array,l=new Int8Array(b),n.GetAttributeInt8ForAllPoints(s,A,a);break;case 2:a=new e.DracoUInt8Array,l=new Uint8Array(b),n.GetAttributeUInt8ForAllPoints(s,A,a);break;case 3:a=new e.DracoInt16Array,l=new Int16Array(b),n.GetAttributeInt16ForAllPoints(s,A,a);break;case 4:a=new e.DracoUInt16Array,l=new Uint16Array(b),n.GetAttributeUInt16ForAllPoints(s,A,a);break;case 5:case 7:a=new e.DracoInt32Array,l=new Int32Array(b),n.GetAttributeInt32ForAllPoints(s,A,a);break;case 6:case 8:a=new e.DracoUInt32Array,l=new Uint32Array(b),n.GetAttributeUInt32ForAllPoints(s,A,a);break;case 9:case 10:a=new e.DracoFloat32Array,l=new Float32Array(b),n.GetAttributeFloatForAllPoints(s,A,a)}for(let m=0;m<b;++m)l[m]=a.GetValue(m);return e.destroy(a),l}(d,i,t,y);const w=G.ComponentDatatype.fromTypedArray(c);return{array:c,data:{componentsPerAttribute:o,componentDatatype:w,byteOffset:t.byte_offset(),byteStride:G.ComponentDatatype.getSizeInBytes(w)*o,normalized:t.normalized(),quantization:u}}}function F(d){return I.defined(d.bufferView)?function(i){const t=new e.Decoder,f=["POSITION","NORMAL","COLOR","TEX_COORD"];if(i.dequantizeInShader)for(let n=0;n<f.length;++n)t.SkipAttributeTransform(e[f[n]]);const o=i.bufferView,u=new e.DecoderBuffer;if(u.Init(i.array,o.byteLength),t.GetEncodedGeometryType(u)!==e.TRIANGULAR_MESH)throw new p.RuntimeError("Unsupported draco mesh geometry type.");const r=new e.Mesh,y=t.DecodeBufferToMesh(u,r);if(!y.ok()||r.ptr===0)throw new p.RuntimeError(`Error decoding draco mesh geometry: ${y.error_msg()}`);e.destroy(u);const c={},w=i.compressedAttributes;for(const n in w)if(w.hasOwnProperty(n)){const A=w[n],b=t.GetAttributeByUniqueId(r,A);c[n]=O(r,t,b)}const s={indexArray:T(r,t),attributeData:c};return e.destroy(r),e.destroy(t),s}(d):function(i){const t=new e.Decoder;i.dequantizeInShader&&(t.SkipAttributeTransform(e.POSITION),t.SkipAttributeTransform(e.NORMAL));const f=new e.DecoderBuffer;if(f.Init(i.buffer,i.buffer.length),t.GetEncodedGeometryType(f)!==e.POINT_CLOUD)throw new p.RuntimeError("Draco geometry type must be POINT_CLOUD.");const o=new e.PointCloud,u=t.DecodeBufferToPointCloud(f,o);if(!u.ok()||o.ptr===0)throw new p.RuntimeError(`Error decoding draco point cloud: ${u.error_msg()}`);e.destroy(f);const r={},y=i.properties;for(const c in y)if(y.hasOwnProperty(c)){let w;if(c==="POSITION"||c==="NORMAL"){const s=t.GetAttributeId(o,e[c]);w=t.GetAttribute(o,s)}else{const s=y[c];w=t.GetAttributeByUniqueId(o,s)}r[c]=O(o,t,w)}return e.destroy(o),e.destroy(t),r}(d)}function h(d){e=d,self.onmessage=U(F),self.postMessage(!0)}return function(d){const i=d.data.webAssemblyConfig;if(I.defined(i))return require([i.modulePath],function(t){I.defined(i.wasmBinaryFile)?(I.defined(t)||(t=self.DracoDecoderModule),t(i).then(function(f){h(f)})):h(t())})}});
