/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./ArcType-efd92361","./arrayRemoveDuplicates-cadb0e8e","./Matrix2-462b83d3","./Matrix3-2955527a","./ComponentDatatype-f9ac3ed8","./defaultValue-ebbd2e4d","./EllipsoidRhumbLine-8bc8a516","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryPipeline-3cfa9822","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolygonPipeline-4fdc8b4f","./Transforms-5b74e989"],function(J,q,B,M,y,H,b,F,P,X,Z,$,G,S,U){"use strict";function E(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(E.prototype,{length:{get:function(){return this._length}}}),E.prototype.enqueue=function(n){this._array.push(n),this._length++},E.prototype.dequeue=function(){if(this._length===0)return;const n=this._array;let r=this._offset;const s=n[r];return n[r]=void 0,r++,r>10&&2*r>n.length&&(this._array=n.slice(r),r=0),this._offset=r,this._length--,s},E.prototype.peek=function(){if(this._length!==0)return this._array[this._offset]},E.prototype.contains=function(n){return this._array.indexOf(n)!==-1},E.prototype.clear=function(){this._array.length=this._offset=this._length=0},E.prototype.sort=function(n){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(n)};const x={computeHierarchyPackedLength:function(n,r){let s=0;const h=[n];for(;h.length>0;){const c=h.pop();if(!b.defined(c))continue;s+=2;const l=c.positions,e=c.holes;if(b.defined(l)&&l.length>0&&(s+=l.length*r.packedLength),b.defined(e)){const t=e.length;for(let i=0;i<t;++i)h.push(e[i])}}return s},packPolygonHierarchy:function(n,r,s,h){const c=[n];for(;c.length>0;){const l=c.pop();if(!b.defined(l))continue;const e=l.positions,t=l.holes;if(r[s++]=b.defined(e)?e.length:0,r[s++]=b.defined(t)?t.length:0,b.defined(e)){const i=e.length;for(let o=0;o<i;++o,s+=h.packedLength)h.pack(e[o],r,s)}if(b.defined(t)){const i=t.length;for(let o=0;o<i;++o)c.push(t[o])}}return s},unpackPolygonHierarchy:function(n,r,s){const h=n[r++],c=n[r++],l=new Array(h),e=c>0?new Array(c):void 0;for(let t=0;t<h;++t,r+=s.packedLength)l[t]=s.unpack(n,r);for(let t=0;t<c;++t)e[t]=x.unpackPolygonHierarchy(n,r,s),r=e[t].startingIndex,delete e[t].startingIndex;return{positions:l,holes:e,startingIndex:r}}},R=new M.Cartesian2;function Y(n,r,s,h){return M.Cartesian2.subtract(r,n,R),M.Cartesian2.multiplyByScalar(R,s/h,R),M.Cartesian2.add(n,R,R),[R.x,R.y]}const D=new y.Cartesian3;function ee(n,r,s,h){return y.Cartesian3.subtract(r,n,D),y.Cartesian3.multiplyByScalar(D,s/h,D),y.Cartesian3.add(n,D,D),[D.x,D.y,D.z]}x.subdivideLineCount=function(n,r,s){const h=y.Cartesian3.distance(n,r)/s,c=Math.max(0,Math.ceil(G.CesiumMath.log2(h)));return Math.pow(2,c)};const W=new y.Cartographic,V=new y.Cartographic,te=new y.Cartographic,ne=new y.Cartesian3,Q=new F.EllipsoidRhumbLine;x.subdivideRhumbLineCount=function(n,r,s,h){const c=n.cartesianToCartographic(r,W),l=n.cartesianToCartographic(s,V),e=new F.EllipsoidRhumbLine(c,l,n).surfaceDistance/h,t=Math.max(0,Math.ceil(G.CesiumMath.log2(e)));return Math.pow(2,t)},x.subdivideTexcoordLine=function(n,r,s,h,c,l){const e=x.subdivideLineCount(s,h,c),t=M.Cartesian2.distance(n,r),i=t/e,o=l;o.length=2*e;let a=0;for(let f=0;f<e;f++){const d=Y(n,r,f*i,t);o[a++]=d[0],o[a++]=d[1]}return o},x.subdivideLine=function(n,r,s,h){const c=x.subdivideLineCount(n,r,s),l=y.Cartesian3.distance(n,r),e=l/c;b.defined(h)||(h=[]);const t=h;t.length=3*c;let i=0;for(let o=0;o<c;o++){const a=ee(n,r,o*e,l);t[i++]=a[0],t[i++]=a[1],t[i++]=a[2]}return t},x.subdivideTexcoordRhumbLine=function(n,r,s,h,c,l,e){const t=s.cartesianToCartographic(h,W),i=s.cartesianToCartographic(c,V);Q.setEndPoints(t,i);const o=Q.surfaceDistance/l,a=Math.max(0,Math.ceil(G.CesiumMath.log2(o))),f=Math.pow(2,a),d=M.Cartesian2.distance(n,r),p=d/f,g=e;g.length=2*f;let m=0;for(let u=0;u<f;u++){const C=Y(n,r,u*p,d);g[m++]=C[0],g[m++]=C[1]}return g},x.subdivideRhumbLine=function(n,r,s,h,c){const l=n.cartesianToCartographic(r,W),e=n.cartesianToCartographic(s,V),t=new F.EllipsoidRhumbLine(l,e,n),i=t.surfaceDistance/h,o=Math.max(0,Math.ceil(G.CesiumMath.log2(i))),a=Math.pow(2,o),f=t.surfaceDistance/a;b.defined(c)||(c=[]);const d=c;d.length=3*a;let p=0;for(let g=0;g<a;g++){const m=t.interpolateUsingSurfaceDistance(g*f,te),u=n.cartographicToCartesian(m,ne);d[p++]=u.x,d[p++]=u.y,d[p++]=u.z}return d};const ie=new y.Cartesian3,oe=new y.Cartesian3,re=new y.Cartesian3,se=new y.Cartesian3;x.scaleToGeodeticHeightExtruded=function(n,r,s,h,c){h=b.defaultValue(h,y.Ellipsoid.WGS84);const l=ie;let e=oe;const t=re;let i=se;if(b.defined(n)&&b.defined(n.attributes)&&b.defined(n.attributes.position)){const o=n.attributes.position.values,a=o.length/2;for(let f=0;f<a;f+=3)y.Cartesian3.fromArray(o,f,t),h.geodeticSurfaceNormal(t,l),i=h.scaleToGeodeticSurface(t,i),e=y.Cartesian3.multiplyByScalar(l,s,e),e=y.Cartesian3.add(i,e,e),o[f+a]=e.x,o[f+1+a]=e.y,o[f+2+a]=e.z,c&&(i=y.Cartesian3.clone(t,i)),e=y.Cartesian3.multiplyByScalar(l,r,e),e=y.Cartesian3.add(i,e,e),o[f]=e.x,o[f+1]=e.y,o[f+2]=e.z}return n},x.polygonOutlinesFromHierarchy=function(n,r,s){const h=[],c=new E;let l,e,t;for(c.enqueue(n);c.length!==0;){const i=c.dequeue();let o=i.positions;if(r)for(t=o.length,l=0;l<t;l++)s.scaleToGeodeticSurface(o[l],o[l]);if(o=B.arrayRemoveDuplicates(o,y.Cartesian3.equalsEpsilon,!0),o.length<3)continue;const a=i.holes?i.holes.length:0;for(l=0;l<a;l++){const f=i.holes[l];let d=f.positions;if(r)for(t=d.length,e=0;e<t;++e)s.scaleToGeodeticSurface(d[e],d[e]);if(d=B.arrayRemoveDuplicates(d,y.Cartesian3.equalsEpsilon,!0),d.length<3)continue;h.push(d);let p=0;for(b.defined(f.holes)&&(p=f.holes.length),e=0;e<p;e++)c.enqueue(f.holes[e])}h.push(o)}return h},x.polygonsFromHierarchy=function(n,r,s,h,c){const l=[],e=[],t=new E;for(t.enqueue(n);t.length!==0;){const i=t.dequeue();let o=i.positions;const a=i.holes;let f,d;if(h)for(d=o.length,f=0;f<d;f++)c.scaleToGeodeticSurface(o[f],o[f]);if(r||(o=B.arrayRemoveDuplicates(o,y.Cartesian3.equalsEpsilon,!0)),o.length<3)continue;let p=s(o);if(!b.defined(p))continue;const g=[];let m=S.PolygonPipeline.computeWindingOrder2D(p);m===S.WindingOrder.CLOCKWISE&&(p.reverse(),o=o.slice().reverse());let u=o.slice();const C=b.defined(a)?a.length:0,A=[];let v;for(f=0;f<C;f++){const L=a[f];let T=L.positions;if(h)for(d=T.length,v=0;v<d;++v)c.scaleToGeodeticSurface(T[v],T[v]);if(r||(T=B.arrayRemoveDuplicates(T,y.Cartesian3.equalsEpsilon,!0)),T.length<3)continue;const N=s(T);if(!b.defined(N))continue;m=S.PolygonPipeline.computeWindingOrder2D(N),m===S.WindingOrder.CLOCKWISE&&(N.reverse(),T=T.slice().reverse()),A.push(T),g.push(u.length),u=u.concat(T),p=p.concat(N);let w=0;for(b.defined(L.holes)&&(w=L.holes.length),v=0;v<w;v++)t.enqueue(L.holes[v])}l.push({outerRing:o,holes:A}),e.push({positions:u,positions2D:p,holes:g})}return{hierarchy:l,polygons:e}};const ae=new M.Cartesian2,ce=new y.Cartesian3,le=new U.Quaternion,ue=new y.Matrix3;x.computeBoundingRectangle=function(n,r,s,h,c){const l=U.Quaternion.fromAxisAngle(n,h,le),e=y.Matrix3.fromQuaternion(l,ue);let t=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,o=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;const f=s.length;for(let d=0;d<f;++d){const p=y.Cartesian3.clone(s[d],ce);y.Matrix3.multiplyByVector(e,p,p);const g=r(p,ae);b.defined(g)&&(t=Math.min(t,g.x),i=Math.max(i,g.x),o=Math.min(o,g.y),a=Math.max(a,g.y))}return c.x=t,c.y=o,c.width=i-t,c.height=a-o,c},x.createGeometryFromPositions=function(n,r,s,h,c,l,e){let t=S.PolygonPipeline.triangulate(r.positions2D,r.holes);t.length<3&&(t=[0,1,2]);const i=r.positions,o=b.defined(s),a=o?s.positions:void 0;if(c){const f=i.length,d=new Array(3*f);let p=0;for(let u=0;u<f;u++){const C=i[u];d[p++]=C.x,d[p++]=C.y,d[p++]=C.z}const g={attributes:{position:new P.GeometryAttribute({componentDatatype:H.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:d})},indices:t,primitiveType:P.PrimitiveType.TRIANGLES};o&&(g.attributes.st=new P.GeometryAttribute({componentDatatype:H.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:M.Cartesian2.packArray(a)}));const m=new P.Geometry(g);return l.normal?Z.GeometryPipeline.computeNormal(m):m}return e===q.ArcType.GEODESIC?S.PolygonPipeline.computeSubdivision(n,i,t,a,h):e===q.ArcType.RHUMB?S.PolygonPipeline.computeRhumbLineSubdivision(n,i,t,a,h):void 0};const K=[],j=[],he=new y.Cartesian3,fe=new y.Cartesian3;x.computeWallGeometry=function(n,r,s,h,c,l){let e,t,i,o,a,f,d,p,g,m=n.length,u=0,C=0;const A=b.defined(r),v=A?r.positions:void 0;if(c)for(t=3*m*2,e=new Array(2*t),A&&(g=2*m*2,p=new Array(2*g)),i=0;i<m;i++)o=n[i],a=n[(i+1)%m],e[u]=e[u+t]=o.x,++u,e[u]=e[u+t]=o.y,++u,e[u]=e[u+t]=o.z,++u,e[u]=e[u+t]=a.x,++u,e[u]=e[u+t]=a.y,++u,e[u]=e[u+t]=a.z,++u,A&&(f=v[i],d=v[(i+1)%m],p[C]=p[C+g]=f.x,++C,p[C]=p[C+g]=f.y,++C,p[C]=p[C+g]=d.x,++C,p[C]=p[C+g]=d.y,++C);else{const w=G.CesiumMath.chordLength(h,s.maximumRadius);let _=0;if(l===q.ArcType.GEODESIC)for(i=0;i<m;i++)_+=x.subdivideLineCount(n[i],n[(i+1)%m],w);else if(l===q.ArcType.RHUMB)for(i=0;i<m;i++)_+=x.subdivideRhumbLineCount(s,n[i],n[(i+1)%m],w);for(t=3*(_+m),e=new Array(2*t),A&&(g=2*(_+m),p=new Array(2*g)),i=0;i<m;i++){let I,O;o=n[i],a=n[(i+1)%m],A&&(f=v[i],d=v[(i+1)%m]),l===q.ArcType.GEODESIC?(I=x.subdivideLine(o,a,w,j),A&&(O=x.subdivideTexcoordLine(f,d,o,a,w,K))):l===q.ArcType.RHUMB&&(I=x.subdivideRhumbLine(s,o,a,w,j),A&&(O=x.subdivideTexcoordRhumbLine(f,d,s,o,a,w,K)));const pe=I.length;for(let k=0;k<pe;++k,++u)e[u]=I[k],e[u+t]=I[k];if(e[u]=a.x,e[u+t]=a.x,++u,e[u]=a.y,e[u+t]=a.y,++u,e[u]=a.z,e[u+t]=a.z,++u,A){const k=O.length;for(let z=0;z<k;++z,++C)p[C]=O[z],p[C+g]=O[z];p[C]=d.x,p[C+g]=d.x,++C,p[C]=d.y,p[C+g]=d.y,++C}}}m=e.length;const L=$.IndexDatatype.createTypedArray(m/3,m-6*n.length);let T=0;for(m/=6,i=0;i<m;i++){const w=i,_=w+1,I=w+m,O=I+1;o=y.Cartesian3.fromArray(e,3*w,he),a=y.Cartesian3.fromArray(e,3*_,fe),y.Cartesian3.equalsEpsilon(o,a,G.CesiumMath.EPSILON10,G.CesiumMath.EPSILON10)||(L[T++]=w,L[T++]=I,L[T++]=_,L[T++]=_,L[T++]=I,L[T++]=O)}const N={attributes:new X.GeometryAttributes({position:new P.GeometryAttribute({componentDatatype:H.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e})}),indices:L,primitiveType:P.PrimitiveType.TRIANGLES};return A&&(N.attributes.st=new P.GeometryAttribute({componentDatatype:H.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:p})),new P.Geometry(N)};var de=x;J.PolygonGeometryLibrary=de});
