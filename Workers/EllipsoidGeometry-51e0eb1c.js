/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Transforms-5b74e989","./Matrix2-462b83d3","./Matrix3-2955527a","./ComponentDatatype-f9ac3ed8","./defaultValue-ebbd2e4d","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryOffsetAttribute-739bec2c","./IndexDatatype-7ccfd280","./Math-1fe079f3","./VertexFormat-5b02b45a"],function(pt,yt,_t,m,D,c,g,ht,xt,At,G,h){"use strict";const bt=new m.Cartesian3,kt=new m.Cartesian3,wt=new m.Cartesian3,Pt=new m.Cartesian3,gt=new m.Cartesian3,vt=new m.Cartesian3(1,1,1),at=Math.cos,it=Math.sin;function A(a){a=c.defaultValue(a,c.defaultValue.EMPTY_OBJECT);const o=c.defaultValue(a.radii,vt),n=c.defaultValue(a.innerRadii,o),b=c.defaultValue(a.minimumClock,0),F=c.defaultValue(a.maximumClock,G.CesiumMath.TWO_PI),k=c.defaultValue(a.minimumCone,0),w=c.defaultValue(a.maximumCone,G.CesiumMath.PI),u=Math.round(c.defaultValue(a.stackPartitions,64)),t=Math.round(c.defaultValue(a.slicePartitions,64)),i=c.defaultValue(a.vertexFormat,h.VertexFormat.DEFAULT);this._radii=m.Cartesian3.clone(o),this._innerRadii=m.Cartesian3.clone(n),this._minimumClock=b,this._maximumClock=F,this._minimumCone=k,this._maximumCone=w,this._stackPartitions=u,this._slicePartitions=t,this._vertexFormat=h.VertexFormat.clone(i),this._offsetAttribute=a.offsetAttribute,this._workerName="createEllipsoidGeometry"}A.packedLength=2*m.Cartesian3.packedLength+h.VertexFormat.packedLength+7,A.pack=function(a,o,n){return n=c.defaultValue(n,0),m.Cartesian3.pack(a._radii,o,n),n+=m.Cartesian3.packedLength,m.Cartesian3.pack(a._innerRadii,o,n),n+=m.Cartesian3.packedLength,h.VertexFormat.pack(a._vertexFormat,o,n),n+=h.VertexFormat.packedLength,o[n++]=a._minimumClock,o[n++]=a._maximumClock,o[n++]=a._minimumCone,o[n++]=a._maximumCone,o[n++]=a._stackPartitions,o[n++]=a._slicePartitions,o[n]=c.defaultValue(a._offsetAttribute,-1),o};const nt=new m.Cartesian3,ot=new m.Cartesian3,rt=new h.VertexFormat,v={radii:nt,innerRadii:ot,vertexFormat:rt,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let Y;A.unpack=function(a,o,n){o=c.defaultValue(o,0);const b=m.Cartesian3.unpack(a,o,nt);o+=m.Cartesian3.packedLength;const F=m.Cartesian3.unpack(a,o,ot);o+=m.Cartesian3.packedLength;const k=h.VertexFormat.unpack(a,o,rt);o+=h.VertexFormat.packedLength;const w=a[o++],u=a[o++],t=a[o++],i=a[o++],d=a[o++],C=a[o++],e=a[o];return c.defined(n)?(n._radii=m.Cartesian3.clone(b,n._radii),n._innerRadii=m.Cartesian3.clone(F,n._innerRadii),n._vertexFormat=h.VertexFormat.clone(k,n._vertexFormat),n._minimumClock=w,n._maximumClock=u,n._minimumCone=t,n._maximumCone=i,n._stackPartitions=d,n._slicePartitions=C,n._offsetAttribute=e===-1?void 0:e,n):(v.minimumClock=w,v.maximumClock=u,v.minimumCone=t,v.maximumCone=i,v.stackPartitions=d,v.slicePartitions=C,v.offsetAttribute=e===-1?void 0:e,new A(v))},A.createGeometry=function(a){const o=a._radii;if(o.x<=0||o.y<=0||o.z<=0)return;const n=a._innerRadii;if(n.x<=0||n.y<=0||n.z<=0)return;const b=a._minimumClock,F=a._maximumClock,k=a._minimumCone,w=a._maximumCone,u=a._vertexFormat;let t,i,d=a._slicePartitions+1,C=a._stackPartitions+1;d=Math.round(d*Math.abs(F-b)/G.CesiumMath.TWO_PI),C=Math.round(C*Math.abs(w-k)/G.CesiumMath.PI),d<2&&(d=2),C<2&&(C=2);let e=0;const O=[k],I=[b];for(t=0;t<C;t++)O.push(k+t*(w-k)/(C-1));for(O.push(w),i=0;i<d;i++)I.push(b+i*(F-b)/(d-1));I.push(F);const l=O.length,s=I.length;let E=0,z=1;const U=n.x!==o.x||n.y!==o.y||n.z!==o.z;let J=!1,st=!1,mt=!1;U&&(z=2,k>0&&(J=!0,E+=d-1),w<Math.PI&&(st=!0,E+=d-1),(F-b)%G.CesiumMath.TWO_PI?(mt=!0,E+=2*(C-1)+1):E+=1);const x=s*l*z,P=new Float64Array(3*x),X=new Array(x).fill(!1),ut=new Array(x).fill(!1),ct=d*C*z,Ft=6*(ct+E+1-(d+C)*z),r=At.IndexDatatype.createTypedArray(ct,Ft),S=u.normal?new Float32Array(3*x):void 0,B=u.tangent?new Float32Array(3*x):void 0,W=u.bitangent?new Float32Array(3*x):void 0,Z=u.st?new Float32Array(2*x):void 0,N=new Array(l),j=new Array(l);for(t=0;t<l;t++)N[t]=it(O[t]),j[t]=at(O[t]);const q=new Array(s),H=new Array(s);for(i=0;i<s;i++)H[i]=at(I[i]),q[i]=it(I[i]);for(t=0;t<l;t++)for(i=0;i<s;i++)P[e++]=o.x*N[t]*H[i],P[e++]=o.y*N[t]*q[i],P[e++]=o.z*j[t];let V,M,p,f,K=x/2;if(U)for(t=0;t<l;t++)for(i=0;i<s;i++)P[e++]=n.x*N[t]*H[i],P[e++]=n.y*N[t]*q[i],P[e++]=n.z*j[t],X[K]=!0,t>0&&t!==l-1&&i!==0&&i!==s-1&&(ut[K]=!0),K++;for(e=0,t=1;t<l-2;t++)for(V=t*s,M=(t+1)*s,i=1;i<s-2;i++)r[e++]=M+i,r[e++]=M+i+1,r[e++]=V+i+1,r[e++]=M+i,r[e++]=V+i+1,r[e++]=V+i;if(U){const L=l*s;for(t=1;t<l-2;t++)for(V=L+t*s,M=L+(t+1)*s,i=1;i<s-2;i++)r[e++]=M+i,r[e++]=V+i,r[e++]=V+i+1,r[e++]=M+i,r[e++]=V+i+1,r[e++]=M+i+1}if(U){if(J)for(f=l*s,t=1;t<s-2;t++)r[e++]=t,r[e++]=t+1,r[e++]=f+t+1,r[e++]=t,r[e++]=f+t+1,r[e++]=f+t;if(st)for(p=l*s-s,f=l*s*z-s,t=1;t<s-2;t++)r[e++]=p+t+1,r[e++]=p+t,r[e++]=f+t,r[e++]=p+t+1,r[e++]=f+t,r[e++]=f+t+1}if(mt){for(t=1;t<l-2;t++)f=s*l+s*t,p=s*t,r[e++]=f,r[e++]=p+s,r[e++]=p,r[e++]=f,r[e++]=f+s,r[e++]=p+s;for(t=1;t<l-2;t++)f=s*l+s*(t+1)-1,p=s*(t+1)-1,r[e++]=p+s,r[e++]=f,r[e++]=p,r[e++]=p+s,r[e++]=f+s,r[e++]=f}const T=new ht.GeometryAttributes;u.position&&(T.position=new g.GeometryAttribute({componentDatatype:D.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:P}));let lt=0,Q=0,$=0,tt=0;const Vt=x/2;let ft;const dt=m.Ellipsoid.fromCartesian3(o),Mt=m.Ellipsoid.fromCartesian3(n);if(u.st||u.normal||u.tangent||u.bitangent){for(t=0;t<x;t++){ft=X[t]?Mt:dt;const L=m.Cartesian3.fromArray(P,3*t,bt),_=ft.geodeticSurfaceNormal(L,kt);if(ut[t]&&m.Cartesian3.negate(_,_),u.st){const y=_t.Cartesian2.negate(_,gt);Z[lt++]=Math.atan2(y.y,y.x)/G.CesiumMath.TWO_PI+.5,Z[lt++]=Math.asin(_.z)/Math.PI+.5}if(u.normal&&(S[Q++]=_.x,S[Q++]=_.y,S[Q++]=_.z),u.tangent||u.bitangent){const y=wt;let Ct,et=0;if(X[t]&&(et=Vt),Ct=!J&&t>=et&&t<et+2*s?m.Cartesian3.UNIT_X:m.Cartesian3.UNIT_Z,m.Cartesian3.cross(Ct,_,y),m.Cartesian3.normalize(y,y),u.tangent&&(B[$++]=y.x,B[$++]=y.y,B[$++]=y.z),u.bitangent){const R=m.Cartesian3.cross(_,y,Pt);m.Cartesian3.normalize(R,R),W[tt++]=R.x,W[tt++]=R.y,W[tt++]=R.z}}}u.st&&(T.st=new g.GeometryAttribute({componentDatatype:D.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:Z})),u.normal&&(T.normal=new g.GeometryAttribute({componentDatatype:D.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:S})),u.tangent&&(T.tangent=new g.GeometryAttribute({componentDatatype:D.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:B})),u.bitangent&&(T.bitangent=new g.GeometryAttribute({componentDatatype:D.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:W}))}if(c.defined(a._offsetAttribute)){const L=P.length,_=a._offsetAttribute===xt.GeometryOffsetAttribute.NONE?0:1,y=new Uint8Array(L/3).fill(_);T.applyOffset=new g.GeometryAttribute({componentDatatype:D.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:y})}return new g.Geometry({attributes:T,indices:r,primitiveType:g.PrimitiveType.TRIANGLES,boundingSphere:yt.BoundingSphere.fromEllipsoid(dt),offsetAttribute:a._offsetAttribute})},A.getUnitEllipsoid=function(){return c.defined(Y)||(Y=A.createGeometry(new A({radii:new m.Cartesian3(1,1,1),vertexFormat:h.VertexFormat.POSITION_ONLY}))),Y},pt.EllipsoidGeometry=A});
