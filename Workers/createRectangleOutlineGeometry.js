/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./defaultValue-ebbd2e4d","./Matrix3-2955527a","./Matrix2-462b83d3","./Transforms-5b74e989","./ComponentDatatype-f9ac3ed8","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryOffsetAttribute-739bec2c","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolygonPipeline-4fdc8b4f","./RectangleGeometryLibrary-a4beb9d0","./RuntimeError-38a08050","./combine-55e9f355","./WebGLConstants-544672c2","./EllipsoidRhumbLine-8bc8a516"],function(c,h,A,C,T,P,J,k,B,L,M,D,te,ie,oe,ne){"use strict";const j=new C.BoundingSphere,K=new C.BoundingSphere,Q=new h.Cartesian3,X=new A.Rectangle;function U(e,t){const i=e._ellipsoid,m=t.height,l=t.width,y=t.northCap,f=t.southCap;let G=m,_=2,g=0,w=4;y&&(_-=1,G-=1,g+=1,w-=2),f&&(_-=1,G-=1,g+=1,w-=2),g+=_*l+2*G-w;const o=new Float64Array(3*g);let n,a=0,d=0;const r=Q;if(y)D.RectangleGeometryLibrary.computePosition(t,i,!1,d,0,r),o[a++]=r.x,o[a++]=r.y,o[a++]=r.z;else for(n=0;n<l;n++)D.RectangleGeometryLibrary.computePosition(t,i,!1,d,n,r),o[a++]=r.x,o[a++]=r.y,o[a++]=r.z;for(n=l-1,d=1;d<m;d++)D.RectangleGeometryLibrary.computePosition(t,i,!1,d,n,r),o[a++]=r.x,o[a++]=r.y,o[a++]=r.z;if(d=m-1,!f)for(n=l-2;n>=0;n--)D.RectangleGeometryLibrary.computePosition(t,i,!1,d,n,r),o[a++]=r.x,o[a++]=r.y,o[a++]=r.z;for(n=0,d=m-2;d>0;d--)D.RectangleGeometryLibrary.computePosition(t,i,!1,d,n,r),o[a++]=r.x,o[a++]=r.y,o[a++]=r.z;const I=o.length/3*2,x=B.IndexDatatype.createTypedArray(o.length/3,I);let E=0;for(let R=0;R<o.length/3-1;R++)x[E++]=R,x[E++]=R+1;x[E++]=o.length/3-1,x[E++]=0;const S=new P.Geometry({attributes:new J.GeometryAttributes,primitiveType:P.PrimitiveType.LINES});return S.attributes.position=new P.GeometryAttribute({componentDatatype:T.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:o}),S.indices=x,S}function v(e){const t=(e=c.defaultValue(e,c.defaultValue.EMPTY_OBJECT)).rectangle,i=c.defaultValue(e.granularity,L.CesiumMath.RADIANS_PER_DEGREE),m=c.defaultValue(e.ellipsoid,h.Ellipsoid.WGS84),l=c.defaultValue(e.rotation,0),y=c.defaultValue(e.height,0),f=c.defaultValue(e.extrudedHeight,y);this._rectangle=A.Rectangle.clone(t),this._granularity=i,this._ellipsoid=m,this._surfaceHeight=Math.max(y,f),this._rotation=l,this._extrudedHeight=Math.min(y,f),this._offsetAttribute=e.offsetAttribute,this._workerName="createRectangleOutlineGeometry"}v.packedLength=A.Rectangle.packedLength+h.Ellipsoid.packedLength+5,v.pack=function(e,t,i){return i=c.defaultValue(i,0),A.Rectangle.pack(e._rectangle,t,i),i+=A.Rectangle.packedLength,h.Ellipsoid.pack(e._ellipsoid,t,i),i+=h.Ellipsoid.packedLength,t[i++]=e._granularity,t[i++]=e._surfaceHeight,t[i++]=e._rotation,t[i++]=e._extrudedHeight,t[i]=c.defaultValue(e._offsetAttribute,-1),t};const z=new A.Rectangle,q=h.Ellipsoid.clone(h.Ellipsoid.UNIT_SPHERE),H={rectangle:z,ellipsoid:q,granularity:void 0,height:void 0,rotation:void 0,extrudedHeight:void 0,offsetAttribute:void 0};v.unpack=function(e,t,i){t=c.defaultValue(t,0);const m=A.Rectangle.unpack(e,t,z);t+=A.Rectangle.packedLength;const l=h.Ellipsoid.unpack(e,t,q);t+=h.Ellipsoid.packedLength;const y=e[t++],f=e[t++],G=e[t++],_=e[t++],g=e[t];return c.defined(i)?(i._rectangle=A.Rectangle.clone(m,i._rectangle),i._ellipsoid=h.Ellipsoid.clone(l,i._ellipsoid),i._surfaceHeight=f,i._rotation=G,i._extrudedHeight=_,i._offsetAttribute=g===-1?void 0:g,i):(H.granularity=y,H.height=f,H.rotation=G,H.extrudedHeight=_,H.offsetAttribute=g===-1?void 0:g,new v(H))};const Z=new h.Cartographic;return v.createGeometry=function(e){const t=e._rectangle,i=e._ellipsoid,m=D.RectangleGeometryLibrary.computeOptions(t,e._granularity,e._rotation,0,X,Z);let l,y;if(L.CesiumMath.equalsEpsilon(t.north,t.south,L.CesiumMath.EPSILON10)||L.CesiumMath.equalsEpsilon(t.east,t.west,L.CesiumMath.EPSILON10))return;const f=e._surfaceHeight,G=e._extrudedHeight;let _;if(L.CesiumMath.equalsEpsilon(f,G,0,L.CesiumMath.EPSILON2)){if(l=U(e,m),l.attributes.position.values=M.PolygonPipeline.scaleToGeodeticHeight(l.attributes.position.values,f,i,!1),c.defined(e._offsetAttribute)){const g=l.attributes.position.values.length;_=e._offsetAttribute===k.GeometryOffsetAttribute.NONE?0:1;const w=new Uint8Array(g/3).fill(_);l.attributes.applyOffset=new P.GeometryAttribute({componentDatatype:T.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:w})}y=C.BoundingSphere.fromRectangle3D(t,i,f)}else{if(l=function(o,n){const a=o._surfaceHeight,d=o._extrudedHeight,r=o._ellipsoid,I=d,x=a,E=U(o,n),S=n.height,R=n.width,Y=M.PolygonPipeline.scaleToGeodeticHeight(E.attributes.position.values,x,r,!1);let p=Y.length;const N=new Float64Array(2*p);N.set(Y);const $=M.PolygonPipeline.scaleToGeodeticHeight(E.attributes.position.values,I,r);N.set($,p),E.attributes.position.values=N;const F=n.northCap,W=n.southCap;let V=4;F&&(V-=1),W&&(V-=1);const ee=2*(N.length/3+V),s=B.IndexDatatype.createTypedArray(N.length/3,ee);p=N.length/6;let O,u=0;for(let b=0;b<p-1;b++)s[u++]=b,s[u++]=b+1,s[u++]=b+p,s[u++]=b+p+1;if(s[u++]=p-1,s[u++]=0,s[u++]=p+p-1,s[u++]=p,s[u++]=0,s[u++]=p,F)O=S-1;else{const b=R-1;s[u++]=b,s[u++]=b+p,O=R+S-2}if(s[u++]=O,s[u++]=O+p,!W){const b=R+O-1;s[u++]=b,s[u]=b+p}return E.indices=s,E}(e,m),c.defined(e._offsetAttribute)){const o=l.attributes.position.values.length/3;let n=new Uint8Array(o);e._offsetAttribute===k.GeometryOffsetAttribute.TOP?n=n.fill(1,0,o/2):(_=e._offsetAttribute===k.GeometryOffsetAttribute.NONE?0:1,n=n.fill(_)),l.attributes.applyOffset=new P.GeometryAttribute({componentDatatype:T.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}const g=C.BoundingSphere.fromRectangle3D(t,i,f,K),w=C.BoundingSphere.fromRectangle3D(t,i,G,j);y=C.BoundingSphere.union(g,w)}return new P.Geometry({attributes:l.attributes,indices:l.indices,primitiveType:P.PrimitiveType.LINES,boundingSphere:y,offsetAttribute:e._offsetAttribute})},function(e,t){return c.defined(t)&&(e=v.unpack(e,t)),e._ellipsoid=h.Ellipsoid.clone(e._ellipsoid),e._rectangle=A.Rectangle.clone(e._rectangle),v.createGeometry(e)}});
