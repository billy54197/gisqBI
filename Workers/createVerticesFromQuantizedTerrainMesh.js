/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./AxisAlignedBoundingBox-a26a3fb6","./Matrix2-462b83d3","./Matrix3-2955527a","./defaultValue-ebbd2e4d","./TerrainEncoding-519593e1","./IndexDatatype-7ccfd280","./Math-1fe079f3","./Transforms-5b74e989","./WebMercatorProjection-3d5b0545","./createTaskProcessorWorker","./RuntimeError-38a08050","./AttributeCompression-6f93ad0c","./ComponentDatatype-f9ac3ed8","./WebGLConstants-544672c2","./combine-55e9f355"],function(be,H,h,A,he,ue,N,Ae,j,Ce,Ye,Oe,Be,Re,Le){"use strict";function T(){h.DeveloperError.throwInstantiationError()}Object.defineProperties(T.prototype,{errorEvent:{get:h.DeveloperError.throwInstantiationError},credit:{get:h.DeveloperError.throwInstantiationError},tilingScheme:{get:h.DeveloperError.throwInstantiationError},ready:{get:h.DeveloperError.throwInstantiationError},readyPromise:{get:h.DeveloperError.throwInstantiationError},hasWaterMask:{get:h.DeveloperError.throwInstantiationError},hasVertexNormals:{get:h.DeveloperError.throwInstantiationError},availability:{get:h.DeveloperError.throwInstantiationError}});const le=[];T.getRegularGridIndices=function(e,o){let t=le[e];A.defined(t)||(le[e]=t=[]);let r=t[o];return A.defined(r)||(r=e*o<N.CesiumMath.SIXTY_FOUR_KILOBYTES?t[o]=new Uint16Array((e-1)*(o-1)*6):t[o]=new Uint32Array((e-1)*(o-1)*6),me(e,o,r,0)),r};const de=[];T.getRegularGridIndicesAndEdgeIndices=function(e,o){let t=de[e];A.defined(t)||(de[e]=t=[]);let r=t[o];if(!A.defined(r)){const i=T.getRegularGridIndices(e,o),s=ge(e,o),n=s.westIndicesSouthToNorth,a=s.southIndicesEastToWest,m=s.eastIndicesNorthToSouth,I=s.northIndicesWestToEast;r=t[o]={indices:i,westIndicesSouthToNorth:n,southIndicesEastToWest:a,eastIndicesNorthToSouth:m,northIndicesWestToEast:I}}return r};const Ie=[];function ge(e,o){const t=new Array(o),r=new Array(e),i=new Array(o),s=new Array(e);let n;for(n=0;n<e;++n)s[n]=n,r[n]=e*o-1-n;for(n=0;n<o;++n)i[n]=(n+1)*e-1,t[n]=(o-n-1)*e;return{westIndicesSouthToNorth:t,southIndicesEastToWest:r,eastIndicesNorthToSouth:i,northIndicesWestToEast:s}}function me(e,o,t,r){let i=0;for(let s=0;s<o-1;++s){for(let n=0;n<e-1;++n){const a=i,m=a+e,I=m+1,u=a+1;t[r++]=a,t[r++]=m,t[r++]=u,t[r++]=u,t[r++]=m,t[r++]=I,++i}++i}}function U(e,o,t,r){let i=e[0];const s=e.length;for(let n=1;n<s;++n){const a=e[n];t[r++]=i,t[r++]=a,t[r++]=o,t[r++]=o,t[r++]=a,t[r++]=o+1,i=a,++o}return r}T.getRegularGridAndSkirtIndicesAndEdgeIndices=function(e,o){let t=Ie[e];A.defined(t)||(Ie[e]=t=[]);let r=t[o];if(!A.defined(r)){const i=e*o,s=(e-1)*(o-1)*6,n=2*e+2*o,a=i+n,m=s+6*Math.max(0,n-4),I=ge(e,o),u=I.westIndicesSouthToNorth,k=I.southIndicesEastToWest,E=I.eastIndicesNorthToSouth,C=I.northIndicesWestToEast,w=ue.IndexDatatype.createTypedArray(a,m);me(e,o,w,0),T.addSkirtIndices(u,k,E,C,i,w,s),r=t[o]={indices:w,westIndicesSouthToNorth:u,southIndicesEastToWest:k,eastIndicesNorthToSouth:E,northIndicesWestToEast:C,indexCountWithoutSkirts:s}}return r},T.addSkirtIndices=function(e,o,t,r,i,s,n){let a=i;n=U(e,a,s,n),a+=e.length,n=U(o,a,s,n),a+=o.length,n=U(t,a,s,n),a+=t.length,U(r,a,s,n)},T.heightmapTerrainQuality=.25,T.getEstimatedLevelZeroGeometricErrorForAHeightmap=function(e,o,t){return 2*e.maximumRadius*Math.PI*T.heightmapTerrainQuality/(o*t)},T.prototype.requestTileGeometry=h.DeveloperError.throwInstantiationError,T.prototype.getLevelMaximumGeometricError=h.DeveloperError.throwInstantiationError,T.prototype.getTileDataAvailable=h.DeveloperError.throwInstantiationError,T.prototype.loadTileDataAvailability=h.DeveloperError.throwInstantiationError;const J=32767,B=new h.Cartesian3,We=new h.Cartesian3,ve=new h.Cartesian3,d=new h.Cartographic,O=new H.Cartesian2;function z(e,o,t,r,i,s,n,a,m){let I=Number.POSITIVE_INFINITY;const u=i.north,k=i.south;let E=i.east;const C=i.west;E<C&&(E+=N.CesiumMath.TWO_PI);const w=e.length;for(let g=0;g<w;++g){const M=e[g],W=t[M],p=r[M];d.longitude=N.CesiumMath.lerp(C,E,p.x),d.latitude=N.CesiumMath.lerp(k,u,p.y),d.height=W-o;const v=s.cartographicToCartesian(d,B);H.Matrix4.multiplyByPoint(n,v,v),h.Cartesian3.minimumByComponent(v,a,a),h.Cartesian3.maximumByComponent(v,m,m),I=Math.min(I,d.height)}return I}function q(e,o,t,r,i,s,n,a,m,I,u,k,E,C){const w=A.defined(n),g=m.north,M=m.south;let W=m.east;const p=m.west;W<p&&(W+=N.CesiumMath.TWO_PI);const v=t.length;for(let P=0;P<v;++P){const y=t[P],F=i[y],R=s[y];d.longitude=N.CesiumMath.lerp(p,W,R.x)+E,d.latitude=N.CesiumMath.lerp(M,g,R.y)+C,d.height=F-I;const K=a.cartographicToCartesian(d,B);if(w){const l=2*y;O.x=n[l],O.y=n[l+1]}let X,L;r.hasWebMercatorT&&(X=(j.WebMercatorProjection.geodeticLatitudeToMercatorAngle(d.latitude)-u)*k),r.hasGeodeticSurfaceNormals&&(L=a.geodeticSurfaceNormal(K)),o=r.encode(e,o,K,R,d.height,O,X,L)}}function Q(e,o){let t;return typeof e.slice=="function"&&(t=e.slice(),typeof t.sort!="function"&&(t=void 0)),A.defined(t)||(t=Array.prototype.slice.call(e)),t.sort(o),t}return Ce(function(e,o){const t=e.quantizedVertices,r=t.length/3,i=e.octEncodedNormals,s=e.westIndices.length+e.eastIndices.length+e.southIndices.length+e.northIndices.length,n=e.includeWebMercatorT,a=e.exaggeration,m=e.exaggerationRelativeHeight,I=a!==1,u=H.Rectangle.clone(e.rectangle),k=u.west,E=u.south,C=u.east,w=u.north,g=h.Ellipsoid.clone(e.ellipsoid),M=e.minimumHeight,W=e.maximumHeight,p=e.relativeToCenter,v=Ae.Transforms.eastNorthUpToFixedFrame(p,g),P=H.Matrix4.inverseTransformation(v,new H.Matrix4);let y,F;n&&(y=j.WebMercatorProjection.geodeticLatitudeToMercatorAngle(E),F=1/(j.WebMercatorProjection.geodeticLatitudeToMercatorAngle(w)-y));const R=t.subarray(0,r),K=t.subarray(r,2*r),X=t.subarray(2*r,3*r),L=A.defined(i),l=new Array(r),S=new Array(r),$=new Array(r),Te=n?new Array(r):[],fe=I?new Array(r):[],x=We;x.x=Number.POSITIVE_INFINITY,x.y=Number.POSITIVE_INFINITY,x.z=Number.POSITIVE_INFINITY;const b=ve;b.x=Number.NEGATIVE_INFINITY,b.y=Number.NEGATIVE_INFINITY,b.z=Number.NEGATIVE_INFINITY;let ee=Number.POSITIVE_INFINITY,te=Number.NEGATIVE_INFINITY,re=Number.POSITIVE_INFINITY,oe=Number.NEGATIVE_INFINITY;for(let c=0;c<r;++c){const f=R[c],Ve=K[c],Me=f/J,Se=Ve/J,xe=N.CesiumMath.lerp(M,W,X[c]/J);d.longitude=N.CesiumMath.lerp(k,C,Me),d.latitude=N.CesiumMath.lerp(E,w,Se),d.height=xe,ee=Math.min(d.longitude,ee),te=Math.max(d.longitude,te),re=Math.min(d.latitude,re),oe=Math.max(d.latitude,oe);const ce=g.cartographicToCartesian(d);l[c]=new H.Cartesian2(Me,Se),S[c]=xe,$[c]=ce,n&&(Te[c]=(j.WebMercatorProjection.geodeticLatitudeToMercatorAngle(d.latitude)-y)*F),I&&(fe[c]=g.geodeticSurfaceNormal(ce)),H.Matrix4.multiplyByPoint(P,ce,B),h.Cartesian3.minimumByComponent(B,x,x),h.Cartesian3.maximumByComponent(B,b,b)}const ne=Q(e.westIndices,function(c,f){return l[c].y-l[f].y}),ie=Q(e.eastIndices,function(c,f){return l[f].y-l[c].y}),se=Q(e.southIndices,function(c,f){return l[f].x-l[c].x}),ae=Q(e.northIndices,function(c,f){return l[c].x-l[f].x});let Ee;M<0&&(Ee=new he.EllipsoidalOccluder(g).computeHorizonCullingPointPossiblyUnderEllipsoid(p,$,M));let D=M;D=Math.min(D,z(e.westIndices,e.westSkirtHeight,S,l,u,g,P,x,b)),D=Math.min(D,z(e.southIndices,e.southSkirtHeight,S,l,u,g,P,x,b)),D=Math.min(D,z(e.eastIndices,e.eastSkirtHeight,S,l,u,g,P,x,b)),D=Math.min(D,z(e.northIndices,e.northSkirtHeight,S,l,u,g,P,x,b));const Pe=new be.AxisAlignedBoundingBox(x,b,p),_=new he.TerrainEncoding(p,Pe,D,W,v,L,n,I,a,m),G=_.stride,V=new Float32Array(r*G+s*G);let pe=0;for(let c=0;c<r;++c){if(L){const f=2*c;O.x=i[f],O.y=i[f+1]}pe=_.encode(V,pe,$[c],l[c],S[c],O,Te[c],fe[c])}const De=Math.max(0,2*(s-4)),ke=e.indices.length+3*De,Z=ue.IndexDatatype.createTypedArray(r+s,ke);Z.set(e.indices,0);const ye=1e-4,Ne=(te-ee)*ye,we=(oe-re)*ye,Fe=-Ne,He=Ne,_e=we,Ge=-we;let Y=r*G;return q(V,Y,ne,_,S,l,i,g,u,e.westSkirtHeight,y,F,Fe,0),Y+=e.westIndices.length*G,q(V,Y,se,_,S,l,i,g,u,e.southSkirtHeight,y,F,0,Ge),Y+=e.southIndices.length*G,q(V,Y,ie,_,S,l,i,g,u,e.eastSkirtHeight,y,F,He,0),Y+=e.eastIndices.length*G,q(V,Y,ae,_,S,l,i,g,u,e.northSkirtHeight,y,F,0,_e),T.addSkirtIndices(ne,se,ie,ae,r,Z,e.indices.length),o.push(V.buffer,Z.buffer),{vertices:V.buffer,indices:Z.buffer,westIndicesSouthToNorth:ne,southIndicesEastToWest:se,eastIndicesNorthToSouth:ie,northIndicesWestToEast:ae,vertexStride:G,center:p,minimumHeight:M,maximumHeight:W,occludeePointInScaledSpace:Ee,encoding:_,indexCountWithoutSkirts:e.indices.length}})});
