/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./defaultValue-ebbd2e4d","./Matrix3-2955527a","./ArcType-efd92361","./Transforms-5b74e989","./Color-3cef7e8d","./ComponentDatatype-f9ac3ed8","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolylinePipeline-0a87fb90","./Matrix2-462b83d3","./RuntimeError-38a08050","./combine-55e9f355","./WebGLConstants-544672c2","./EllipsoidGeodesic-7acc6014","./EllipsoidRhumbLine-8bc8a516","./IntersectionTests-2a07bba4","./Plane-7e97483e"],function(p,h,k,N,a,M,L,F,H,I,A,z,J,j,K,Q,X,Z,$){"use strict";function W(i,o,e,l,s,r,c){const T=A.PolylinePipeline.numberOfPoints(i,o,s);let d;const t=e.red,u=e.green,C=e.blue,g=e.alpha,n=l.red,y=l.green,m=l.blue,G=l.alpha;if(a.Color.equals(e,l)){for(d=0;d<T;d++)r[c++]=a.Color.floatToByte(t),r[c++]=a.Color.floatToByte(u),r[c++]=a.Color.floatToByte(C),r[c++]=a.Color.floatToByte(g);return c}const R=(n-t)/T,D=(y-u)/T,x=(m-C)/T,b=(G-g)/T;let f=c;for(d=0;d<T;d++)r[f++]=a.Color.floatToByte(t+d*R),r[f++]=a.Color.floatToByte(u+d*D),r[f++]=a.Color.floatToByte(C+d*x),r[f++]=a.Color.floatToByte(g+d*b);return f}function E(i){const o=(i=p.defaultValue(i,p.defaultValue.EMPTY_OBJECT)).positions,e=i.colors,l=p.defaultValue(i.colorsPerVertex,!1);this._positions=o,this._colors=e,this._colorsPerVertex=l,this._arcType=p.defaultValue(i.arcType,k.ArcType.GEODESIC),this._granularity=p.defaultValue(i.granularity,I.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=p.defaultValue(i.ellipsoid,h.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";let s=1+o.length*h.Cartesian3.packedLength;s+=p.defined(e)?1+e.length*a.Color.packedLength:1,this.packedLength=s+h.Ellipsoid.packedLength+3}E.pack=function(i,o,e){let l;e=p.defaultValue(e,0);const s=i._positions;let r=s.length;for(o[e++]=r,l=0;l<r;++l,e+=h.Cartesian3.packedLength)h.Cartesian3.pack(s[l],o,e);const c=i._colors;for(r=p.defined(c)?c.length:0,o[e++]=r,l=0;l<r;++l,e+=a.Color.packedLength)a.Color.pack(c[l],o,e);return h.Ellipsoid.pack(i._ellipsoid,o,e),e+=h.Ellipsoid.packedLength,o[e++]=i._colorsPerVertex?1:0,o[e++]=i._arcType,o[e]=i._granularity,o},E.unpack=function(i,o,e){let l;o=p.defaultValue(o,0);let s=i[o++];const r=new Array(s);for(l=0;l<s;++l,o+=h.Cartesian3.packedLength)r[l]=h.Cartesian3.unpack(i,o);s=i[o++];const c=s>0?new Array(s):void 0;for(l=0;l<s;++l,o+=a.Color.packedLength)c[l]=a.Color.unpack(i,o);const T=h.Ellipsoid.unpack(i,o);o+=h.Ellipsoid.packedLength;const d=i[o++]===1,t=i[o++],u=i[o];return p.defined(e)?(e._positions=r,e._colors=c,e._ellipsoid=T,e._colorsPerVertex=d,e._arcType=t,e._granularity=u,e):new E({positions:r,colors:c,ellipsoid:T,colorsPerVertex:d,arcType:t,granularity:u})};const w=new Array(2),V=new Array(2),Y={positions:w,height:V,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return E.createGeometry=function(i){const o=i._positions,e=i._colors,l=i._colorsPerVertex,s=i._arcType,r=i._granularity,c=i._ellipsoid,T=I.CesiumMath.chordLength(r,c.maximumRadius),d=p.defined(e)&&!l;let t;const u=o.length;let C,g,n,y,m=0;if(s===k.ArcType.GEODESIC||s===k.ArcType.RHUMB){let b,f,B;s===k.ArcType.GEODESIC?(b=I.CesiumMath.chordLength(r,c.maximumRadius),f=A.PolylinePipeline.numberOfPoints,B=A.PolylinePipeline.generateArc):(b=r,f=A.PolylinePipeline.numberOfPointsRhumbLine,B=A.PolylinePipeline.generateRhumbArc);const v=A.PolylinePipeline.extractHeights(o,c),P=Y;if(s===k.ArcType.GEODESIC?P.minDistance=T:P.granularity=r,P.ellipsoid=c,d){let _=0;for(t=0;t<u-1;t++)_+=f(o[t],o[t+1],b)+1;C=new Float64Array(3*_),n=new Uint8Array(4*_),P.positions=w,P.height=V;let S=0;for(t=0;t<u-1;++t){w[0]=o[t],w[1]=o[t+1],V[0]=v[t],V[1]=v[t+1];const O=B(P);if(p.defined(e)){const q=O.length/3;y=e[t];for(let U=0;U<q;++U)n[S++]=a.Color.floatToByte(y.red),n[S++]=a.Color.floatToByte(y.green),n[S++]=a.Color.floatToByte(y.blue),n[S++]=a.Color.floatToByte(y.alpha)}C.set(O,m),m+=O.length}}else if(P.positions=o,P.height=v,C=new Float64Array(B(P)),p.defined(e)){for(n=new Uint8Array(C.length/3*4),t=0;t<u-1;++t)m=W(o[t],o[t+1],e[t],e[t+1],T,n,m);const _=e[u-1];n[m++]=a.Color.floatToByte(_.red),n[m++]=a.Color.floatToByte(_.green),n[m++]=a.Color.floatToByte(_.blue),n[m++]=a.Color.floatToByte(_.alpha)}}else{g=d?2*u-2:u,C=new Float64Array(3*g),n=p.defined(e)?new Uint8Array(4*g):void 0;let b=0,f=0;for(t=0;t<u;++t){const B=o[t];if(d&&t>0&&(h.Cartesian3.pack(B,C,b),b+=3,y=e[t-1],n[f++]=a.Color.floatToByte(y.red),n[f++]=a.Color.floatToByte(y.green),n[f++]=a.Color.floatToByte(y.blue),n[f++]=a.Color.floatToByte(y.alpha)),d&&t===u-1)break;h.Cartesian3.pack(B,C,b),b+=3,p.defined(e)&&(y=e[t],n[f++]=a.Color.floatToByte(y.red),n[f++]=a.Color.floatToByte(y.green),n[f++]=a.Color.floatToByte(y.blue),n[f++]=a.Color.floatToByte(y.alpha))}}const G=new F.GeometryAttributes;G.position=new L.GeometryAttribute({componentDatatype:M.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:C}),p.defined(e)&&(G.color=new L.GeometryAttribute({componentDatatype:M.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:n,normalize:!0})),g=C.length/3;const R=2*(g-1),D=H.IndexDatatype.createTypedArray(g,R);let x=0;for(t=0;t<g-1;++t)D[x++]=t,D[x++]=t+1;return new L.Geometry({attributes:G,indices:D,primitiveType:L.PrimitiveType.LINES,boundingSphere:N.BoundingSphere.fromPoints(o)})},function(i,o){return p.defined(o)&&(i=E.unpack(i,o)),i._ellipsoid=h.Ellipsoid.clone(i._ellipsoid),E.createGeometry(i)}});
