/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Transforms-5b74e989","./Matrix2-462b83d3","./Matrix3-2955527a","./ComponentDatatype-f9ac3ed8","./CylinderGeometryLibrary-187f9348","./defaultValue-ebbd2e4d","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryOffsetAttribute-739bec2c","./IndexDatatype-7ccfd280","./Math-1fe079f3","./VertexFormat-5b02b45a"],function(B,Y,k,b,D,Z,x,C,J,W,j,q,g){"use strict";const O=new k.Cartesian2,H=new b.Cartesian3,K=new b.Cartesian3,Q=new b.Cartesian3,X=new b.Cartesian3;function F(t){const n=(t=x.defaultValue(t,x.defaultValue.EMPTY_OBJECT)).length,o=t.topRadius,_=t.bottomRadius,e=x.defaultValue(t.vertexFormat,g.VertexFormat.DEFAULT),s=x.defaultValue(t.slices,128);this._length=n,this._topRadius=o,this._bottomRadius=_,this._vertexFormat=g.VertexFormat.clone(e),this._slices=s,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}F.packedLength=g.VertexFormat.packedLength+5,F.pack=function(t,n,o){return o=x.defaultValue(o,0),g.VertexFormat.pack(t._vertexFormat,n,o),o+=g.VertexFormat.packedLength,n[o++]=t._length,n[o++]=t._topRadius,n[o++]=t._bottomRadius,n[o++]=t._slices,n[o]=x.defaultValue(t._offsetAttribute,-1),n};const z=new g.VertexFormat,R={vertexFormat:z,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let L;F.unpack=function(t,n,o){n=x.defaultValue(n,0);const _=g.VertexFormat.unpack(t,n,z);n+=g.VertexFormat.packedLength;const e=t[n++],s=t[n++],f=t[n++],T=t[n++],d=t[n];return x.defined(o)?(o._vertexFormat=g.VertexFormat.clone(_,o._vertexFormat),o._length=e,o._topRadius=s,o._bottomRadius=f,o._slices=T,o._offsetAttribute=d===-1?void 0:d,o):(R.length=e,R.topRadius=s,R.bottomRadius=f,R.slices=T,R.offsetAttribute=d===-1?void 0:d,new F(R))},F.createGeometry=function(t){let n=t._length;const o=t._topRadius,_=t._bottomRadius,e=t._vertexFormat,s=t._slices;if(n<=0||o<0||_<0||o===0&&_===0)return;const f=s+s,T=s+f,d=f+f,M=Z.CylinderGeometryLibrary.computePositions(n,o,_,s,!0),P=e.st?new Float32Array(2*d):void 0,m=e.normal?new Float32Array(3*d):void 0,c=e.tangent?new Float32Array(3*d):void 0,l=e.bitangent?new Float32Array(3*d):void 0;let a;const E=e.normal||e.tangent||e.bitangent;if(E){const w=e.tangent||e.bitangent;let u=0,p=0,y=0;const I=Math.atan2(_-o,n),A=H;A.z=Math.sin(I);const U=Math.cos(I);let h=Q,v=K;for(a=0;a<s;a++){const S=a/s*q.CesiumMath.TWO_PI,et=U*Math.cos(S),ot=U*Math.sin(S);E&&(A.x=et,A.y=ot,w&&(h=b.Cartesian3.normalize(b.Cartesian3.cross(b.Cartesian3.UNIT_Z,A,h),h)),e.normal&&(m[u++]=A.x,m[u++]=A.y,m[u++]=A.z,m[u++]=A.x,m[u++]=A.y,m[u++]=A.z),e.tangent&&(c[p++]=h.x,c[p++]=h.y,c[p++]=h.z,c[p++]=h.x,c[p++]=h.y,c[p++]=h.z),e.bitangent&&(v=b.Cartesian3.normalize(b.Cartesian3.cross(A,h,v),v),l[y++]=v.x,l[y++]=v.y,l[y++]=v.z,l[y++]=v.x,l[y++]=v.y,l[y++]=v.z))}for(a=0;a<s;a++)e.normal&&(m[u++]=0,m[u++]=0,m[u++]=-1),e.tangent&&(c[p++]=1,c[p++]=0,c[p++]=0),e.bitangent&&(l[y++]=0,l[y++]=-1,l[y++]=0);for(a=0;a<s;a++)e.normal&&(m[u++]=0,m[u++]=0,m[u++]=1),e.tangent&&(c[p++]=1,c[p++]=0,c[p++]=0),e.bitangent&&(l[y++]=0,l[y++]=1,l[y++]=0)}const $=12*s-12,r=j.IndexDatatype.createTypedArray(d,$);let i=0,G=0;for(a=0;a<s-1;a++)r[i++]=G,r[i++]=G+2,r[i++]=G+3,r[i++]=G,r[i++]=G+3,r[i++]=G+1,G+=2;for(r[i++]=f-2,r[i++]=0,r[i++]=1,r[i++]=f-2,r[i++]=1,r[i++]=f-1,a=1;a<s-1;a++)r[i++]=f+a+1,r[i++]=f+a,r[i++]=f;for(a=1;a<s-1;a++)r[i++]=T,r[i++]=T+a,r[i++]=T+a+1;let N=0;if(e.st){const w=Math.max(o,_);for(a=0;a<d;a++){const u=b.Cartesian3.fromArray(M,3*a,X);P[N++]=(u.x+w)/(2*w),P[N++]=(u.y+w)/(2*w)}}const V=new J.GeometryAttributes;e.position&&(V.position=new C.GeometryAttribute({componentDatatype:D.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:M})),e.normal&&(V.normal=new C.GeometryAttribute({componentDatatype:D.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m})),e.tangent&&(V.tangent=new C.GeometryAttribute({componentDatatype:D.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:c})),e.bitangent&&(V.bitangent=new C.GeometryAttribute({componentDatatype:D.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:l})),e.st&&(V.st=new C.GeometryAttribute({componentDatatype:D.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:P})),O.x=.5*n,O.y=Math.max(_,o);const tt=new Y.BoundingSphere(b.Cartesian3.ZERO,k.Cartesian2.magnitude(O));if(x.defined(t._offsetAttribute)){n=M.length;const w=t._offsetAttribute===W.GeometryOffsetAttribute.NONE?0:1,u=new Uint8Array(n/3).fill(w);V.applyOffset=new C.GeometryAttribute({componentDatatype:D.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:u})}return new C.Geometry({attributes:V,indices:r,primitiveType:C.PrimitiveType.TRIANGLES,boundingSphere:tt,offsetAttribute:t._offsetAttribute})},F.getUnitCylinder=function(){return x.defined(L)||(L=F.createGeometry(new F({topRadius:1,bottomRadius:1,length:1,vertexFormat:g.VertexFormat.POSITION_ONLY}))),L},B.CylinderGeometry=F});
