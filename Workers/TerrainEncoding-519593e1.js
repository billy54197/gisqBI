/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Transforms-5b74e989","./Matrix3-2955527a","./defaultValue-ebbd2e4d","./Matrix2-462b83d3","./AttributeCompression-6f93ad0c","./ComponentDatatype-f9ac3ed8","./Math-1fe079f3"],function(q,j,r,l,c,x,G,T){"use strict";function S(e,t){this._ellipsoid=e,this._cameraPosition=new r.Cartesian3,this._cameraPositionInScaledSpace=new r.Cartesian3,this._distanceToLimbInScaledSpaceSquared=0,l.defined(t)&&(this.cameraPosition=t)}Object.defineProperties(S.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},cameraPosition:{get:function(){return this._cameraPosition},set:function(e){const t=this._ellipsoid.transformPositionToScaledSpace(e,this._cameraPositionInScaledSpace),i=r.Cartesian3.magnitudeSquared(t)-1;r.Cartesian3.clone(e,this._cameraPosition),this._cameraPositionInScaledSpace=t,this._distanceToLimbInScaledSpaceSquared=i}}});const O=new r.Cartesian3;S.prototype.isPointVisible=function(e){return w(this._ellipsoid.transformPositionToScaledSpace(e,O),this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)},S.prototype.isScaledSpacePointVisible=function(e){return w(e,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};const k=new r.Cartesian3;S.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid=function(e,t){const i=this._ellipsoid;let a,o;return l.defined(t)&&t<0&&i.minimumRadius>-t?(o=k,o.x=this._cameraPosition.x/(i.radii.x+t),o.y=this._cameraPosition.y/(i.radii.y+t),o.z=this._cameraPosition.z/(i.radii.z+t),a=o.x*o.x+o.y*o.y+o.z*o.z-1):(o=this._cameraPositionInScaledSpace,a=this._distanceToLimbInScaledSpaceSquared),w(e,o,a)},S.prototype.computeHorizonCullingPoint=function(e,t,i){return U(this._ellipsoid,e,t,i)};const B=r.Ellipsoid.clone(r.Ellipsoid.UNIT_SPHERE);S.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid=function(e,t,i,a){return U(R(this._ellipsoid,i,B),e,t,a)},S.prototype.computeHorizonCullingPointFromVertices=function(e,t,i,a,o){return v(this._ellipsoid,e,t,i,a,o)},S.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid=function(e,t,i,a,o,s){return v(R(this._ellipsoid,o,B),e,t,i,a,s)};const J=[];S.prototype.computeHorizonCullingPointFromRectangle=function(e,t,i){const a=c.Rectangle.subsample(e,t,0,J),o=j.BoundingSphere.fromPoints(a);if(!(r.Cartesian3.magnitude(o.center)<.1*t.minimumRadius))return this.computeHorizonCullingPoint(o.center,a,i)};const K=new r.Cartesian3;function R(e,t,i){if(l.defined(t)&&t<0&&e.minimumRadius>-t){const a=r.Cartesian3.fromElements(e.radii.x+t,e.radii.y+t,e.radii.z+t,K);e=r.Ellipsoid.fromCartesian3(a,i)}return e}function U(e,t,i,a){l.defined(a)||(a=new r.Cartesian3);const o=D(e,t);let s=0;for(let n=0,d=i.length;n<d;++n){const u=W(e,i[n],o);if(u<0)return;s=Math.max(s,u)}return L(o,s,a)}const b=new r.Cartesian3;function v(e,t,i,a,o,s){l.defined(s)||(s=new r.Cartesian3),a=l.defaultValue(a,3),o=l.defaultValue(o,r.Cartesian3.ZERO);const n=D(e,t);let d=0;for(let u=0,C=i.length;u<C;u+=a){b.x=i[u]+o.x,b.y=i[u+1]+o.y,b.z=i[u+2]+o.z;const h=W(e,b,n);if(h<0)return;d=Math.max(d,h)}return L(n,d,s)}function w(e,t,i){const a=t,o=i,s=r.Cartesian3.subtract(e,a,O),n=-r.Cartesian3.dot(s,a);return!(o<0?n>0:n>o&&n*n/r.Cartesian3.magnitudeSquared(s)>o)}const Q=new r.Cartesian3,X=new r.Cartesian3;function W(e,t,i){const a=e.transformPositionToScaledSpace(t,Q);let o=r.Cartesian3.magnitudeSquared(a),s=Math.sqrt(o);const n=r.Cartesian3.divideByScalar(a,s,X);o=Math.max(1,o),s=Math.max(1,s);const d=1/s;return 1/(r.Cartesian3.dot(n,i)*d-r.Cartesian3.magnitude(r.Cartesian3.cross(n,i,n))*(Math.sqrt(o-1)*d))}function L(e,t,i){if(!(t<=0||t===1/0||t!=t))return r.Cartesian3.multiplyByScalar(e,t,i)}const A=new r.Cartesian3;function D(e,t){return r.Cartesian3.equals(t,r.Cartesian3.ZERO)?t:(e.transformPositionToScaledSpace(t,A),r.Cartesian3.normalize(A,A))}const I={getHeight:function(e,t,i){return(e-i)*t+i}},Y=new r.Cartesian3;I.getPosition=function(e,t,i,a,o){const s=t.cartesianToCartographic(e,Y),n=I.getHeight(s.height,i,a);return r.Cartesian3.fromRadians(s.longitude,s.latitude,n,t,o)};var $=I,p=Object.freeze({NONE:0,BITS12:1});const y=new r.Cartesian3,tt=new r.Cartesian3,f=new c.Cartesian2,P=new c.Matrix4,et=new c.Matrix4,it=Math.pow(2,12);function m(e,t,i,a,o,s,n,d,u,C){let h,g,E=p.NONE;if(l.defined(t)&&l.defined(i)&&l.defined(a)&&l.defined(o)){const M=t.minimum,V=t.maximum,N=r.Cartesian3.subtract(V,M,tt),at=a-i;E=Math.max(r.Cartesian3.maximumComponent(N),at)<it-1?p.BITS12:p.NONE,h=c.Matrix4.inverseTransformation(o,new c.Matrix4);const rt=r.Cartesian3.negate(M,y);c.Matrix4.multiply(c.Matrix4.fromTranslation(rt,P),h,h);const H=y;H.x=1/N.x,H.y=1/N.y,H.z=1/N.z,c.Matrix4.multiply(c.Matrix4.fromScale(H,P),h,h),g=c.Matrix4.clone(o),c.Matrix4.setTranslation(g,r.Cartesian3.ZERO,g),o=c.Matrix4.clone(o,new c.Matrix4);const nt=c.Matrix4.fromTranslation(M,P),st=c.Matrix4.fromScale(N,et),Z=c.Matrix4.multiply(nt,st,P);c.Matrix4.multiply(o,Z,o),c.Matrix4.multiply(g,Z,g)}this.quantization=E,this.minimumHeight=i,this.maximumHeight=a,this.center=r.Cartesian3.clone(e),this.toScaledENU=h,this.fromScaledENU=o,this.matrix=g,this.hasVertexNormals=s,this.hasWebMercatorT=l.defaultValue(n,!1),this.hasGeodeticSurfaceNormals=l.defaultValue(d,!1),this.exaggeration=l.defaultValue(u,1),this.exaggerationRelativeHeight=l.defaultValue(C,0),this.stride=0,this._offsetGeodeticSurfaceNormal=0,this._offsetVertexNormal=0,this._calculateStrideAndOffsets()}m.prototype.encode=function(e,t,i,a,o,s,n,d){const u=a.x,C=a.y;if(this.quantization===p.BITS12){(i=c.Matrix4.multiplyByPoint(this.toScaledENU,i,y)).x=T.CesiumMath.clamp(i.x,0,1),i.y=T.CesiumMath.clamp(i.y,0,1),i.z=T.CesiumMath.clamp(i.z,0,1);const h=this.maximumHeight-this.minimumHeight,g=T.CesiumMath.clamp((o-this.minimumHeight)/h,0,1);c.Cartesian2.fromElements(i.x,i.y,f);const E=x.AttributeCompression.compressTextureCoordinates(f);c.Cartesian2.fromElements(i.z,g,f);const M=x.AttributeCompression.compressTextureCoordinates(f);c.Cartesian2.fromElements(u,C,f);const V=x.AttributeCompression.compressTextureCoordinates(f);if(e[t++]=E,e[t++]=M,e[t++]=V,this.hasWebMercatorT){c.Cartesian2.fromElements(n,0,f);const N=x.AttributeCompression.compressTextureCoordinates(f);e[t++]=N}}else r.Cartesian3.subtract(i,this.center,y),e[t++]=y.x,e[t++]=y.y,e[t++]=y.z,e[t++]=o,e[t++]=u,e[t++]=C,this.hasWebMercatorT&&(e[t++]=n);return this.hasVertexNormals&&(e[t++]=x.AttributeCompression.octPackFloat(s)),this.hasGeodeticSurfaceNormals&&(e[t++]=d.x,e[t++]=d.y,e[t++]=d.z),t};const ot=new r.Cartesian3,F=new r.Cartesian3;m.prototype.addGeodeticSurfaceNormals=function(e,t,i){if(this.hasGeodeticSurfaceNormals)return;const a=this.stride,o=e.length/a;this.hasGeodeticSurfaceNormals=!0,this._calculateStrideAndOffsets();const s=this.stride;for(let n=0;n<o;n++){for(let h=0;h<a;h++){const g=n*a+h;t[n*s+h]=e[g]}const d=this.decodePosition(t,n,ot),u=i.geodeticSurfaceNormal(d,F),C=n*s+this._offsetGeodeticSurfaceNormal;t[C]=u.x,t[C+1]=u.y,t[C+2]=u.z}},m.prototype.removeGeodeticSurfaceNormals=function(e,t){if(!this.hasGeodeticSurfaceNormals)return;const i=this.stride,a=e.length/i;this.hasGeodeticSurfaceNormals=!1,this._calculateStrideAndOffsets();const o=this.stride;for(let s=0;s<a;s++)for(let n=0;n<o;n++){const d=s*i+n;t[s*o+n]=e[d]}},m.prototype.decodePosition=function(e,t,i){if(l.defined(i)||(i=new r.Cartesian3),t*=this.stride,this.quantization===p.BITS12){const a=x.AttributeCompression.decompressTextureCoordinates(e[t],f);i.x=a.x,i.y=a.y;const o=x.AttributeCompression.decompressTextureCoordinates(e[t+1],f);return i.z=o.x,c.Matrix4.multiplyByPoint(this.fromScaledENU,i,i)}return i.x=e[t],i.y=e[t+1],i.z=e[t+2],r.Cartesian3.add(i,this.center,i)},m.prototype.getExaggeratedPosition=function(e,t,i){i=this.decodePosition(e,t,i);const a=this.exaggeration,o=this.exaggerationRelativeHeight;if(a!==1&&this.hasGeodeticSurfaceNormals){const s=this.decodeGeodeticSurfaceNormal(e,t,F),n=this.decodeHeight(e,t),d=$.getHeight(n,a,o)-n;i.x+=s.x*d,i.y+=s.y*d,i.z+=s.z*d}return i},m.prototype.decodeTextureCoordinates=function(e,t,i){return l.defined(i)||(i=new c.Cartesian2),t*=this.stride,this.quantization===p.BITS12?x.AttributeCompression.decompressTextureCoordinates(e[t+2],i):c.Cartesian2.fromElements(e[t+4],e[t+5],i)},m.prototype.decodeHeight=function(e,t){return t*=this.stride,this.quantization===p.BITS12?x.AttributeCompression.decompressTextureCoordinates(e[t+1],f).y*(this.maximumHeight-this.minimumHeight)+this.minimumHeight:e[t+3]},m.prototype.decodeWebMercatorT=function(e,t){return t*=this.stride,this.quantization===p.BITS12?x.AttributeCompression.decompressTextureCoordinates(e[t+3],f).x:e[t+6]},m.prototype.getOctEncodedNormal=function(e,t,i){const a=e[t=t*this.stride+this._offsetVertexNormal]/256,o=Math.floor(a),s=256*(a-o);return c.Cartesian2.fromElements(o,s,i)},m.prototype.decodeGeodeticSurfaceNormal=function(e,t,i){return t=t*this.stride+this._offsetGeodeticSurfaceNormal,i.x=e[t],i.y=e[t+1],i.z=e[t+2],i},m.prototype._calculateStrideAndOffsets=function(){let e=0;this.quantization===p.BITS12?e+=3:e+=6,this.hasWebMercatorT&&(e+=1),this.hasVertexNormals&&(this._offsetVertexNormal=e,e+=1),this.hasGeodeticSurfaceNormals&&(this._offsetGeodeticSurfaceNormal=e,e+=3),this.stride=e};const z={position3DAndHeight:0,textureCoordAndEncodedNormals:1,geodeticSurfaceNormal:2},_={compressed0:0,compressed1:1,geodeticSurfaceNormal:2};m.prototype.getAttributes=function(e){const t=G.ComponentDatatype.FLOAT,i=G.ComponentDatatype.getSizeInBytes(t),a=this.stride*i;let o=0;const s=[];function n(d,u){s.push({index:d,vertexBuffer:e,componentDatatype:t,componentsPerAttribute:u,offsetInBytes:o,strideInBytes:a}),o+=u*i}if(this.quantization===p.NONE){n(z.position3DAndHeight,4);let d=2;d+=this.hasWebMercatorT?1:0,d+=this.hasVertexNormals?1:0,n(z.textureCoordAndEncodedNormals,d),this.hasGeodeticSurfaceNormals&&n(z.geodeticSurfaceNormal,3)}else{const d=this.hasWebMercatorT||this.hasVertexNormals,u=this.hasWebMercatorT&&this.hasVertexNormals;n(_.compressed0,d?4:3),u&&n(_.compressed1,1),this.hasGeodeticSurfaceNormals&&n(_.geodeticSurfaceNormal,3)}return s},m.prototype.getAttributeLocations=function(){return this.quantization===p.NONE?z:_},m.clone=function(e,t){if(l.defined(e))return l.defined(t)||(t=new m),t.quantization=e.quantization,t.minimumHeight=e.minimumHeight,t.maximumHeight=e.maximumHeight,t.center=r.Cartesian3.clone(e.center),t.toScaledENU=c.Matrix4.clone(e.toScaledENU),t.fromScaledENU=c.Matrix4.clone(e.fromScaledENU),t.matrix=c.Matrix4.clone(e.matrix),t.hasVertexNormals=e.hasVertexNormals,t.hasWebMercatorT=e.hasWebMercatorT,t.hasGeodeticSurfaceNormals=e.hasGeodeticSurfaceNormals,t.exaggeration=e.exaggeration,t.exaggerationRelativeHeight=e.exaggerationRelativeHeight,t._calculateStrideAndOffsets(),t},q.EllipsoidalOccluder=S,q.TerrainEncoding=m});
