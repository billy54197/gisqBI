/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Matrix2-462b83d3","./Matrix3-2955527a","./EllipsoidTangentPlane-da4fdd19","./Math-1fe079f3","./PolylinePipeline-0a87fb90","./Transforms-5b74e989","./defaultValue-ebbd2e4d"],function(K,I,e,oe,X,$,W,le){"use strict";var H=Object.freeze({ROUNDED:0,MITERED:1,BEVELED:2});const ce={};function L(a,r){le.defined(ce[a])||(ce[a]=!0,console.warn(le.defaultValue(r,a)))}L.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",L.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",L.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",L.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";const w=[new e.Cartesian3,new e.Cartesian3],pe=new e.Cartesian3,we=new e.Cartesian3,xe=new e.Cartesian3,Ee=new e.Cartesian3,Pe=new e.Cartesian3,be=new e.Cartesian3,Me=new e.Cartesian3,Te=new e.Cartesian3,Be=new e.Cartesian3,Q=new e.Cartesian3,Y=new e.Cartesian3,_={};let ee=new e.Cartographic;function ne(a,r,o,h){const t=a[0],n=a[1],u=e.Cartesian3.angleBetween(t,n),c=Math.ceil(u/h),d=new Array(c);let s;if(r===o){for(s=0;s<c;s++)d[s]=r;return d.push(o),d}const z=(o-r)/c;for(s=1;s<c;s++){const m=r+s*z;d[s]=m}return d[0]=r,d.push(o),d}const k=new e.Cartesian3,J=new e.Cartesian3,ze=new e.Cartesian3(-1,0,0);let N=new I.Matrix4;const Se=new I.Matrix4;let ae=new e.Matrix3;const Ae=e.Matrix3.IDENTITY.clone(),De=new e.Cartesian3,Re=new I.Cartesian4,Ce=new e.Cartesian3;function v(a,r,o,h,t,n,u,c){let d=De,s=Re;N=W.Transforms.eastNorthUpToFixedFrame(a,t,N),d=I.Matrix4.multiplyByPointAsVector(N,ze,d),d=e.Cartesian3.normalize(d,d);const z=function(P,i,C,S){const g=new oe.EllipsoidTangentPlane(C,S),M=g.projectPointOntoPlane(e.Cartesian3.add(C,P,k),k),l=g.projectPointOntoPlane(e.Cartesian3.add(C,i,J),J),E=I.Cartesian2.angleBetween(M,l);return l.x*M.y-l.y*M.x>=0?-E:E}(d,r,a,t);ae=e.Matrix3.fromRotationZ(z,ae),Ce.z=n,N=I.Matrix4.multiplyTransformation(N,I.Matrix4.fromRotationTranslation(ae,Ce,Se),N);const m=Ae;m[0]=u;for(let P=0;P<c;P++)for(let i=0;i<o.length;i+=3)s=e.Cartesian3.fromArray(o,i,s),s=e.Matrix3.multiplyByVector(m,s,s),s=I.Matrix4.multiplyByPoint(N,s,s),h.push(s.x,s.y,s.z);return h}const Oe=new e.Cartesian3;function re(a,r,o,h,t,n,u){for(let c=0;c<a.length;c+=3)h=v(e.Cartesian3.fromArray(a,c,Oe),r,o,h,t,n[c/3],u,1);return h}function ue(a,r){const o=a.length,h=new Array(3*o);let t=0;const n=r.x+r.width/2,u=r.y+r.height/2;for(let c=0;c<o;c++)h[t++]=a[c].x-n,h[t++]=0,h[t++]=a[c].y-u;return h}const de=new W.Quaternion,ge=new e.Cartesian3,ye=new e.Matrix3;function fe(a,r,o,h,t,n,u,c,d,s){const z=e.Cartesian3.angleBetween(e.Cartesian3.subtract(r,a,Q),e.Cartesian3.subtract(o,a,Y)),m=h===H.BEVELED?0:Math.ceil(z/X.CesiumMath.toRadians(5));let P,i,C;if(P=t?e.Matrix3.fromQuaternion(W.Quaternion.fromAxisAngle(e.Cartesian3.negate(a,Q),z/(m+1),de),ye):e.Matrix3.fromQuaternion(W.Quaternion.fromAxisAngle(a,z/(m+1),de),ye),r=e.Cartesian3.clone(r,ge),m>0){const S=s?2:1;for(let g=0;g<m;g++)r=e.Matrix3.multiplyByVector(P,r,r),i=e.Cartesian3.subtract(r,a,Q),i=e.Cartesian3.normalize(i,i),t||(i=e.Cartesian3.negate(i,i)),C=n.scaleToGeodeticSurface(r,Y),u=v(C,i,c,u,n,d,1,S)}else i=e.Cartesian3.subtract(r,a,Q),i=e.Cartesian3.normalize(i,i),t||(i=e.Cartesian3.negate(i,i)),C=n.scaleToGeodeticSurface(r,Y),u=v(C,i,c,u,n,d,1,1),o=e.Cartesian3.clone(o,ge),i=e.Cartesian3.subtract(o,a,Q),i=e.Cartesian3.normalize(i,i),t||(i=e.Cartesian3.negate(i,i)),C=n.scaleToGeodeticSurface(o,Y),u=v(C,i,c,u,n,d,1,1);return u}_.removeDuplicatesFromShape=function(a){const r=a.length,o=[];for(let h=r-1,t=0;t<r;h=t++){const n=a[h],u=a[t];I.Cartesian2.equals(n,u)||o.push(u)}return o},_.angleIsGreaterThanPi=function(a,r,o,h){const t=new oe.EllipsoidTangentPlane(o,h),n=t.projectPointOntoPlane(e.Cartesian3.add(o,a,k),k),u=t.projectPointOntoPlane(e.Cartesian3.add(o,r,J),J);return u.x*n.y-u.y*n.x>=0};const Ve=new e.Cartesian3,Ie=new e.Cartesian3;_.computePositions=function(a,r,o,h,t){const n=h._ellipsoid,u=function(b,V){const B=new Array(b.length);for(let f=0;f<b.length;f++){const p=b[f];ee=V.cartesianToCartographic(p,ee),B[f]=ee.height,b[f]=V.scaleToGeodeticSurface(p,p)}return B}(a,n),c=h._granularity,d=h._cornerType,s=t?function(b,V){const B=b.length,f=new Array(6*B);let p=0;const j=V.x+V.width/2,te=V.y+V.height/2;let G=b[0];f[p++]=G.x-j,f[p++]=0,f[p++]=G.y-te;for(let se=1;se<B;se++){G=b[se];const he=G.x-j,me=G.y-te;f[p++]=he,f[p++]=0,f[p++]=me,f[p++]=he,f[p++]=0,f[p++]=me}return G=b[0],f[p++]=G.x-j,f[p++]=0,f[p++]=G.y-te,f}(r,o):ue(r,o),z=t?ue(r,o):void 0,m=o.height/2,P=o.width/2;let i=a.length,C=[],S=t?[]:void 0,g=pe,M=we,l=xe,E=Ee,A=Pe,D=be,R=Me,y=Te,T=Be,x=a[0],q=a[1];E=n.geodeticSurfaceNormal(x,E),g=e.Cartesian3.subtract(q,x,g),g=e.Cartesian3.normalize(g,g),y=e.Cartesian3.cross(E,g,y),y=e.Cartesian3.normalize(y,y);let F,U,Z=u[0],O=u[1];t&&(S=v(x,y,z,S,n,Z+m,1,1)),T=e.Cartesian3.clone(x,T),x=q,M=e.Cartesian3.negate(g,M);for(let b=1;b<i-1;b++){const V=t?2:1;if(q=a[b+1],x.equals(q)){L("Positions are too close and are considered equivalent with rounding error.");continue}g=e.Cartesian3.subtract(q,x,g),g=e.Cartesian3.normalize(g,g),l=e.Cartesian3.add(g,M,l),l=e.Cartesian3.normalize(l,l),E=n.geodeticSurfaceNormal(x,E);const B=e.Cartesian3.multiplyByScalar(E,e.Cartesian3.dot(g,E),Ve);e.Cartesian3.subtract(g,B,B),e.Cartesian3.normalize(B,B);const f=e.Cartesian3.multiplyByScalar(E,e.Cartesian3.dot(M,E),Ie);if(e.Cartesian3.subtract(M,f,f),e.Cartesian3.normalize(f,f),X.CesiumMath.equalsEpsilon(Math.abs(e.Cartesian3.dot(B,f)),1,X.CesiumMath.EPSILON7))C=v(T,y,s,C,n,Z+m,1,1),T=x;else{l=e.Cartesian3.cross(l,E,l),l=e.Cartesian3.cross(E,l,l),l=e.Cartesian3.normalize(l,l);const p=1/Math.max(.25,e.Cartesian3.magnitude(e.Cartesian3.cross(l,M,Q))),j=_.angleIsGreaterThanPi(g,M,x,n);j?(A=e.Cartesian3.add(x,e.Cartesian3.multiplyByScalar(l,p*P,l),A),D=e.Cartesian3.add(A,e.Cartesian3.multiplyByScalar(y,P,D),D),w[0]=e.Cartesian3.clone(T,w[0]),w[1]=e.Cartesian3.clone(D,w[1]),F=ne(w,Z+m,O+m,c),U=$.PolylinePipeline.generateArc({positions:w,granularity:c,ellipsoid:n}),C=re(U,y,s,C,n,F,1),y=e.Cartesian3.cross(E,g,y),y=e.Cartesian3.normalize(y,y),R=e.Cartesian3.add(A,e.Cartesian3.multiplyByScalar(y,P,R),R),d===H.ROUNDED||d===H.BEVELED?fe(A,D,R,d,j,n,C,s,O+m,t):(l=e.Cartesian3.negate(l,l),C=v(x,l,s,C,n,O+m,p,V)),T=e.Cartesian3.clone(R,T)):(A=e.Cartesian3.add(x,e.Cartesian3.multiplyByScalar(l,p*P,l),A),D=e.Cartesian3.add(A,e.Cartesian3.multiplyByScalar(y,-P,D),D),w[0]=e.Cartesian3.clone(T,w[0]),w[1]=e.Cartesian3.clone(D,w[1]),F=ne(w,Z+m,O+m,c),U=$.PolylinePipeline.generateArc({positions:w,granularity:c,ellipsoid:n}),C=re(U,y,s,C,n,F,1),y=e.Cartesian3.cross(E,g,y),y=e.Cartesian3.normalize(y,y),R=e.Cartesian3.add(A,e.Cartesian3.multiplyByScalar(y,-P,R),R),d===H.ROUNDED||d===H.BEVELED?fe(A,D,R,d,j,n,C,s,O+m,t):C=v(x,l,s,C,n,O+m,p,V),T=e.Cartesian3.clone(R,T)),M=e.Cartesian3.negate(g,M)}Z=O,O=u[b+1],x=q}w[0]=e.Cartesian3.clone(T,w[0]),w[1]=e.Cartesian3.clone(x,w[1]),F=ne(w,Z+m,O+m,c),U=$.PolylinePipeline.generateArc({positions:w,granularity:c,ellipsoid:n}),C=re(U,y,s,C,n,F,1),t&&(S=v(x,y,z,S,n,O+m,1,1)),i=C.length;const Ge=t?i+S.length:i,ie=new Float64Array(Ge);return ie.set(C),t&&ie.set(S,i),ie};var ve=_;K.CornerType=H,K.PolylineVolumeGeometryLibrary=ve,K.oneTimeWarning=L});
