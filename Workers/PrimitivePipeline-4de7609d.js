/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Transforms-5b74e989","./ComponentDatatype-f9ac3ed8","./defaultValue-ebbd2e4d","./Matrix3-2955527a","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryPipeline-3cfa9822","./IndexDatatype-7ccfd280","./Matrix2-462b83d3","./WebMercatorProjection-3d5b0545"],function(B,b,k,d,I,A,H,x,T,P,F){"use strict";function C(e,i,t){e=d.defaultValue(e,0),i=d.defaultValue(i,0),t=d.defaultValue(t,0),this.value=new Float32Array([e,i,t])}function V(e,i){const t=e.attributes,r=t.position,s=r.values.length/r.componentsPerAttribute;t.batchId=new A.GeometryAttribute({componentDatatype:k.ComponentDatatype.FLOAT,componentsPerAttribute:1,values:new Float32Array(s)});const m=t.batchId.values;for(let n=0;n<s;++n)m[n]=i}function z(e){const i=e.instances,t=e.projection,r=e.elementIndexUintSupported,s=e.scene3DOnly,m=e.vertexCacheOptimize,n=e.compressVertices,f=e.modelMatrix;let a,p,c=i.length;for(a=0;a<c;++a)if(d.defined(i[a].geometry)){i[a].geometry.primitiveType;break}if(function(o,u,g){let h=!g;const S=o.length;let y;if(!h&&S>1){const w=o[0].modelMatrix;for(y=1;y<S;++y)if(!P.Matrix4.equals(w,o[y].modelMatrix)){h=!0;break}}if(h)for(y=0;y<S;++y)d.defined(o[y].geometry)&&x.GeometryPipeline.transformToWorldCoordinates(o[y]);else P.Matrix4.multiplyTransformation(u,o[0].modelMatrix,u)}(i,f,s),!s)for(a=0;a<c;++a)d.defined(i[a].geometry)&&x.GeometryPipeline.splitLongitude(i[a]);if(function(o){const u=o.length;for(let g=0;g<u;++g){const h=o[g];d.defined(h.geometry)?V(h.geometry,g):d.defined(h.westHemisphereGeometry)&&d.defined(h.eastHemisphereGeometry)&&(V(h.westHemisphereGeometry,g),V(h.eastHemisphereGeometry,g))}}(i),m)for(a=0;a<c;++a){const o=i[a];d.defined(o.geometry)?(x.GeometryPipeline.reorderForPostVertexCache(o.geometry),x.GeometryPipeline.reorderForPreVertexCache(o.geometry)):d.defined(o.westHemisphereGeometry)&&d.defined(o.eastHemisphereGeometry)&&(x.GeometryPipeline.reorderForPostVertexCache(o.westHemisphereGeometry),x.GeometryPipeline.reorderForPreVertexCache(o.westHemisphereGeometry),x.GeometryPipeline.reorderForPostVertexCache(o.eastHemisphereGeometry),x.GeometryPipeline.reorderForPreVertexCache(o.eastHemisphereGeometry))}let l=x.GeometryPipeline.combineInstances(i);for(c=l.length,a=0;a<c;++a){p=l[a];const o=p.attributes;if(s)for(const u in o)o.hasOwnProperty(u)&&o[u].componentDatatype===k.ComponentDatatype.DOUBLE&&x.GeometryPipeline.encodeAttribute(p,u,`${u}3DHigh`,`${u}3DLow`);else for(const u in o)if(o.hasOwnProperty(u)&&o[u].componentDatatype===k.ComponentDatatype.DOUBLE){const g=`${u}3D`,h=`${u}2D`;x.GeometryPipeline.projectTo2D(p,u,g,h,t),d.defined(p.boundingSphere)&&u==="position"&&(p.boundingSphereCV=b.BoundingSphere.fromVertices(p.attributes.position2D.values)),x.GeometryPipeline.encodeAttribute(p,g,`${g}High`,`${g}Low`),x.GeometryPipeline.encodeAttribute(p,h,`${h}High`,`${h}Low`)}n&&x.GeometryPipeline.compressVertices(p)}if(!r){let o=[];for(c=l.length,a=0;a<c;++a)p=l[a],o=o.concat(x.GeometryPipeline.fitToUnsignedShortIndices(p));l=o}return l}function D(e,i,t,r){let s,m,n;const f=r.length-1;if(f>=0){const p=r[f];s=p.offset+p.count,n=p.index,m=t[n].indices.length}else s=0,n=0,m=t[n].indices.length;const a=e.length;for(let p=0;p<a;++p){const c=e[p][i];if(!d.defined(c))continue;const l=c.indices.length;s+l>m&&(s=0,m=t[++n].indices.length),r.push({index:n,offset:s,count:l}),s+=l}}Object.defineProperties(C.prototype,{componentDatatype:{get:function(){return k.ComponentDatatype.FLOAT}},componentsPerAttribute:{get:function(){return 3}},normalize:{get:function(){return!1}}}),C.fromCartesian3=function(e){return new C(e.x,e.y,e.z)},C.toValue=function(e,i){return d.defined(i)||(i=new Float32Array([e.x,e.y,e.z])),i[0]=e.x,i[1]=e.y,i[2]=e.z,i};const G={};function j(e,i){const t=e.attributes;for(const r in t)if(t.hasOwnProperty(r)){const s=t[r];d.defined(s)&&d.defined(s.values)&&i.push(s.values.buffer)}d.defined(e.indices)&&i.push(e.indices.buffer)}function R(e,i){const t=e.length,r=new Float64Array(1+19*t);let s=0;r[s++]=t;for(let m=0;m<t;m++){const n=e[m];if(P.Matrix4.pack(n.modelMatrix,r,s),s+=P.Matrix4.packedLength,d.defined(n.attributes)&&d.defined(n.attributes.offset)){const f=n.attributes.offset.value;r[s]=f[0],r[s+1]=f[1],r[s+2]=f[2]}s+=3}return i.push(r.buffer),r}function M(e){const i=e.length,t=1+(b.BoundingSphere.packedLength+1)*i,r=new Float32Array(t);let s=0;r[s++]=i;for(let m=0;m<i;++m){const n=e[m];d.defined(n)?(r[s++]=1,b.BoundingSphere.pack(e[m],r,s)):r[s++]=0,s+=b.BoundingSphere.packedLength}return r}function v(e){const i=new Array(e[0]);let t=0,r=1;for(;r<e.length;)e[r++]===1&&(i[t]=b.BoundingSphere.unpack(e,r)),++t,r+=b.BoundingSphere.packedLength;return i}G.combineGeometry=function(e){let i,t;const r=e.instances,s=r.length;let m,n,f=!1;s>0&&(i=z(e),i.length>0&&(t=x.GeometryPipeline.createAttributeLocations(i[0]),e.createPickOffsets&&(m=function(c,l){const o=[];return D(c,"geometry",l,o),D(c,"westHemisphereGeometry",l,o),D(c,"eastHemisphereGeometry",l,o),o}(r,i))),d.defined(r[0].attributes)&&d.defined(r[0].attributes.offset)&&(n=new Array(s),f=!0));const a=new Array(s),p=new Array(s);for(let c=0;c<s;++c){const l=r[c],o=l.geometry;d.defined(o)&&(a[c]=o.boundingSphere,p[c]=o.boundingSphereCV,f&&(n[c]=l.geometry.offsetAttribute));const u=l.eastHemisphereGeometry,g=l.westHemisphereGeometry;d.defined(u)&&d.defined(g)&&(d.defined(u.boundingSphere)&&d.defined(g.boundingSphere)&&(a[c]=b.BoundingSphere.union(u.boundingSphere,g.boundingSphere)),d.defined(u.boundingSphereCV)&&d.defined(g.boundingSphereCV)&&(p[c]=b.BoundingSphere.union(u.boundingSphereCV,g.boundingSphereCV)))}return{geometries:i,modelMatrix:e.modelMatrix,attributeLocations:t,pickOffsets:m,offsetInstanceExtend:n,boundingSpheres:a,boundingSpheresCV:p}},G.packCreateGeometryResults=function(e,i){const t=new Float64Array(function(f){let a=1;const p=f.length;for(let c=0;c<p;c++){const l=f[c];if(++a,!d.defined(l))continue;const o=l.attributes;a+=7+2*b.BoundingSphere.packedLength+(d.defined(l.indices)?l.indices.length:0);for(const u in o)o.hasOwnProperty(u)&&d.defined(o[u])&&(a+=5+o[u].values.length)}return a}(e)),r=[],s={},m=e.length;let n=0;t[n++]=m;for(let f=0;f<m;f++){const a=e[f],p=d.defined(a);if(t[n++]=p?1:0,!p)continue;t[n++]=a.primitiveType,t[n++]=a.geometryType,t[n++]=d.defaultValue(a.offsetAttribute,-1);const c=d.defined(a.boundingSphere)?1:0;t[n++]=c,c&&b.BoundingSphere.pack(a.boundingSphere,t,n),n+=b.BoundingSphere.packedLength;const l=d.defined(a.boundingSphereCV)?1:0;t[n++]=l,l&&b.BoundingSphere.pack(a.boundingSphereCV,t,n),n+=b.BoundingSphere.packedLength;const o=a.attributes,u=[];for(const h in o)o.hasOwnProperty(h)&&d.defined(o[h])&&(u.push(h),d.defined(s[h])||(s[h]=r.length,r.push(h)));t[n++]=u.length;for(let h=0;h<u.length;h++){const S=u[h],y=o[S];t[n++]=s[S],t[n++]=y.componentDatatype,t[n++]=y.componentsPerAttribute,t[n++]=y.normalize?1:0,t[n++]=y.values.length,t.set(y.values,n),n+=y.values.length}const g=d.defined(a.indices)?a.indices.length:0;t[n++]=g,g>0&&(t.set(a.indices,n),n+=g)}return i.push(t.buffer),{stringTable:r,packedData:t}},G.unpackCreateGeometryResults=function(e){const i=e.stringTable,t=e.packedData;let r;const s=new Array(t[0]);let m=0,n=1;for(;n<t.length;){if(t[n++]!==1){s[m++]=void 0;continue}const f=t[n++],a=t[n++];let p,c,l=t[n++];l===-1&&(l=void 0),t[n++]===1&&(p=b.BoundingSphere.unpack(t,n)),n+=b.BoundingSphere.packedLength;let o,u,g;t[n++]===1&&(c=b.BoundingSphere.unpack(t,n)),n+=b.BoundingSphere.packedLength;const h=new H.GeometryAttributes,S=t[n++];for(r=0;r<S;r++){const w=i[t[n++]],L=t[n++];g=t[n++];const U=t[n++]!==0;o=t[n++],u=k.ComponentDatatype.createTypedArray(L,o);for(let O=0;O<o;O++)u[O]=t[n++];h[w]=new A.GeometryAttribute({componentDatatype:L,componentsPerAttribute:g,normalize:U,values:u})}let y;if(o=t[n++],o>0){const w=u.length/g;for(y=T.IndexDatatype.createTypedArray(w,o),r=0;r<o;r++)y[r]=t[n++]}s[m++]=new A.Geometry({primitiveType:f,geometryType:a,boundingSphere:p,boundingSphereCV:c,indices:y,attributes:h,offsetAttribute:l})}return s},G.packCombineGeometryParameters=function(e,i){const t=e.createGeometryResults,r=t.length;for(let s=0;s<r;s++)i.push(t[s].packedData.buffer);return{createGeometryResults:e.createGeometryResults,packedInstances:R(e.instances,i),ellipsoid:e.ellipsoid,isGeographic:e.projection instanceof b.GeographicProjection,elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e.createPickOffsets}},G.unpackCombineGeometryParameters=function(e){const i=function(n){const f=n,a=new Array(f[0]);let p=0,c=1;for(;c<f.length;){const l=P.Matrix4.unpack(f,c);let o;c+=P.Matrix4.packedLength,d.defined(f[c])&&(o={offset:new C(f[c],f[c+1],f[c+2])}),c+=3,a[p++]={modelMatrix:l,attributes:o}}return a}(e.packedInstances),t=e.createGeometryResults,r=t.length;let s=0;for(let n=0;n<r;n++){const f=G.unpackCreateGeometryResults(t[n]),a=f.length;for(let p=0;p<a;p++){const c=f[p];i[s].geometry=c,++s}}const m=I.Ellipsoid.clone(e.ellipsoid);return{instances:i,ellipsoid:m,projection:e.isGeographic?new b.GeographicProjection(m):new F.WebMercatorProjection(m),elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:P.Matrix4.clone(e.modelMatrix),createPickOffsets:e.createPickOffsets}},G.packCombineGeometryResults=function(e,i){d.defined(e.geometries)&&function(s,m){const n=s.length;for(let f=0;f<n;++f)j(s[f],m)}(e.geometries,i);const t=M(e.boundingSpheres),r=M(e.boundingSpheresCV);return i.push(t.buffer,r.buffer),{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:t,boundingSpheresCV:r}},G.unpackCombineGeometryResults=function(e){return{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:v(e.boundingSpheres),boundingSpheresCV:v(e.boundingSpheresCV)}};var E=G;B.PrimitivePipeline=E});
