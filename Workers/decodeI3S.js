/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./createTaskProcessorWorker","./defaultValue-ebbd2e4d","./WebMercatorProjection-3d5b0545","./Matrix3-2955527a","./Math-1fe079f3"],function(ne,d,re,U,N){"use strict";let $;function T(n,i,t,r){return r[n+i*t]}function oe(n,i,t){const r=t.nativeExtent;let c=(n-r.west)/(r.east-r.west)*(t.width-1),o=(i-r.south)/(r.north-r.south)*(t.height-1);const e=Math.floor(c);let y=Math.floor(o);c-=e,o-=y;const l=e<t.width?e+1:e;let s=y<t.height?y+1:y;y=t.height-1-y,s=t.height-1-s;let a=function(f,u,p,b,w,x){return(p*(1-f)+b*f)*(1-u)+(w*(1-f)+x*f)*u}(c,o,T(e,y,t.width,t.buffer),T(l,y,t.width,t.buffer),T(e,s,t.width,t.buffer),T(l,s,t.width,t.buffer));return a=a*t.scale+t.offset,a}function ee(n,i,t){for(let r=0;r<t.length;r++){const c=t[r].nativeExtent;let o=new U.Cartesian3;if(t[r].projectionType==="WebMercator"){const e=t[r].projection._ellipsoid._radii;o=new re.WebMercatorProjection(new U.Ellipsoid(e.x,e.y,e.z)).project(new U.Cartographic(n,i,0))}else o.x=n,o.y=i;if(o.x>c.west&&o.x<c.east&&o.y>c.south&&o.y<c.north)return oe(o.x,o.y,t[r])}return 0}function ie(n,i,t,r){const c=new Uint8Array(n,0,5);return c[0]==="D".charCodeAt()&&c[1]==="R".charCodeAt()&&c[2]==="A".charCodeAt()&&c[3]==="C".charCodeAt()&&c[4]==="O".charCodeAt()?function(o){const e=$,y=new e.DecoderBuffer,l=new Uint8Array(o);y.Init(l,l.length);const s=new e.Decoder,a=s.GetEncodedGeometryType(y),f=new e.MetadataQuerier;let u,p;a===e.TRIANGULAR_MESH&&(u=new e.Mesh,p=s.DecodeBufferToMesh(y,u));const b={vertexCount:[0],featureCount:0};if(d.defined(p)&&p.ok()&&u.ptr!==0){const w=u.num_faces(),x=u.num_attributes(),A=u.num_points();b.indices=new Uint32Array(3*w);const L=b.indices;b.vertexCount[0]=A,b.scale_x=1,b.scale_y=1;const I=new e.DracoInt32Array(3);for(let g=0;g<w;++g)s.GetFaceFromMesh(u,g,I),L[3*g]=I.GetValue(0),L[3*g+1]=I.GetValue(1),L[3*g+2]=I.GetValue(2);e.destroy(I);for(let g=0;g<x;++g){const m=s.GetAttribute(u,g),V=ae(e,s,u,m,A),D=m.attribute_type();let C="unknown";D===e.POSITION?C="positions":D===e.NORMAL?C="normals":D===e.COLOR?C="colors":D===e.TEX_COORD&&(C="uv0s");const O=s.GetAttributeMetadata(u,g);if(O.ptr!==0){const M=f.NumEntries(O);for(let _=0;_<M;++_){const G=f.GetEntryName(O,_);G==="i3s-scale_x"?b.scale_x=f.GetDoubleEntry(O,"i3s-scale_x"):G==="i3s-scale_y"?b.scale_y=f.GetDoubleEntry(O,"i3s-scale_y"):G==="i3s-attribute-type"&&(C=f.GetStringEntry(O,"i3s-attribute-type"))}}d.defined(b[C])&&console.log("Attribute already exists",C),b[C]=V,C==="feature-index"&&b.featureCount++}e.destroy(u)}return e.destroy(f),e.destroy(s),b}(n):function(o,e,y,l){const s={vertexCount:0},a=new DataView(o);try{let f=0;if(s.vertexCount=a.getUint32(f,1),f+=4,s.featureCount=a.getUint32(f,1),f+=4,d.defined(y))for(let u=0;u<y.attributes.length;u++)d.defined(F[y.attributes[u]])?f=F[y.attributes[u]](s,o,f):console.error("Unknown decoder for",y.attributes[u]);else{let u=e.ordering,p=e.featureAttributeOrder;d.defined(l)&&d.defined(l.geometryData)&&d.defined(l.geometryData[0])&&d.defined(l.geometryData[0].params)&&(u=Object.keys(l.geometryData[0].params.vertexAttributes),p=Object.keys(l.geometryData[0].params.featureAttributes));for(let b=0;b<u.length;b++){const w=F[u[b]];d.defined(w)||console.log(u[b]),f=w(s,o,f)}for(let b=0;b<p.length;b++){const w=F[p[b]];d.defined(w)||console.log(p[b]),f=w(s,o,f)}}}catch(f){console.error(f)}return s.scale_x=1,s.scale_y=1,s}(n,i,t,r)}function ae(n,i,t,r,c){const o=r.num_components()*c;let e;const y=[function(){},function(){e=new n.DracoInt8Array(o),i.GetAttributeInt8ForAllPoints(t,r,e)||console.error("Bad stream");const s=new Int8Array(o);for(let a=0;a<o;++a)s[a]=e.GetValue(a);return s},function(){e=new n.DracoInt8Array(o),i.GetAttributeUInt8ForAllPoints(t,r,e)||console.error("Bad stream");const s=new Uint8Array(o);for(let a=0;a<o;++a)s[a]=e.GetValue(a);return s},function(){e=new n.DracoInt16Array(o),i.GetAttributeInt16ForAllPoints(t,r,e)||console.error("Bad stream");const s=new Int16Array(o);for(let a=0;a<o;++a)s[a]=e.GetValue(a);return s},function(){e=new n.DracoInt16Array(o),i.GetAttributeUInt16ForAllPoints(t,r,e)||console.error("Bad stream");const s=new Uint16Array(o);for(let a=0;a<o;++a)s[a]=e.GetValue(a);return s},function(){e=new n.DracoInt32Array(o),i.GetAttributeInt32ForAllPoints(t,r,e)||console.error("Bad stream");const s=new Int32Array(o);for(let a=0;a<o;++a)s[a]=e.GetValue(a);return s},function(){e=new n.DracoInt32Array(o),i.GetAttributeUInt32ForAllPoints(t,r,e)||console.error("Bad stream");const s=new Uint32Array(o);for(let a=0;a<o;++a)s[a]=e.GetValue(a);return s},function(){},function(){},function(){e=new n.DracoFloat32Array(o),i.GetAttributeFloatForAllPoints(t,r,e)||console.error("Bad stream");const s=new Float32Array(o);for(let a=0;a<o;++a)s[a]=e.GetValue(a);return s},function(){},function(){e=new n.DracoUInt8Array(o),i.GetAttributeUInt8ForAllPoints(t,r,e)||console.error("Bad stream");const s=new Uint8Array(o);for(let a=0;a<o;++a)s[a]=e.GetValue(a);return s}],l=y[r.data_type()]();return d.defined(e)&&n.destroy(e),l}const F={position:function(n,i,t){const r=3*n.vertexCount;return n.positions=new Float32Array(i,t,r),t+=4*r},normal:function(n,i,t){const r=3*n.vertexCount;return n.normals=new Float32Array(i,t,r),t+=4*r},uv0:function(n,i,t){const r=2*n.vertexCount;return n.uv0s=new Float32Array(i,t,r),t+=4*r},color:function(n,i,t){const r=4*n.vertexCount;return n.colors=new Uint8Array(i,t,r),t+=r},featureId:function(n,i,t){return t+=8*n.featureCount},id:function(n,i,t){return t+=8*n.featureCount},faceRange:function(n,i,t){const r=2*n.featureCount;return n.faceRange=new Uint32Array(i,t,r),t+=4*r},uvRegion:function(n,i,t){const r=4*n.vertexCount;return n["uv-region"]=new Uint16Array(i,t,r),t+=2*r},region:function(n,i,t){const r=4*n.vertexCount;return n["uv-region"]=new Uint16Array(i,t,r),t+=2*r}};function se(n){const i=ie(n.binaryData,n.schema,n.bufferInfo,n.featureData);d.defined(n.geoidDataList)&&n.geoidDataList.length>0&&function(c,o,e,y,l,s,a){if(a)return;const f=ee(l.longitude,l.latitude,s);for(let u=0;u<c;++u){const p=ee(l.longitude+N.CesiumMath.toRadians(e*o[3*u]),l.latitude+N.CesiumMath.toRadians(y*o[3*u+1]),s);o[3*u+2]+=p-f}}(i.vertexCount,i.positions,i.scale_x,i.scale_y,n.cartographicCenter,n.geoidDataList,!1),function(c,o,e,y,l,s,a,f,u){if(c===0||!d.defined(o)||o.length===0)return;const p=new U.Ellipsoid(Math.sqrt(a.x),Math.sqrt(a.y),Math.sqrt(a.z));for(let b=0;b<c;++b){const w=3*b,x=w+1,A=w+2,L=new U.Cartographic;L.longitude=y.longitude+N.CesiumMath.toRadians(f*o[w]),L.latitude=y.latitude+N.CesiumMath.toRadians(u*o[x]),L.height=y.height+o[A];const I={};p.cartographicToCartesian(L,I),I.x-=l.x,I.y-=l.y,I.z-=l.z;const g={};if(U.Matrix3.multiplyByVector(s,I,g),o[w]=g.x,o[x]=g.y,o[A]=g.z,d.defined(e)){const m=new U.Cartesian3(e[w],e[x],e[A]),V={};U.Matrix3.multiplyByVector(s,m,V),e[w]=V.x,e[x]=V.y,e[A]=V.z}}}(i.vertexCount,i.positions,i.normals,n.cartographicCenter,n.cartesianCenter,n.parentRotation,n.ellipsoidRadiiSquare,i.scale_x,i.scale_y);const t=function(c,o,e,y,l,s,a){if(c===0||!d.defined(e)||e.length===0)return{buffers:[],bufferViews:[],accessors:[],meshes:[],nodes:[],nodesInScene:[]};const f=[],u=[],p=[],b=[],w=[],x=[];d.defined(o)&&(c=o.length);const A=new Uint32Array(c);if(d.defined(o))for(let h=0;h<c;++h)A[h]=o[h];else for(let h=0;h<c;++h)A[h]=h;const L=new Blob([A],{type:"application/binary"}),I=URL.createObjectURL(L),g=c,m=e.subarray(0,3*g),V=new Blob([m],{type:"application/binary"}),D=URL.createObjectURL(V);let C=Number.POSITIVE_INFINITY,O=Number.NEGATIVE_INFINITY,M=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,G=Number.POSITIVE_INFINITY,X=Number.NEGATIVE_INFINITY;for(let h=0;h<m.length/3;h++)C=Math.min(C,m[3*h+0]),O=Math.max(O,m[3*h+0]),M=Math.min(M,m[3*h+1]),_=Math.max(_,m[3*h+1]),G=Math.min(G,m[3*h+2]),X=Math.max(X,m[3*h+2]);const B=y?y.subarray(0,3*g):void 0;let H;if(d.defined(B)){const h=new Blob([B],{type:"application/binary"});H=URL.createObjectURL(h)}const P=l?l.subarray(0,2*g):void 0;let Q;if(d.defined(P)){const h=new Blob([P],{type:"application/binary"});Q=URL.createObjectURL(h)}const j=d.defined(s)?s.subarray(0,4*g):void 0;let J;if(d.defined(j)){const h=new Blob([j],{type:"application/binary"});J=URL.createObjectURL(h)}const K=a?a.subarray(0,4*g):void 0;let Z,v;if(d.defined(K)){let h=K.length;v=new Float32Array(h);for(let W=0;W<h;++W)v[W]=K[W]/65535;const ue=new Blob([v],{type:"application/binary"});Z=URL.createObjectURL(ue)}let S=0,k=0,z=0,Y=0,q=0,R=0;const E={POSITION:0};return f.push({uri:D,byteLength:m.byteLength}),u.push({buffer:0,byteOffset:0,byteLength:m.byteLength,target:34962}),p.push({bufferView:0,byteOffset:0,componentType:5126,count:c,type:"VEC3",max:[C,M,G],min:[O,_,X]}),d.defined(H)&&(++R,S=R,E.NORMAL=S,f.push({uri:H,byteLength:B.byteLength}),u.push({buffer:S,byteOffset:0,byteLength:B.byteLength,target:34962}),p.push({bufferView:S,byteOffset:0,componentType:5126,count:c,type:"VEC3"})),d.defined(Q)&&(++R,k=R,E.TEXCOORD_0=k,f.push({uri:Q,byteLength:P.byteLength}),u.push({buffer:k,byteOffset:0,byteLength:P.byteLength,target:34962}),p.push({bufferView:k,byteOffset:0,componentType:5126,count:c,type:"VEC2"})),d.defined(J)&&(++R,z=R,E.COLOR_0=z,f.push({uri:J,byteLength:j.byteLength}),u.push({buffer:z,byteOffset:0,byteLength:j.byteLength,target:34962}),p.push({bufferView:z,byteOffset:0,componentType:5121,normalized:!0,count:c,type:"VEC4"})),d.defined(Z)&&(++R,q=R,E.TEXCOORDREGION_0=q,f.push({uri:Z,byteLength:v.byteLength}),u.push({buffer:q,byteOffset:0,byteLength:v.byteLength,target:34962}),p.push({bufferView:q,byteOffset:0,componentType:5126,count:c,type:"VEC4"})),++R,Y=R,f.push({uri:I,byteLength:A.byteLength}),u.push({buffer:Y,byteOffset:0,byteLength:A.byteLength,target:34963}),p.push({bufferView:Y,byteOffset:0,componentType:5125,count:c,type:"SCALAR"}),b.push({primitives:[{attributes:E,indices:Y,material:0}]}),x.push(0),w.push({mesh:0}),{buffers:f,bufferViews:u,accessors:p,meshes:b,nodes:w,nodesInScene:x}}(i.vertexCount,i.indices,i.positions,i.normals,i.uv0s,i.colors,i["uv-region"]),r={};if(d.defined(i["feature-index"]))r.positions=i.positions,r.indices=i.indices,r.featureIndex=i["feature-index"],r.cartesianCenter=n.cartesianCenter,r.parentRotation=n.parentRotation;else if(d.defined(i.faceRange)){r.positions=i.positions,r.indices=i.indices,r.sourceURL=n.url,r.cartesianCenter=n.cartesianCenter,r.parentRotation=n.parentRotation,r.featureIndex=new Array(i.positions.length);for(let c=0;c<i.faceRange.length-1;c+=2){const o=c/2,e=i.faceRange[c],y=i.faceRange[c+1];for(let l=e;l<=y;l++)r.featureIndex[3*l]=o,r.featureIndex[3*l+1]=o,r.featureIndex[3*l+2]=o}}return t._customAttributes=r,{meshData:t}}function te(n){$=n,self.onmessage=ne(se),self.postMessage(!0)}return function(n){const i=n.data.webAssemblyConfig;if(d.defined(i))return require([i.modulePath],function(t){d.defined(i.wasmBinaryFile)?(d.defined(t)||(t=self.DracoDecoderModule),t(i).then(function(r){te(r)})):te(t())})}});
