/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./AttributeCompression-6f93ad0c","./Transforms-5b74e989","./Matrix2-462b83d3","./Matrix3-2955527a","./defaultValue-ebbd2e4d","./TerrainEncoding-519593e1","./IndexDatatype-7ccfd280","./Math-1fe079f3","./OrientedBoundingBox-48eb7862","./createTaskProcessorWorker","./ComponentDatatype-f9ac3ed8","./WebGLConstants-544672c2","./combine-55e9f355","./RuntimeError-38a08050","./EllipsoidTangentPlane-da4fdd19","./AxisAlignedBoundingBox-a26a3fb6","./IntersectionTests-2a07bba4","./Plane-7e97483e"],function($,oe,J,A,v,he,ye,M,de,Ie,Ge,Je,Ze,je,qe,Qe,$e,et){"use strict";var ee={clipTriangleAtAxisAlignedThreshold:function(t,p,s,n,r,e){let c,w,u;v.defined(e)?e.length=0:e=[],p?(c=s<t,w=n<t,u=r<t):(c=s>t,w=n>t,u=r>t);const d=c+w+u;let h,a,o,C,y,I;return d===1?c?(h=(t-s)/(n-s),a=(t-s)/(r-s),e.push(1),e.push(2),a!==1&&(e.push(-1),e.push(0),e.push(2),e.push(a)),h!==1&&(e.push(-1),e.push(0),e.push(1),e.push(h))):w?(o=(t-n)/(r-n),C=(t-n)/(s-n),e.push(2),e.push(0),C!==1&&(e.push(-1),e.push(1),e.push(0),e.push(C)),o!==1&&(e.push(-1),e.push(1),e.push(2),e.push(o))):u&&(y=(t-r)/(s-r),I=(t-r)/(n-r),e.push(0),e.push(1),I!==1&&(e.push(-1),e.push(2),e.push(1),e.push(I)),y!==1&&(e.push(-1),e.push(2),e.push(0),e.push(y))):d===2?c||s===t?w||n===t?u||r===t||(a=(t-s)/(r-s),o=(t-n)/(r-n),e.push(2),e.push(-1),e.push(0),e.push(2),e.push(a),e.push(-1),e.push(1),e.push(2),e.push(o)):(I=(t-r)/(n-r),h=(t-s)/(n-s),e.push(1),e.push(-1),e.push(2),e.push(1),e.push(I),e.push(-1),e.push(0),e.push(1),e.push(h)):(C=(t-n)/(s-n),y=(t-r)/(s-r),e.push(0),e.push(-1),e.push(1),e.push(0),e.push(C),e.push(-1),e.push(2),e.push(0),e.push(y)):d!==3&&(e.push(0),e.push(1),e.push(2)),e},computeBarycentricCoordinates:function(t,p,s,n,r,e,c,w,u){const d=s-c,h=c-r,a=e-w,o=n-w,C=1/(a*d+h*o),y=p-w,I=t-c,R=(a*I+h*y)*C,z=(-o*I+d*y)*C,k=1-R-z;return v.defined(u)?(u.x=R,u.y=z,u.z=k,u):new A.Cartesian3(R,z,k)},computeLineSegmentLineSegmentIntersection:function(t,p,s,n,r,e,c,w,u){const d=(w-e)*(s-t)-(c-r)*(n-p);if(d===0)return;const h=((c-r)*(p-e)-(w-e)*(t-r))/d,a=((s-t)*(p-e)-(n-p)*(t-r))/d;return h>=0&&h<=1&&a>=0&&a<=1?(v.defined(u)||(u=new J.Cartesian2),u.x=t+h*(s-t),u.y=p+h*(n-p),u):void 0}};const f=32767,T=16383,Ae=[],pe=[],be=[],Z=new A.Cartographic;let N=new A.Cartesian3;const ve=[],Te=[],Me=[],ze=[],Ve=[],Ne=new A.Cartesian3,Ee=new oe.BoundingSphere,Re=new de.OrientedBoundingBox,He=new J.Cartesian2,Oe=new A.Cartesian3;function l(){this.vertexBuffer=void 0,this.index=void 0,this.first=void 0,this.second=void 0,this.ratio=void 0}l.prototype.clone=function(t){return v.defined(t)||(t=new l),t.uBuffer=this.uBuffer,t.vBuffer=this.vBuffer,t.heightBuffer=this.heightBuffer,t.normalBuffer=this.normalBuffer,t.index=this.index,t.first=this.first,t.second=this.second,t.ratio=this.ratio,t},l.prototype.initializeIndexed=function(t,p,s,n,r){this.uBuffer=t,this.vBuffer=p,this.heightBuffer=s,this.normalBuffer=n,this.index=r,this.first=void 0,this.second=void 0,this.ratio=void 0},l.prototype.initializeFromClipResult=function(t,p,s){let n=p+1;return t[p]!==-1?s[t[p]].clone(this):(this.vertexBuffer=void 0,this.index=void 0,this.first=s[t[n]],++n,this.second=s[t[n]],++n,this.ratio=t[n],++n),n},l.prototype.getKey=function(){return this.isIndexed()?this.index:JSON.stringify({first:this.first.getKey(),second:this.second.getKey(),ratio:this.ratio})},l.prototype.isIndexed=function(){return v.defined(this.index)},l.prototype.getH=function(){return v.defined(this.index)?this.heightBuffer[this.index]:M.CesiumMath.lerp(this.first.getH(),this.second.getH(),this.ratio)},l.prototype.getU=function(){return v.defined(this.index)?this.uBuffer[this.index]:M.CesiumMath.lerp(this.first.getU(),this.second.getU(),this.ratio)},l.prototype.getV=function(){return v.defined(this.index)?this.vBuffer[this.index]:M.CesiumMath.lerp(this.first.getV(),this.second.getV(),this.ratio)};let F=new J.Cartesian2,j=-1;const Pe=[new A.Cartesian3,new A.Cartesian3],Se=[new A.Cartesian3,new A.Cartesian3];function ae(t,p){++j;let s=Pe[j],n=Se[j];return s=$.AttributeCompression.octDecode(t.first.getNormalX(),t.first.getNormalY(),s),n=$.AttributeCompression.octDecode(t.second.getNormalX(),t.second.getNormalY(),n),N=A.Cartesian3.lerp(s,n,t.ratio,N),A.Cartesian3.normalize(N,N),$.AttributeCompression.octEncode(N,p),--j,p}l.prototype.getNormalX=function(){return v.defined(this.index)?this.normalBuffer[2*this.index]:(F=ae(this,F),F.x)},l.prototype.getNormalY=function(){return v.defined(this.index)?this.normalBuffer[2*this.index+1]:(F=ae(this,F),F.y)};const B=[];function le(t,p,s,n,r,e,c,w,u){if(c.length===0)return;let d=0,h=0;for(;h<c.length;)h=B[d++].initializeFromClipResult(c,h,w);for(let a=0;a<d;++a){const o=B[a];if(o.isIndexed())o.newIndex=e[o.index],o.uBuffer=t,o.vBuffer=p,o.heightBuffer=s,u&&(o.normalBuffer=n);else{const C=o.getKey();if(v.defined(e[C]))o.newIndex=e[C];else{const y=t.length;t.push(o.getU()),p.push(o.getV()),s.push(o.getH()),u&&(n.push(o.getNormalX()),n.push(o.getNormalY())),o.newIndex=y,e[C]=y}}}d===3?(r.push(B[0].newIndex),r.push(B[1].newIndex),r.push(B[2].newIndex)):d===4&&(r.push(B[0].newIndex),r.push(B[1].newIndex),r.push(B[2].newIndex),r.push(B[0].newIndex),r.push(B[2].newIndex),r.push(B[3].newIndex))}return B.push(new l),B.push(new l),B.push(new l),B.push(new l),Ie(function(t,p){const s=t.isEastChild,n=t.isNorthChild,r=s?T:0,e=s?f:T,c=n?T:0,w=n?f:T,u=ve,d=Te,h=Me,a=Ve;u.length=0,d.length=0,h.length=0,a.length=0;const o=ze;o.length=0;const C={},y=t.vertices;let I=t.indices;I=I.subarray(0,t.indexCountWithoutSkirts);const R=he.TerrainEncoding.clone(t.encoding),z=R.hasVertexNormals;let k=0;const K=t.vertexCountWithoutSkirts,te=t.minimumHeight,fe=t.maximumHeight,S=new Array(K),q=new Array(K),L=new Array(K),U=z?new Array(2*K):void 0;let E,i,D,g,m;for(i=0,D=0;i<K;++i,D+=2){const O=R.decodeTextureCoordinates(y,i,He);if(E=R.decodeHeight(y,i),g=M.CesiumMath.clamp(O.x*f|0,0,f),m=M.CesiumMath.clamp(O.y*f|0,0,f),L[i]=M.CesiumMath.clamp((E-te)/(fe-te)*f|0,0,f),g<20&&(g=0),m<20&&(m=0),f-g<20&&(g=f),f-m<20&&(m=f),S[i]=g,q[i]=m,z){const G=R.getOctEncodedNormal(y,i,Oe);U[D]=G.x,U[D+1]=G.y}(s&&g>=T||!s&&g<=T)&&(n&&m>=T||!n&&m<=T)&&(C[i]=k,u.push(g),d.push(m),h.push(L[i]),z&&(a.push(U[D]),a.push(U[D+1])),++k)}const V=[];V.push(new l),V.push(new l),V.push(new l);const x=[];let b,Q;for(x.push(new l),x.push(new l),x.push(new l),i=0;i<I.length;i+=3){const O=I[i],G=I[i+1],Be=I[i+2],Le=S[O],Ye=S[G],_e=S[Be];V[0].initializeIndexed(S,q,L,U,O),V[1].initializeIndexed(S,q,L,U,G),V[2].initializeIndexed(S,q,L,U,Be);const P=ee.clipTriangleAtAxisAlignedThreshold(T,s,Le,Ye,_e,Ae);b=0,b>=P.length||(b=x[0].initializeFromClipResult(P,b,V),b>=P.length||(b=x[1].initializeFromClipResult(P,b,V),b>=P.length||(b=x[2].initializeFromClipResult(P,b,V),Q=ee.clipTriangleAtAxisAlignedThreshold(T,n,x[0].getV(),x[1].getV(),x[2].getV(),pe),le(u,d,h,a,o,C,Q,x,z),b<P.length&&(x[2].clone(x[1]),x[2].initializeFromClipResult(P,b,V),Q=ee.clipTriangleAtAxisAlignedThreshold(T,n,x[0].getV(),x[1].getV(),x[2].getV(),pe),le(u,d,h,a,o,C,Q,x,z)))))}const Ue=s?-32767:0,Fe=n?-32767:0,ce=[],ge=[],me=[],xe=[];let H=Number.MAX_VALUE,Y=-H;const W=be;W.length=0;const ne=A.Ellipsoid.clone(t.ellipsoid),_=J.Rectangle.clone(t.childRectangle),De=_.north,We=_.south;let ie=_.east;const we=_.west;for(ie<we&&(ie+=M.CesiumMath.TWO_PI),i=0;i<u.length;++i)g=Math.round(u[i]),g<=r?(ce.push(i),g=0):g>=e?(me.push(i),g=f):g=2*g+Ue,u[i]=g,m=Math.round(d[i]),m<=c?(ge.push(i),m=0):m>=w?(xe.push(i),m=f):m=2*m+Fe,d[i]=m,E=M.CesiumMath.lerp(te,fe,h[i]/f),E<H&&(H=E),E>Y&&(Y=E),h[i]=E,Z.longitude=M.CesiumMath.lerp(we,ie,g/f),Z.latitude=M.CesiumMath.lerp(We,De,m/f),Z.height=E,ne.cartographicToCartesian(Z,N),W.push(N.x),W.push(N.y),W.push(N.z);const se=oe.BoundingSphere.fromVertices(W,A.Cartesian3.ZERO,3,Ee),Xe=de.OrientedBoundingBox.fromRectangle(_,H,Y,ne,Re),ke=new he.EllipsoidalOccluder(ne).computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid(se.center,W,3,se.center,H,Ne),Ke=Y-H,X=new Uint16Array(u.length+d.length+h.length);for(i=0;i<u.length;++i)X[i]=u[i];let re=u.length;for(i=0;i<d.length;++i)X[re+i]=d[i];for(re+=d.length,i=0;i<h.length;++i)X[re+i]=f*(h[i]-H)/Ke;const ue=ye.IndexDatatype.createTypedArray(u.length,o);let Ce;if(z){const O=new Uint8Array(a);p.push(X.buffer,ue.buffer,O.buffer),Ce=O.buffer}else p.push(X.buffer,ue.buffer);return{vertices:X.buffer,encodedNormals:Ce,indices:ue.buffer,minimumHeight:H,maximumHeight:Y,westIndices:ce,southIndices:ge,eastIndices:me,northIndices:xe,boundingSphere:se,orientedBoundingBox:Xe,horizonOcclusionPoint:ke}})});
