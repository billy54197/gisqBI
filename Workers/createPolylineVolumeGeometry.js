/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./defaultValue-ebbd2e4d","./Matrix3-2955527a","./arrayRemoveDuplicates-cadb0e8e","./BoundingRectangle-3be07fe8","./Transforms-5b74e989","./Matrix2-462b83d3","./ComponentDatatype-f9ac3ed8","./PolylineVolumeGeometryLibrary-65969b57","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryPipeline-3cfa9822","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolygonPipeline-4fdc8b4f","./VertexFormat-5b02b45a","./combine-55e9f355","./RuntimeError-38a08050","./WebGLConstants-544672c2","./EllipsoidTangentPlane-da4fdd19","./AxisAlignedBoundingBox-a26a3fb6","./IntersectionTests-2a07bba4","./Plane-7e97483e","./PolylinePipeline-0a87fb90","./EllipsoidGeodesic-7acc6014","./EllipsoidRhumbLine-8bc8a516","./AttributeCompression-6f93ad0c","./EncodedCartesian3-d4159969"],function(h,l,K,M,Y,C,U,R,w,j,q,z,Q,N,P,$,ee,te,ne,ae,re,ie,oe,le,se,pe,ce){"use strict";function v(e){const t=(e=h.defaultValue(e,h.defaultValue.EMPTY_OBJECT)).polylinePositions,n=e.shapePositions;this._positions=t,this._shape=n,this._ellipsoid=l.Ellipsoid.clone(h.defaultValue(e.ellipsoid,l.Ellipsoid.WGS84)),this._cornerType=h.defaultValue(e.cornerType,R.CornerType.ROUNDED),this._vertexFormat=P.VertexFormat.clone(h.defaultValue(e.vertexFormat,P.VertexFormat.DEFAULT)),this._granularity=h.defaultValue(e.granularity,Q.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let a=1+t.length*l.Cartesian3.packedLength;a+=1+n.length*C.Cartesian2.packedLength,this.packedLength=a+l.Ellipsoid.packedLength+P.VertexFormat.packedLength+2}v.pack=function(e,t,n){let a;n=h.defaultValue(n,0);const y=e._positions;let u=y.length;for(t[n++]=u,a=0;a<u;++a,n+=l.Cartesian3.packedLength)l.Cartesian3.pack(y[a],t,n);const d=e._shape;for(u=d.length,t[n++]=u,a=0;a<u;++a,n+=C.Cartesian2.packedLength)C.Cartesian2.pack(d[a],t,n);return l.Ellipsoid.pack(e._ellipsoid,t,n),n+=l.Ellipsoid.packedLength,P.VertexFormat.pack(e._vertexFormat,t,n),n+=P.VertexFormat.packedLength,t[n++]=e._cornerType,t[n]=e._granularity,t};const H=l.Ellipsoid.clone(l.Ellipsoid.UNIT_SPHERE),J=new P.VertexFormat,F={polylinePositions:void 0,shapePositions:void 0,ellipsoid:H,vertexFormat:J,cornerType:void 0,granularity:void 0};v.unpack=function(e,t,n){let a;t=h.defaultValue(t,0);let y=e[t++];const u=new Array(y);for(a=0;a<y;++a,t+=l.Cartesian3.packedLength)u[a]=l.Cartesian3.unpack(e,t);y=e[t++];const d=new Array(y);for(a=0;a<y;++a,t+=C.Cartesian2.packedLength)d[a]=C.Cartesian2.unpack(e,t);const B=l.Ellipsoid.unpack(e,t,H);t+=l.Ellipsoid.packedLength;const m=P.VertexFormat.unpack(e,t,J);t+=P.VertexFormat.packedLength;const V=e[t++],i=e[t];return h.defined(n)?(n._positions=u,n._shape=d,n._ellipsoid=l.Ellipsoid.clone(B,n._ellipsoid),n._vertexFormat=P.VertexFormat.clone(m,n._vertexFormat),n._cornerType=V,n._granularity=i,n):(F.polylinePositions=u,F.shapePositions=d,F.cornerType=V,F.granularity=i,new v(F))};const X=new M.BoundingRectangle;return v.createGeometry=function(e){const t=e._positions,n=K.arrayRemoveDuplicates(t,l.Cartesian3.equalsEpsilon);let a=e._shape;if(a=R.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(a),n.length<2||a.length<3)return;N.PolygonPipeline.computeWindingOrder2D(a)===N.WindingOrder.CLOCKWISE&&a.reverse();const y=M.BoundingRectangle.fromPoints(a,X);return function(u,d,B,m){const V=new j.GeometryAttributes;m.position&&(V.position=new w.GeometryAttribute({componentDatatype:U.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:u}));const i=d.length,S=u.length/3,A=(S-2*i)/(2*i),T=N.PolygonPipeline.triangulate(d),Z=(A-1)*i*6+2*T.length,r=z.IndexDatatype.createTypedArray(S,Z);let c,p,b,x,L,I;const O=2*i;let o=0;for(c=0;c<A-1;c++){for(p=0;p<i-1;p++)b=2*p+c*i*2,I=b+O,x=b+1,L=x+O,r[o++]=x,r[o++]=b,r[o++]=L,r[o++]=L,r[o++]=b,r[o++]=I;b=2*i-2+c*i*2,x=b+1,L=x+O,I=b+O,r[o++]=x,r[o++]=b,r[o++]=L,r[o++]=L,r[o++]=b,r[o++]=I}if(m.st||m.tangent||m.bitangent){const s=new Float32Array(2*S),G=1/(A-1),k=1/B.height,D=B.height/2;let E,f,g=0;for(c=0;c<A;c++){for(E=c*G,f=k*(d[0].y+D),s[g++]=E,s[g++]=f,p=1;p<i;p++)f=k*(d[p].y+D),s[g++]=E,s[g++]=f,s[g++]=E,s[g++]=f;f=k*(d[0].y+D),s[g++]=E,s[g++]=f}for(p=0;p<i;p++)E=0,f=k*(d[p].y+D),s[g++]=E,s[g++]=f;for(p=0;p<i;p++)E=(A-1)*G,f=k*(d[p].y+D),s[g++]=E,s[g++]=f;V.st=new w.GeometryAttribute({componentDatatype:U.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(s)})}const W=S-2*i;for(c=0;c<T.length;c+=3){const s=T[c]+W,G=T[c+1]+W,k=T[c+2]+W;r[o++]=s,r[o++]=G,r[o++]=k,r[o++]=k+i,r[o++]=G+i,r[o++]=s+i}let _=new w.Geometry({attributes:V,indices:r,boundingSphere:Y.BoundingSphere.fromVertices(u),primitiveType:w.PrimitiveType.TRIANGLES});if(m.normal&&(_=q.GeometryPipeline.computeNormal(_)),m.tangent||m.bitangent){try{_=q.GeometryPipeline.computeTangentAndBitangent(_)}catch{R.oneTimeWarning("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}m.tangent||(_.attributes.tangent=void 0),m.bitangent||(_.attributes.bitangent=void 0),m.st||(_.attributes.st=void 0)}return _}(R.PolylineVolumeGeometryLibrary.computePositions(n,a,y,e,!0),a,y,e._vertexFormat)},function(e,t){return h.defined(t)&&(e=v.unpack(e,t)),e._ellipsoid=l.Ellipsoid.clone(e._ellipsoid),v.createGeometry(e)}});
