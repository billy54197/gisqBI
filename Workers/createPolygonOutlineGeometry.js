/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./defaultValue-ebbd2e4d","./Matrix3-2955527a","./ArcType-efd92361","./Transforms-5b74e989","./ComponentDatatype-f9ac3ed8","./EllipsoidTangentPlane-da4fdd19","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryInstance-4ef1b8a5","./GeometryOffsetAttribute-739bec2c","./GeometryPipeline-3cfa9822","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolygonGeometryLibrary-e1e72ec4","./PolygonPipeline-4fdc8b4f","./Matrix2-462b83d3","./RuntimeError-38a08050","./combine-55e9f355","./WebGLConstants-544672c2","./AxisAlignedBoundingBox-a26a3fb6","./IntersectionTests-2a07bba4","./Plane-7e97483e","./AttributeCompression-6f93ad0c","./EncodedCartesian3-d4159969","./arrayRemoveDuplicates-cadb0e8e","./EllipsoidRhumbLine-8bc8a516"],function(p,g,E,S,T,x,A,O,D,C,R,I,H,m,L,B,U,W,F,z,Y,j,K,q,J,Q){"use strict";const w=[],v=[];function k(i,t,r,b,y){const h=x.EllipsoidTangentPlane.fromPoints(t,i).projectPointsOntoPlane(t,w);let o,e;L.PolygonPipeline.computeWindingOrder2D(h)===L.WindingOrder.CLOCKWISE&&(h.reverse(),t=t.slice().reverse());let n=t.length,s=0;if(b)for(o=new Float64Array(2*n*3),e=0;e<n;e++){const d=t[e],a=t[(e+1)%n];o[s++]=d.x,o[s++]=d.y,o[s++]=d.z,o[s++]=a.x,o[s++]=a.y,o[s++]=a.z}else{let d=0;if(y===E.ArcType.GEODESIC)for(e=0;e<n;e++)d+=m.PolygonGeometryLibrary.subdivideLineCount(t[e],t[(e+1)%n],r);else if(y===E.ArcType.RHUMB)for(e=0;e<n;e++)d+=m.PolygonGeometryLibrary.subdivideRhumbLineCount(i,t[e],t[(e+1)%n],r);for(o=new Float64Array(3*d),e=0;e<n;e++){let a;y===E.ArcType.GEODESIC?a=m.PolygonGeometryLibrary.subdivideLine(t[e],t[(e+1)%n],r,v):y===E.ArcType.RHUMB&&(a=m.PolygonGeometryLibrary.subdivideRhumbLine(i,t[e],t[(e+1)%n],r,v));const u=a.length;for(let f=0;f<u;++f)o[s++]=a[f]}}n=o.length/3;const l=2*n,c=I.IndexDatatype.createTypedArray(n,l);for(s=0,e=0;e<n-1;e++)c[s++]=e,c[s++]=e+1;return c[s++]=n-1,c[s++]=0,new D.GeometryInstance({geometry:new A.Geometry({attributes:new O.GeometryAttributes({position:new A.GeometryAttribute({componentDatatype:T.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:o})}),indices:c,primitiveType:A.PrimitiveType.LINES})})}function M(i,t,r,b,y){const h=x.EllipsoidTangentPlane.fromPoints(t,i).projectPointsOntoPlane(t,w);let o,e;L.PolygonPipeline.computeWindingOrder2D(h)===L.WindingOrder.CLOCKWISE&&(h.reverse(),t=t.slice().reverse());let n=t.length;const s=new Array(n);let l=0;if(b)for(o=new Float64Array(2*n*3*2),e=0;e<n;++e){s[e]=l/3;const u=t[e],f=t[(e+1)%n];o[l++]=u.x,o[l++]=u.y,o[l++]=u.z,o[l++]=f.x,o[l++]=f.y,o[l++]=f.z}else{let u=0;if(y===E.ArcType.GEODESIC)for(e=0;e<n;e++)u+=m.PolygonGeometryLibrary.subdivideLineCount(t[e],t[(e+1)%n],r);else if(y===E.ArcType.RHUMB)for(e=0;e<n;e++)u+=m.PolygonGeometryLibrary.subdivideRhumbLineCount(i,t[e],t[(e+1)%n],r);for(o=new Float64Array(3*u*2),e=0;e<n;++e){let f;s[e]=l/3,y===E.ArcType.GEODESIC?f=m.PolygonGeometryLibrary.subdivideLine(t[e],t[(e+1)%n],r,v):y===E.ArcType.RHUMB&&(f=m.PolygonGeometryLibrary.subdivideRhumbLine(i,t[e],t[(e+1)%n],r,v));const G=f.length;for(let P=0;P<G;++P)o[l++]=f[P]}}n=o.length/6;const c=s.length,d=2*(2*n+c),a=I.IndexDatatype.createTypedArray(n+c,d);for(l=0,e=0;e<n;++e)a[l++]=e,a[l++]=(e+1)%n,a[l++]=e+n,a[l++]=(e+1)%n+n;for(e=0;e<c;e++){const u=s[e];a[l++]=u,a[l++]=u+n}return new D.GeometryInstance({geometry:new A.Geometry({attributes:new O.GeometryAttributes({position:new A.GeometryAttribute({componentDatatype:T.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:o})}),indices:a,primitiveType:A.PrimitiveType.LINES})})}function _(i){const t=i.polygonHierarchy,r=p.defaultValue(i.ellipsoid,g.Ellipsoid.WGS84),b=p.defaultValue(i.granularity,H.CesiumMath.RADIANS_PER_DEGREE),y=p.defaultValue(i.perPositionHeight,!1),h=y&&p.defined(i.extrudedHeight),o=p.defaultValue(i.arcType,E.ArcType.GEODESIC);let e=p.defaultValue(i.height,0),n=p.defaultValue(i.extrudedHeight,e);if(!h){const s=Math.max(e,n);n=Math.min(e,n),e=s}this._ellipsoid=g.Ellipsoid.clone(r),this._granularity=b,this._height=e,this._extrudedHeight=n,this._arcType=o,this._polygonHierarchy=t,this._perPositionHeight=y,this._perPositionHeightExtrude=h,this._offsetAttribute=i.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=m.PolygonGeometryLibrary.computeHierarchyPackedLength(t,g.Cartesian3)+g.Ellipsoid.packedLength+8}_.pack=function(i,t,r){return r=p.defaultValue(r,0),r=m.PolygonGeometryLibrary.packPolygonHierarchy(i._polygonHierarchy,t,r,g.Cartesian3),g.Ellipsoid.pack(i._ellipsoid,t,r),r+=g.Ellipsoid.packedLength,t[r++]=i._height,t[r++]=i._extrudedHeight,t[r++]=i._granularity,t[r++]=i._perPositionHeightExtrude?1:0,t[r++]=i._perPositionHeight?1:0,t[r++]=i._arcType,t[r++]=p.defaultValue(i._offsetAttribute,-1),t[r]=i.packedLength,t};const N=g.Ellipsoid.clone(g.Ellipsoid.UNIT_SPHERE),V={polygonHierarchy:{}};return _.unpack=function(i,t,r){t=p.defaultValue(t,0);const b=m.PolygonGeometryLibrary.unpackPolygonHierarchy(i,t,g.Cartesian3);t=b.startingIndex,delete b.startingIndex;const y=g.Ellipsoid.unpack(i,t,N);t+=g.Ellipsoid.packedLength;const h=i[t++],o=i[t++],e=i[t++],n=i[t++]===1,s=i[t++]===1,l=i[t++],c=i[t++],d=i[t];return p.defined(r)||(r=new _(V)),r._polygonHierarchy=b,r._ellipsoid=g.Ellipsoid.clone(y,r._ellipsoid),r._height=h,r._extrudedHeight=o,r._granularity=e,r._perPositionHeight=s,r._perPositionHeightExtrude=n,r._arcType=l,r._offsetAttribute=c===-1?void 0:c,r.packedLength=d,r},_.fromPositions=function(i){return new _({polygonHierarchy:{positions:(i=p.defaultValue(i,p.defaultValue.EMPTY_OBJECT)).positions},height:i.height,extrudedHeight:i.extrudedHeight,ellipsoid:i.ellipsoid,granularity:i.granularity,perPositionHeight:i.perPositionHeight,arcType:i.arcType,offsetAttribute:i.offsetAttribute})},_.createGeometry=function(i){const t=i._ellipsoid,r=i._granularity,b=i._polygonHierarchy,y=i._perPositionHeight,h=i._arcType,o=m.PolygonGeometryLibrary.polygonOutlinesFromHierarchy(b,!y,t);if(o.length===0)return;let e;const n=[],s=H.CesiumMath.chordLength(r,t.maximumRadius),l=i._height,c=i._extrudedHeight;let d,a;if(i._perPositionHeightExtrude||!H.CesiumMath.equalsEpsilon(l,c,0,H.CesiumMath.EPSILON2))for(a=0;a<o.length;a++){if(e=M(t,o[a],s,y,h),e.geometry=m.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(e.geometry,l,c,t,y),p.defined(i._offsetAttribute)){const G=e.geometry.attributes.position.values.length/3;let P=new Uint8Array(G);i._offsetAttribute===C.GeometryOffsetAttribute.TOP?P=P.fill(1,0,G/2):(d=i._offsetAttribute===C.GeometryOffsetAttribute.NONE?0:1,P=P.fill(d)),e.geometry.attributes.applyOffset=new A.GeometryAttribute({componentDatatype:T.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:P})}n.push(e)}else for(a=0;a<o.length;a++){if(e=k(t,o[a],s,y,h),e.geometry.attributes.position.values=L.PolygonPipeline.scaleToGeodeticHeight(e.geometry.attributes.position.values,l,t,!y),p.defined(i._offsetAttribute)){const G=e.geometry.attributes.position.values.length;d=i._offsetAttribute===C.GeometryOffsetAttribute.NONE?0:1;const P=new Uint8Array(G/3).fill(d);e.geometry.attributes.applyOffset=new A.GeometryAttribute({componentDatatype:T.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:P})}n.push(e)}const u=R.GeometryPipeline.combineInstances(n)[0],f=S.BoundingSphere.fromVertices(u.attributes.position.values);return new A.Geometry({attributes:u.attributes,indices:u.indices,primitiveType:u.primitiveType,boundingSphere:f,offsetAttribute:i._offsetAttribute})},function(i,t){return p.defined(t)&&(i=_.unpack(i,t)),i._ellipsoid=g.Ellipsoid.clone(i._ellipsoid),_.createGeometry(i)}});
