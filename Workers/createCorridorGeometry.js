/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./arrayRemoveDuplicates-cadb0e8e","./Transforms-5b74e989","./Matrix3-2955527a","./ComponentDatatype-f9ac3ed8","./PolylineVolumeGeometryLibrary-65969b57","./CorridorGeometryLibrary-95558a86","./defaultValue-ebbd2e4d","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryOffsetAttribute-739bec2c","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolygonPipeline-4fdc8b4f","./Matrix2-462b83d3","./VertexFormat-5b02b45a","./combine-55e9f355","./RuntimeError-38a08050","./WebGLConstants-544672c2","./EllipsoidTangentPlane-da4fdd19","./AxisAlignedBoundingBox-a26a3fb6","./IntersectionTests-2a07bba4","./Plane-7e97483e","./PolylinePipeline-0a87fb90","./EllipsoidGeodesic-7acc6014","./EllipsoidRhumbLine-8bc8a516"],function(ht,Pt,e,ot,ct,M,L,at,Ft,pt,bt,st,yt,Ct,tt,Dt,Ot,It,St,Rt,kt,Ht,zt,Bt,Ut){"use strict";const At=new e.Cartesian3,_t=new e.Cartesian3,mt=new e.Cartesian3,ft=new e.Cartesian3,Mt=new e.Cartesian3,wt=new e.Cartesian3,nt=new e.Cartesian3,lt=new e.Cartesian3;function vt(t,a){for(let i=0;i<t.length;i++)t[i]=a.scaleToGeodeticSurface(t[i],t[i]);return t}function et(t,a,i,n,s,c){const V=t.normals,G=t.tangents,h=t.bitangents,p=e.Cartesian3.normalize(e.Cartesian3.cross(i,a,nt),nt);c.normal&&M.CorridorGeometryLibrary.addAttribute(V,a,n,s),c.tangent&&M.CorridorGeometryLibrary.addAttribute(G,p,n,s),c.bitangent&&M.CorridorGeometryLibrary.addAttribute(h,i,n,s)}function Tt(t,a,i){const n=t.positions,s=t.corners,c=t.endPositions,V=t.lefts,G=t.normals,h=new Ft.GeometryAttributes;let p,r,l,y=0,d=0,N=0;for(r=0;r<n.length;r+=2)l=n[r].length-3,y+=l,N+=2*l,d+=n[r+1].length-3;for(y+=3,d+=3,r=0;r<s.length;r++){p=s[r];const o=s[r].leftPositions;L.defined(o)?(l=o.length,y+=l,N+=l):(l=s[r].rightPositions.length,d+=l,N+=l)}const W=L.defined(c);let S;W&&(S=c[0].length-3,y+=S,d+=S,S/=3,N+=6*S);const $=y+d,b=new Float64Array($),R={normals:a.normal?new Float32Array($):void 0,tangents:a.tangent?new Float32Array($):void 0,bitangents:a.bitangent?new Float32Array($):void 0};let q,B,k,O,m,u,v=0,C=$-1,T=At,A=_t;const U=S/2,g=bt.IndexDatatype.createTypedArray($/3,N);let _=0;if(W){u=mt,m=ft;const o=c[0];for(T=e.Cartesian3.fromArray(G,0,T),A=e.Cartesian3.fromArray(V,0,A),r=0;r<U;r++)u=e.Cartesian3.fromArray(o,3*(U-1-r),u),m=e.Cartesian3.fromArray(o,3*(U+r),m),M.CorridorGeometryLibrary.addAttribute(b,m,v),M.CorridorGeometryLibrary.addAttribute(b,u,void 0,C),et(R,T,A,v,C,a),B=v/3,O=B+1,q=(C-2)/3,k=q-1,g[_++]=q,g[_++]=B,g[_++]=k,g[_++]=k,g[_++]=B,g[_++]=O,v+=3,C-=3}let E,P,F=0,I=0,J=n[F++],D=n[F++];for(b.set(J,v),b.set(D,C-D.length+1),A=e.Cartesian3.fromArray(V,I,A),l=D.length-3,r=0;r<l;r+=3)E=i.geodeticSurfaceNormal(e.Cartesian3.fromArray(J,r,nt),nt),P=i.geodeticSurfaceNormal(e.Cartesian3.fromArray(D,l-r,lt),lt),T=e.Cartesian3.normalize(e.Cartesian3.add(E,P,T),T),et(R,T,A,v,C,a),B=v/3,O=B+1,q=(C-2)/3,k=q-1,g[_++]=q,g[_++]=B,g[_++]=k,g[_++]=k,g[_++]=B,g[_++]=O,v+=3,C-=3;for(E=i.geodeticSurfaceNormal(e.Cartesian3.fromArray(J,l,nt),nt),P=i.geodeticSurfaceNormal(e.Cartesian3.fromArray(D,l,lt),lt),T=e.Cartesian3.normalize(e.Cartesian3.add(E,P,T),T),I+=3,r=0;r<s.length;r++){let o;p=s[r];const H=p.leftPositions,Y=p.rightPositions;let w,x,f=wt,z=mt,Q=ft;if(T=e.Cartesian3.fromArray(G,I,T),L.defined(H)){for(et(R,T,A,void 0,C,a),C-=3,w=O,x=k,o=0;o<H.length/3;o++)f=e.Cartesian3.fromArray(H,3*o,f),g[_++]=w,g[_++]=x-o-1,g[_++]=x-o,M.CorridorGeometryLibrary.addAttribute(b,f,void 0,C),z=e.Cartesian3.fromArray(b,3*(x-o-1),z),Q=e.Cartesian3.fromArray(b,3*w,Q),A=e.Cartesian3.normalize(e.Cartesian3.subtract(z,Q,A),A),et(R,T,A,void 0,C,a),C-=3;f=e.Cartesian3.fromArray(b,3*w,f),z=e.Cartesian3.subtract(e.Cartesian3.fromArray(b,3*x,z),f,z),Q=e.Cartesian3.subtract(e.Cartesian3.fromArray(b,3*(x-o),Q),f,Q),A=e.Cartesian3.normalize(e.Cartesian3.add(z,Q,A),A),et(R,T,A,v,void 0,a),v+=3}else{for(et(R,T,A,v,void 0,a),v+=3,w=k,x=O,o=0;o<Y.length/3;o++)f=e.Cartesian3.fromArray(Y,3*o,f),g[_++]=w,g[_++]=x+o,g[_++]=x+o+1,M.CorridorGeometryLibrary.addAttribute(b,f,v),z=e.Cartesian3.fromArray(b,3*w,z),Q=e.Cartesian3.fromArray(b,3*(x+o),Q),A=e.Cartesian3.normalize(e.Cartesian3.subtract(z,Q,A),A),et(R,T,A,v,void 0,a),v+=3;f=e.Cartesian3.fromArray(b,3*w,f),z=e.Cartesian3.subtract(e.Cartesian3.fromArray(b,3*(x+o),z),f,z),Q=e.Cartesian3.subtract(e.Cartesian3.fromArray(b,3*x,Q),f,Q),A=e.Cartesian3.normalize(e.Cartesian3.negate(e.Cartesian3.add(Q,z,A),A),A),et(R,T,A,void 0,C,a),C-=3}for(J=n[F++],D=n[F++],J.splice(0,3),D.splice(D.length-3,3),b.set(J,v),b.set(D,C-D.length+1),l=D.length-3,I+=3,A=e.Cartesian3.fromArray(V,I,A),o=0;o<D.length;o+=3)E=i.geodeticSurfaceNormal(e.Cartesian3.fromArray(J,o,nt),nt),P=i.geodeticSurfaceNormal(e.Cartesian3.fromArray(D,l-o,lt),lt),T=e.Cartesian3.normalize(e.Cartesian3.add(E,P,T),T),et(R,T,A,v,C,a),O=v/3,B=O-1,k=(C-2)/3,q=k+1,g[_++]=q,g[_++]=B,g[_++]=k,g[_++]=k,g[_++]=B,g[_++]=O,v+=3,C-=3;v-=3,C+=3}if(T=e.Cartesian3.fromArray(G,G.length-3,T),et(R,T,A,v,C,a),W){v+=3,C-=3,u=mt,m=ft;const o=c[1];for(r=0;r<U;r++)u=e.Cartesian3.fromArray(o,3*(S-r-1),u),m=e.Cartesian3.fromArray(o,3*r,m),M.CorridorGeometryLibrary.addAttribute(b,u,void 0,C),M.CorridorGeometryLibrary.addAttribute(b,m,v),et(R,T,A,v,C,a),O=v/3,B=O-1,k=(C-2)/3,q=k+1,g[_++]=q,g[_++]=B,g[_++]=k,g[_++]=k,g[_++]=B,g[_++]=O,v+=3,C-=3}if(h.position=new at.GeometryAttribute({componentDatatype:ot.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:b}),a.st){const o=new Float32Array($/3*2);let H,Y,w=0;if(W){y/=3,d/=3;const x=Math.PI/(S+1);let f;Y=1/(y-S+1),H=1/(d-S+1);const z=S/2;for(r=z+1;r<S+1;r++)f=st.CesiumMath.PI_OVER_TWO+x*r,o[w++]=H*(1+Math.cos(f)),o[w++]=.5*(1+Math.sin(f));for(r=1;r<d-S+1;r++)o[w++]=r*H,o[w++]=0;for(r=S;r>z;r--)f=st.CesiumMath.PI_OVER_TWO-r*x,o[w++]=1-H*(1+Math.cos(f)),o[w++]=.5*(1+Math.sin(f));for(r=z;r>0;r--)f=st.CesiumMath.PI_OVER_TWO-x*r,o[w++]=1-Y*(1+Math.cos(f)),o[w++]=.5*(1+Math.sin(f));for(r=y-S;r>0;r--)o[w++]=r*Y,o[w++]=1;for(r=1;r<z+1;r++)f=st.CesiumMath.PI_OVER_TWO+x*r,o[w++]=Y*(1+Math.cos(f)),o[w++]=.5*(1+Math.sin(f))}else{for(y/=3,d/=3,Y=1/(y-1),H=1/(d-1),r=0;r<d;r++)o[w++]=r*H,o[w++]=0;for(r=y;r>0;r--)o[w++]=(r-1)*Y,o[w++]=1}h.st=new at.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:o})}return a.normal&&(h.normal=new at.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R.normals})),a.tangent&&(h.tangent=new at.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R.tangents})),a.bitangent&&(h.bitangent=new at.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R.bitangents})),{attributes:h,indices:g}}function gt(t,a,i){i[a++]=t[0],i[a++]=t[1],i[a++]=t[2];for(let n=3;n<t.length;n+=3){const s=t[n],c=t[n+1],V=t[n+2];i[a++]=s,i[a++]=c,i[a++]=V,i[a++]=s,i[a++]=c,i[a++]=V}return i[a++]=t[0],i[a++]=t[1],i[a++]=t[2],i}function Nt(t,a){const i=new tt.VertexFormat({position:a.position,normal:a.normal||a.bitangent||t.shadowVolume,tangent:a.tangent,bitangent:a.normal||a.bitangent,st:a.st}),n=t.ellipsoid,s=Tt(M.CorridorGeometryLibrary.computePositions(t),i,n),c=t.height,V=t.extrudedHeight;let G=s.attributes;const h=s.indices;let p=G.position.values,r=p.length;const l=new Float64Array(6*r);let y=new Float64Array(r);y.set(p);let d,N=new Float64Array(4*r);p=yt.PolygonPipeline.scaleToGeodeticHeight(p,c,n),N=gt(p,0,N),y=yt.PolygonPipeline.scaleToGeodeticHeight(y,V,n),N=gt(y,2*r,N),l.set(p),l.set(y,r),l.set(N,2*r),G.position.values=l,G=function(m,u){if(!(u.normal||u.tangent||u.bitangent||u.st))return m;const v=m.position.values;let C,T;(u.normal||u.bitangent)&&(C=m.normal.values,T=m.bitangent.values);const A=m.position.values.length/18,U=3*A,g=2*A,_=2*U;let E;if(u.normal||u.bitangent||u.tangent){const P=u.normal?new Float32Array(6*U):void 0,F=u.tangent?new Float32Array(6*U):void 0,I=u.bitangent?new Float32Array(6*U):void 0;let J=At,D=_t,o=mt,H=ft,Y=Mt,w=wt,x=_;for(E=0;E<U;E+=3){const f=x+_;J=e.Cartesian3.fromArray(v,E,J),D=e.Cartesian3.fromArray(v,E+U,D),o=e.Cartesian3.fromArray(v,(E+3)%U,o),D=e.Cartesian3.subtract(D,J,D),o=e.Cartesian3.subtract(o,J,o),H=e.Cartesian3.normalize(e.Cartesian3.cross(D,o,H),H),u.normal&&(M.CorridorGeometryLibrary.addAttribute(P,H,f),M.CorridorGeometryLibrary.addAttribute(P,H,f+3),M.CorridorGeometryLibrary.addAttribute(P,H,x),M.CorridorGeometryLibrary.addAttribute(P,H,x+3)),(u.tangent||u.bitangent)&&(w=e.Cartesian3.fromArray(C,E,w),u.bitangent&&(M.CorridorGeometryLibrary.addAttribute(I,w,f),M.CorridorGeometryLibrary.addAttribute(I,w,f+3),M.CorridorGeometryLibrary.addAttribute(I,w,x),M.CorridorGeometryLibrary.addAttribute(I,w,x+3)),u.tangent&&(Y=e.Cartesian3.normalize(e.Cartesian3.cross(w,H,Y),Y),M.CorridorGeometryLibrary.addAttribute(F,Y,f),M.CorridorGeometryLibrary.addAttribute(F,Y,f+3),M.CorridorGeometryLibrary.addAttribute(F,Y,x),M.CorridorGeometryLibrary.addAttribute(F,Y,x+3))),x+=6}if(u.normal){for(P.set(C),E=0;E<U;E+=3)P[E+U]=-C[E],P[E+U+1]=-C[E+1],P[E+U+2]=-C[E+2];m.normal.values=P}else m.normal=void 0;if(u.bitangent?(I.set(T),I.set(T,U),m.bitangent.values=I):m.bitangent=void 0,u.tangent){const f=m.tangent.values;F.set(f),F.set(f,U),m.tangent.values=F}}if(u.st){const P=m.st.values,F=new Float32Array(6*g);F.set(P),F.set(P,g);let I=2*g;for(let J=0;J<2;J++){for(F[I++]=P[0],F[I++]=P[1],E=2;E<g;E+=2){const D=P[E],o=P[E+1];F[I++]=D,F[I++]=o,F[I++]=D,F[I++]=o}F[I++]=P[0],F[I++]=P[1]}m.st.values=F}return m}(G,a);const W=r/3;if(t.shadowVolume){const m=G.normal.values;r=m.length;let u=new Float32Array(6*r);for(d=0;d<r;d++)m[d]=-m[d];u.set(m,r),u=gt(m,4*r,u),G.extrudeDirection=new at.GeometryAttribute({componentDatatype:ot.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:u}),a.normal||(G.normal=void 0)}if(L.defined(t.offsetAttribute)){let m=new Uint8Array(6*W);if(t.offsetAttribute===pt.GeometryOffsetAttribute.TOP)m=m.fill(1,0,W).fill(1,2*W,4*W);else{const u=t.offsetAttribute===pt.GeometryOffsetAttribute.NONE?0:1;m=m.fill(u)}G.applyOffset=new at.GeometryAttribute({componentDatatype:ot.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:m})}const S=h.length,$=W+W,b=bt.IndexDatatype.createTypedArray(l.length/3,2*S+3*$);b.set(h);let R,q,B,k,O=S;for(d=0;d<S;d+=3){const m=h[d],u=h[d+1],v=h[d+2];b[O++]=v+W,b[O++]=u+W,b[O++]=m+W}for(d=0;d<$;d+=2)R=d+$,q=R+$,B=R+1,k=q+1,b[O++]=R,b[O++]=q,b[O++]=B,b[O++]=B,b[O++]=q,b[O++]=k;return{attributes:G,indices:b}}const Gt=new e.Cartesian3,dt=new e.Cartesian3,X=new e.Cartographic;function Et(t,a,i,n,s,c){const V=e.Cartesian3.subtract(a,t,Gt);e.Cartesian3.normalize(V,V);const G=i.geodeticSurfaceNormal(t,dt),h=e.Cartesian3.cross(V,G,Gt);e.Cartesian3.multiplyByScalar(h,n,h);let p=s.latitude,r=s.longitude,l=c.latitude,y=c.longitude;e.Cartesian3.add(t,h,dt),i.cartesianToCartographic(dt,X);let d=X.latitude,N=X.longitude;p=Math.min(p,d),r=Math.min(r,N),l=Math.max(l,d),y=Math.max(y,N),e.Cartesian3.subtract(t,h,dt),i.cartesianToCartographic(dt,X),d=X.latitude,N=X.longitude,p=Math.min(p,d),r=Math.min(r,N),l=Math.max(l,d),y=Math.max(y,N),s.latitude=p,s.longitude=r,c.latitude=l,c.longitude=y}const Z=new e.Cartesian3,ut=new e.Cartesian3,j=new e.Cartographic,K=new e.Cartographic;function Vt(t,a,i,n,s){t=vt(t,a);const c=ht.arrayRemoveDuplicates(t,e.Cartesian3.equalsEpsilon),V=c.length;if(V<2||i<=0)return new Ct.Rectangle;const G=.5*i;let h,p;if(j.latitude=Number.POSITIVE_INFINITY,j.longitude=Number.POSITIVE_INFINITY,K.latitude=Number.NEGATIVE_INFINITY,K.longitude=Number.NEGATIVE_INFINITY,n===ct.CornerType.ROUNDED){const y=c[0];e.Cartesian3.subtract(y,c[1],Z),e.Cartesian3.normalize(Z,Z),e.Cartesian3.multiplyByScalar(Z,G,Z),e.Cartesian3.add(y,Z,ut),a.cartesianToCartographic(ut,X),h=X.latitude,p=X.longitude,j.latitude=Math.min(j.latitude,h),j.longitude=Math.min(j.longitude,p),K.latitude=Math.max(K.latitude,h),K.longitude=Math.max(K.longitude,p)}for(let y=0;y<V-1;++y)Et(c[y],c[y+1],a,G,j,K);const r=c[V-1];e.Cartesian3.subtract(r,c[V-2],Z),e.Cartesian3.normalize(Z,Z),e.Cartesian3.multiplyByScalar(Z,G,Z),e.Cartesian3.add(r,Z,ut),Et(r,ut,a,G,j,K),n===ct.CornerType.ROUNDED&&(a.cartesianToCartographic(ut,X),h=X.latitude,p=X.longitude,j.latitude=Math.min(j.latitude,h),j.longitude=Math.min(j.longitude,p),K.latitude=Math.max(K.latitude,h),K.longitude=Math.max(K.longitude,p));const l=L.defined(s)?s:new Ct.Rectangle;return l.north=K.latitude,l.south=j.latitude,l.east=K.longitude,l.west=j.longitude,l}function rt(t){const a=(t=L.defaultValue(t,L.defaultValue.EMPTY_OBJECT)).positions,i=t.width,n=L.defaultValue(t.height,0),s=L.defaultValue(t.extrudedHeight,n);this._positions=a,this._ellipsoid=e.Ellipsoid.clone(L.defaultValue(t.ellipsoid,e.Ellipsoid.WGS84)),this._vertexFormat=tt.VertexFormat.clone(L.defaultValue(t.vertexFormat,tt.VertexFormat.DEFAULT)),this._width=i,this._height=Math.max(n,s),this._extrudedHeight=Math.min(n,s),this._cornerType=L.defaultValue(t.cornerType,ct.CornerType.ROUNDED),this._granularity=L.defaultValue(t.granularity,st.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=L.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+a.length*e.Cartesian3.packedLength+e.Ellipsoid.packedLength+tt.VertexFormat.packedLength+7}rt.pack=function(t,a,i){i=L.defaultValue(i,0);const n=t._positions,s=n.length;a[i++]=s;for(let c=0;c<s;++c,i+=e.Cartesian3.packedLength)e.Cartesian3.pack(n[c],a,i);return e.Ellipsoid.pack(t._ellipsoid,a,i),i+=e.Ellipsoid.packedLength,tt.VertexFormat.pack(t._vertexFormat,a,i),i+=tt.VertexFormat.packedLength,a[i++]=t._width,a[i++]=t._height,a[i++]=t._extrudedHeight,a[i++]=t._cornerType,a[i++]=t._granularity,a[i++]=t._shadowVolume?1:0,a[i]=L.defaultValue(t._offsetAttribute,-1),a};const xt=e.Ellipsoid.clone(e.Ellipsoid.UNIT_SPHERE),Lt=new tt.VertexFormat,it={positions:void 0,ellipsoid:xt,vertexFormat:Lt,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return rt.unpack=function(t,a,i){a=L.defaultValue(a,0);const n=t[a++],s=new Array(n);for(let N=0;N<n;++N,a+=e.Cartesian3.packedLength)s[N]=e.Cartesian3.unpack(t,a);const c=e.Ellipsoid.unpack(t,a,xt);a+=e.Ellipsoid.packedLength;const V=tt.VertexFormat.unpack(t,a,Lt);a+=tt.VertexFormat.packedLength;const G=t[a++],h=t[a++],p=t[a++],r=t[a++],l=t[a++],y=t[a++]===1,d=t[a];return L.defined(i)?(i._positions=s,i._ellipsoid=e.Ellipsoid.clone(c,i._ellipsoid),i._vertexFormat=tt.VertexFormat.clone(V,i._vertexFormat),i._width=G,i._height=h,i._extrudedHeight=p,i._cornerType=r,i._granularity=l,i._shadowVolume=y,i._offsetAttribute=d===-1?void 0:d,i):(it.positions=s,it.width=G,it.height=h,it.extrudedHeight=p,it.cornerType=r,it.granularity=l,it.shadowVolume=y,it.offsetAttribute=d===-1?void 0:d,new rt(it))},rt.computeRectangle=function(t,a){const i=(t=L.defaultValue(t,L.defaultValue.EMPTY_OBJECT)).positions,n=t.width;return Vt(i,L.defaultValue(t.ellipsoid,e.Ellipsoid.WGS84),n,L.defaultValue(t.cornerType,ct.CornerType.ROUNDED),a)},rt.createGeometry=function(t){let a=t._positions;const i=t._width,n=t._ellipsoid;a=vt(a,n);const s=ht.arrayRemoveDuplicates(a,e.Cartesian3.equalsEpsilon);if(s.length<2||i<=0)return;const c=t._height,V=t._extrudedHeight,G=!st.CesiumMath.equalsEpsilon(c,V,0,st.CesiumMath.EPSILON2),h=t._vertexFormat,p={ellipsoid:n,positions:s,width:i,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!0};let r;if(G)p.height=c,p.extrudedHeight=V,p.shadowVolume=t._shadowVolume,p.offsetAttribute=t._offsetAttribute,r=Nt(p,h);else if(r=Tt(M.CorridorGeometryLibrary.computePositions(p),h,n),r.attributes.position.values=yt.PolygonPipeline.scaleToGeodeticHeight(r.attributes.position.values,c,n),L.defined(t._offsetAttribute)){const d=t._offsetAttribute===pt.GeometryOffsetAttribute.NONE?0:1,N=r.attributes.position.values.length,W=new Uint8Array(N/3).fill(d);r.attributes.applyOffset=new at.GeometryAttribute({componentDatatype:ot.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:W})}const l=r.attributes,y=Pt.BoundingSphere.fromVertices(l.position.values,void 0,3);return h.position||(r.attributes.position.values=void 0),new at.Geometry({attributes:l,indices:r.indices,primitiveType:at.PrimitiveType.TRIANGLES,boundingSphere:y,offsetAttribute:t._offsetAttribute})},rt.createShadowVolume=function(t,a,i){const n=t._granularity,s=t._ellipsoid,c=a(n,s),V=i(n,s);return new rt({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:s,granularity:n,extrudedHeight:c,height:V,vertexFormat:tt.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(rt.prototype,{rectangle:{get:function(){return L.defined(this._rectangle)||(this._rectangle=Vt(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,a){return L.defined(a)&&(t=rt.unpack(t,a)),t._ellipsoid=e.Ellipsoid.clone(t._ellipsoid),rt.createGeometry(t)}});
