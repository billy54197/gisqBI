/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./defaultValue-ebbd2e4d","./Matrix3-2955527a","./ArcType-efd92361","./arrayRemoveDuplicates-cadb0e8e","./Transforms-5b74e989","./Color-3cef7e8d","./ComponentDatatype-f9ac3ed8","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolylinePipeline-0a87fb90","./VertexFormat-5b02b45a","./Matrix2-462b83d3","./RuntimeError-38a08050","./combine-55e9f355","./WebGLConstants-544672c2","./EllipsoidGeodesic-7acc6014","./EllipsoidRhumbLine-8bc8a516","./IntersectionTests-2a07bba4","./Plane-7e97483e"],function(p,i,O,ne,ae,y,v,_,ie,re,q,R,b,ue,ye,me,fe,he,Ce,ge,_e){"use strict";const z=[];function le(e,n,t,o,l){const s=z;let c;s.length=l;const A=t.red,d=t.green,a=t.blue,m=t.alpha,E=o.red,r=o.green,u=o.blue,P=o.alpha;if(y.Color.equals(t,o)){for(c=0;c<l;c++)s[c]=y.Color.clone(t);return s}const S=(E-A)/l,B=(r-d)/l,M=(u-a)/l,F=(P-m)/l;for(c=0;c<l;c++)s[c]=new y.Color(A+c*S,d+c*B,a+c*M,m+c*F);return s}function L(e){const n=(e=p.defaultValue(e,p.defaultValue.EMPTY_OBJECT)).positions,t=e.colors,o=p.defaultValue(e.width,1),l=p.defaultValue(e.colorsPerVertex,!1);this._positions=n,this._colors=t,this._width=o,this._colorsPerVertex=l,this._vertexFormat=b.VertexFormat.clone(p.defaultValue(e.vertexFormat,b.VertexFormat.DEFAULT)),this._arcType=p.defaultValue(e.arcType,O.ArcType.GEODESIC),this._granularity=p.defaultValue(e.granularity,q.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=i.Ellipsoid.clone(p.defaultValue(e.ellipsoid,i.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let s=1+n.length*i.Cartesian3.packedLength;s+=p.defined(t)?1+t.length*y.Color.packedLength:1,this.packedLength=s+i.Ellipsoid.packedLength+b.VertexFormat.packedLength+4}L.pack=function(e,n,t){let o;t=p.defaultValue(t,0);const l=e._positions;let s=l.length;for(n[t++]=s,o=0;o<s;++o,t+=i.Cartesian3.packedLength)i.Cartesian3.pack(l[o],n,t);const c=e._colors;for(s=p.defined(c)?c.length:0,n[t++]=s,o=0;o<s;++o,t+=y.Color.packedLength)y.Color.pack(c[o],n,t);return i.Ellipsoid.pack(e._ellipsoid,n,t),t+=i.Ellipsoid.packedLength,b.VertexFormat.pack(e._vertexFormat,n,t),t+=b.VertexFormat.packedLength,n[t++]=e._width,n[t++]=e._colorsPerVertex?1:0,n[t++]=e._arcType,n[t]=e._granularity,n};const J=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),j=new b.VertexFormat,T={positions:void 0,colors:void 0,ellipsoid:J,vertexFormat:j,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};L.unpack=function(e,n,t){let o;n=p.defaultValue(n,0);let l=e[n++];const s=new Array(l);for(o=0;o<l;++o,n+=i.Cartesian3.packedLength)s[o]=i.Cartesian3.unpack(e,n);l=e[n++];const c=l>0?new Array(l):void 0;for(o=0;o<l;++o,n+=y.Color.packedLength)c[o]=y.Color.unpack(e,n);const A=i.Ellipsoid.unpack(e,n,J);n+=i.Ellipsoid.packedLength;const d=b.VertexFormat.unpack(e,n,j);n+=b.VertexFormat.packedLength;const a=e[n++],m=e[n++]===1,E=e[n++],r=e[n];return p.defined(t)?(t._positions=s,t._colors=c,t._ellipsoid=i.Ellipsoid.clone(A,t._ellipsoid),t._vertexFormat=b.VertexFormat.clone(d,t._vertexFormat),t._width=a,t._colorsPerVertex=m,t._arcType=E,t._granularity=r,t):(T.positions=s,T.colors=c,T.width=a,T.colorsPerVertex=m,T.arcType=E,T.granularity=r,new L(T))};const K=new i.Cartesian3,Q=new i.Cartesian3,X=new i.Cartesian3,Z=new i.Cartesian3;return L.createGeometry=function(e){const n=e._width,t=e._vertexFormat;let o=e._colors;const l=e._colorsPerVertex,s=e._arcType,c=e._granularity,A=e._ellipsoid;let d,a,m;const E=[];let r=ne.arrayRemoveDuplicates(e._positions,i.Cartesian3.equalsEpsilon,!1,E);if(p.defined(o)&&E.length>0){let h=0,C=E[0];o=o.filter(function(I,x){let g=!1;return g=l?x===C||x===0&&C===1:x+1===C,!g||(h++,C=E[h],!1)})}let u=r.length;if(u<2||n<=0)return;if(s===O.ArcType.GEODESIC||s===O.ArcType.RHUMB){let h,C;s===O.ArcType.GEODESIC?(h=q.CesiumMath.chordLength(c,A.maximumRadius),C=R.PolylinePipeline.numberOfPoints):(h=c,C=R.PolylinePipeline.numberOfPointsRhumbLine);const I=R.PolylinePipeline.extractHeights(r,A);if(p.defined(o)){let x=1;for(d=0;d<u-1;++d)x+=C(r[d],r[d+1],h);const g=new Array(x);let Y=0;for(d=0;d<u-1;++d){const ce=r[d],pe=r[d+1],ee=o[d],te=C(ce,pe,h);if(l&&d<x){const oe=le(0,0,ee,o[d+1],te),de=oe.length;for(a=0;a<de;++a)g[Y++]=oe[a]}else for(a=0;a<te;++a)g[Y++]=y.Color.clone(ee)}g[Y]=y.Color.clone(o[o.length-1]),o=g,z.length=0}r=s===O.ArcType.GEODESIC?R.PolylinePipeline.generateCartesianArc({positions:r,minDistance:h,ellipsoid:A,height:I}):R.PolylinePipeline.generateCartesianRhumbArc({positions:r,granularity:h,ellipsoid:A,height:I})}u=r.length;const P=4*u-4,S=new Float64Array(3*P),B=new Float64Array(3*P),M=new Float64Array(3*P),F=new Float32Array(2*P),H=t.st?new Float32Array(2*P):void 0,w=p.defined(o)?new Uint8Array(4*P):void 0;let f,U=0,W=0,$=0,N=0;for(a=0;a<u;++a){let h,C;a===0?(f=K,i.Cartesian3.subtract(r[0],r[1],f),i.Cartesian3.add(r[0],f,f)):f=r[a-1],i.Cartesian3.clone(f,X),i.Cartesian3.clone(r[a],Q),a===u-1?(f=K,i.Cartesian3.subtract(r[u-1],r[u-2],f),i.Cartesian3.add(r[u-1],f,f)):f=r[a+1],i.Cartesian3.clone(f,Z),p.defined(w)&&(h=a===0||l?o[a]:o[a-1],a!==u-1&&(C=o[a]));const I=a===u-1?2:4;for(m=a===0?2:0;m<I;++m){i.Cartesian3.pack(Q,S,U),i.Cartesian3.pack(X,B,U),i.Cartesian3.pack(Z,M,U),U+=3;const x=m-2<0?-1:1;if(F[W++]=m%2*2-1,F[W++]=x*n,t.st&&(H[$++]=a/(u-1),H[$++]=Math.max(F[W-2],0)),p.defined(w)){const g=m<2?h:C;w[N++]=y.Color.floatToByte(g.red),w[N++]=y.Color.floatToByte(g.green),w[N++]=y.Color.floatToByte(g.blue),w[N++]=y.Color.floatToByte(g.alpha)}}}const D=new ie.GeometryAttributes;D.position=new _.GeometryAttribute({componentDatatype:v.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:S}),D.prevPosition=new _.GeometryAttribute({componentDatatype:v.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:B}),D.nextPosition=new _.GeometryAttribute({componentDatatype:v.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:M}),D.expandAndWidth=new _.GeometryAttribute({componentDatatype:v.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:F}),t.st&&(D.st=new _.GeometryAttribute({componentDatatype:v.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:H})),p.defined(w)&&(D.color=new _.GeometryAttribute({componentDatatype:v.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:w,normalize:!0}));const k=re.IndexDatatype.createTypedArray(P,6*u-6);let V=0,G=0;const se=u-1;for(a=0;a<se;++a)k[G++]=V,k[G++]=V+2,k[G++]=V+1,k[G++]=V+1,k[G++]=V+2,k[G++]=V+3,V+=4;return new _.Geometry({attributes:D,indices:k,primitiveType:_.PrimitiveType.TRIANGLES,boundingSphere:ae.BoundingSphere.fromPoints(r),geometryType:_.GeometryType.POLYLINES})},function(e,n){return p.defined(n)&&(e=L.unpack(e,n)),e._ellipsoid=i.Ellipsoid.clone(e._ellipsoid),L.createGeometry(e)}});
