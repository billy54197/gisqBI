/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["exports","./Matrix3-2955527a","./defaultValue-ebbd2e4d","./EllipsoidGeodesic-7acc6014","./EllipsoidRhumbLine-8bc8a516","./IntersectionTests-2a07bba4","./Math-1fe079f3","./Matrix2-462b83d3","./Plane-7e97483e"],function(O,n,w,B,I,U,x,A,b){"use strict";const d={numberOfPoints:function(t,i,r){const a=n.Cartesian3.distance(t,i);return Math.ceil(a/r)},numberOfPointsRhumbLine:function(t,i,r){const a=Math.pow(t.longitude-i.longitude,2)+Math.pow(t.latitude-i.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(a/(r*r))))}},v=new n.Cartographic;d.extractHeights=function(t,i){const r=t.length,a=new Array(r);for(let e=0;e<r;e++){const c=t[e];a[e]=i.cartesianToCartographic(c,v).height}return a};const z=new A.Matrix4,X=new n.Cartesian3,V=new n.Cartesian3,q=new b.Plane(n.Cartesian3.UNIT_X,0),k=new n.Cartesian3,W=new b.Plane(n.Cartesian3.UNIT_X,0),Y=new n.Cartesian3,H=new n.Cartesian3,D=[];function L(t,i,r){const a=D;let e;if(a.length=t,i===r){for(e=0;e<t;e++)a[e]=i;return a}const c=(r-i)/t;for(e=0;e<t;e++){const h=i+e*c;a[e]=h}return a}const R=new n.Cartographic,S=new n.Cartographic,y=new n.Cartesian3,N=new n.Cartesian3,Z=new n.Cartesian3,G=new B.EllipsoidGeodesic;let M=new I.EllipsoidRhumbLine;function j(t,i,r,a,e,c,h,o){const g=a.scaleToGeodeticSurface(t,N),p=a.scaleToGeodeticSurface(i,Z),l=d.numberOfPoints(t,i,r),C=a.cartesianToCartographic(g,R),P=a.cartesianToCartographic(p,S),f=L(l,e,c);G.setEndPoints(C,P);const m=G.surfaceDistance/l;let s=o;C.height=e;let u=a.cartographicToCartesian(C,y);n.Cartesian3.pack(u,h,s),s+=3;for(let T=1;T<l;T++){const E=G.interpolateUsingSurfaceDistance(T*m,S);E.height=f[T],u=a.cartographicToCartesian(E,y),n.Cartesian3.pack(u,h,s),s+=3}return s}function F(t,i,r,a,e,c,h,o){const g=a.cartesianToCartographic(t,R),p=a.cartesianToCartographic(i,S),l=d.numberOfPointsRhumbLine(g,p,r);g.height=0,p.height=0;const C=L(l,e,c);M.ellipsoid.equals(a)||(M=new I.EllipsoidRhumbLine(void 0,void 0,a)),M.setEndPoints(g,p);const P=M.surfaceDistance/l;let f=o;g.height=e;let m=a.cartographicToCartesian(g,y);n.Cartesian3.pack(m,h,f),f+=3;for(let s=1;s<l;s++){const u=M.interpolateUsingSurfaceDistance(s*P,S);u.height=C[s],m=a.cartographicToCartesian(u,y),n.Cartesian3.pack(m,h,f),f+=3}return f}d.wrapLongitude=function(t,i){const r=[],a=[];if(w.defined(t)&&t.length>0){i=w.defaultValue(i,A.Matrix4.IDENTITY);const e=A.Matrix4.inverseTransformation(i,z),c=A.Matrix4.multiplyByPoint(e,n.Cartesian3.ZERO,X),h=n.Cartesian3.normalize(A.Matrix4.multiplyByPointAsVector(e,n.Cartesian3.UNIT_Y,V),V),o=b.Plane.fromPointNormal(c,h,q),g=n.Cartesian3.normalize(A.Matrix4.multiplyByPointAsVector(e,n.Cartesian3.UNIT_X,k),k),p=b.Plane.fromPointNormal(c,g,W);let l=1;r.push(n.Cartesian3.clone(t[0]));let C=r[0];const P=t.length;for(let f=1;f<P;++f){const m=t[f];if(b.Plane.getPointDistance(p,C)<0||b.Plane.getPointDistance(p,m)<0){const s=U.IntersectionTests.lineSegmentPlane(C,m,o,Y);if(w.defined(s)){const u=n.Cartesian3.multiplyByScalar(h,5e-9,H);b.Plane.getPointDistance(o,C)<0&&n.Cartesian3.negate(u,u),r.push(n.Cartesian3.add(s,u,new n.Cartesian3)),a.push(l+1),n.Cartesian3.negate(u,u),r.push(n.Cartesian3.add(s,u,new n.Cartesian3)),l=1}}r.push(n.Cartesian3.clone(t[f])),l++,C=m}a.push(l)}return{positions:r,lengths:a}},d.generateArc=function(t){w.defined(t)||(t={});const i=t.positions,r=i.length,a=w.defaultValue(t.ellipsoid,n.Ellipsoid.WGS84);let e=w.defaultValue(t.height,0);const c=Array.isArray(e);if(r<1)return[];if(r===1){const s=a.scaleToGeodeticSurface(i[0],N);if(e=c?e[0]:e,e!==0){const u=a.geodeticSurfaceNormal(s,y);n.Cartesian3.multiplyByScalar(u,e,u),n.Cartesian3.add(s,u,s)}return[s.x,s.y,s.z]}let h=t.minDistance;if(!w.defined(h)){const s=w.defaultValue(t.granularity,x.CesiumMath.RADIANS_PER_DEGREE);h=x.CesiumMath.chordLength(s,a.maximumRadius)}let o,g=0;for(o=0;o<r-1;o++)g+=d.numberOfPoints(i[o],i[o+1],h);const p=3*(g+1),l=new Array(p);let C=0;for(o=0;o<r-1;o++)C=j(i[o],i[o+1],h,a,c?e[o]:e,c?e[o+1]:e,l,C);D.length=0;const P=i[r-1],f=a.cartesianToCartographic(P,R);f.height=c?e[r-1]:e;const m=a.cartographicToCartesian(f,y);return n.Cartesian3.pack(m,l,p-3),l};const _=new n.Cartographic,J=new n.Cartographic;d.generateRhumbArc=function(t){w.defined(t)||(t={});const i=t.positions,r=i.length,a=w.defaultValue(t.ellipsoid,n.Ellipsoid.WGS84);let e=w.defaultValue(t.height,0);const c=Array.isArray(e);if(r<1)return[];if(r===1){const T=a.scaleToGeodeticSurface(i[0],N);if(e=c?e[0]:e,e!==0){const E=a.geodeticSurfaceNormal(T,y);n.Cartesian3.multiplyByScalar(E,e,E),n.Cartesian3.add(T,E,T)}return[T.x,T.y,T.z]}const h=w.defaultValue(t.granularity,x.CesiumMath.RADIANS_PER_DEGREE);let o,g,p=0,l=a.cartesianToCartographic(i[0],_);for(o=0;o<r-1;o++)g=a.cartesianToCartographic(i[o+1],J),p+=d.numberOfPointsRhumbLine(l,g,h),l=n.Cartographic.clone(g,_);const C=3*(p+1),P=new Array(C);let f=0;for(o=0;o<r-1;o++)f=F(i[o],i[o+1],h,a,c?e[o]:e,c?e[o+1]:e,P,f);D.length=0;const m=i[r-1],s=a.cartesianToCartographic(m,R);s.height=c?e[r-1]:e;const u=a.cartographicToCartesian(s,y);return n.Cartesian3.pack(u,P,C-3),P},d.generateCartesianArc=function(t){const i=d.generateArc(t),r=i.length/3,a=new Array(r);for(let e=0;e<r;e++)a[e]=n.Cartesian3.unpack(i,3*e);return a},d.generateCartesianRhumbArc=function(t){const i=d.generateRhumbArc(t),r=i.length/3,a=new Array(r);for(let e=0;e<r;e++)a[e]=n.Cartesian3.unpack(i,3*e);return a};var K=d;O.PolylinePipeline=K});
