/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./defaultValue-ebbd2e4d","./Matrix3-2955527a","./Transforms-5b74e989","./ComponentDatatype-f9ac3ed8","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./IndexDatatype-7ccfd280","./Math-1fe079f3","./VertexFormat-5b02b45a","./WallGeometryLibrary-9216ba24","./Matrix2-462b83d3","./RuntimeError-38a08050","./combine-55e9f355","./WebGLConstants-544672c2","./arrayRemoveDuplicates-cadb0e8e","./PolylinePipeline-0a87fb90","./EllipsoidGeodesic-7acc6014","./EllipsoidRhumbLine-8bc8a516","./IntersectionTests-2a07bba4","./Plane-7e97483e"],function(s,t,X,T,x,$,ee,B,g,te,me,le,ue,ce,pe,de,ye,fe,ge,he){"use strict";const U=new t.Cartesian3,M=new t.Cartesian3,ne=new t.Cartesian3,Z=new t.Cartesian3,ie=new t.Cartesian3,ae=new t.Cartesian3,oe=new t.Cartesian3;function b(e){const i=(e=s.defaultValue(e,s.defaultValue.EMPTY_OBJECT)).positions,o=e.maximumHeights,a=e.minimumHeights,n=s.defaultValue(e.vertexFormat,g.VertexFormat.DEFAULT),m=s.defaultValue(e.granularity,B.CesiumMath.RADIANS_PER_DEGREE),l=s.defaultValue(e.ellipsoid,t.Ellipsoid.WGS84);this._positions=i,this._minimumHeights=a,this._maximumHeights=o,this._vertexFormat=g.VertexFormat.clone(n),this._granularity=m,this._ellipsoid=t.Ellipsoid.clone(l),this._workerName="createWallGeometry";let r=1+i.length*t.Cartesian3.packedLength+2;s.defined(a)&&(r+=a.length),s.defined(o)&&(r+=o.length),this.packedLength=r+t.Ellipsoid.packedLength+g.VertexFormat.packedLength+1}b.pack=function(e,i,o){let a;o=s.defaultValue(o,0);const n=e._positions;let m=n.length;for(i[o++]=m,a=0;a<m;++a,o+=t.Cartesian3.packedLength)t.Cartesian3.pack(n[a],i,o);const l=e._minimumHeights;if(m=s.defined(l)?l.length:0,i[o++]=m,s.defined(l))for(a=0;a<m;++a)i[o++]=l[a];const r=e._maximumHeights;if(m=s.defined(r)?r.length:0,i[o++]=m,s.defined(r))for(a=0;a<m;++a)i[o++]=r[a];return t.Ellipsoid.pack(e._ellipsoid,i,o),o+=t.Ellipsoid.packedLength,g.VertexFormat.pack(e._vertexFormat,i,o),i[o+=g.VertexFormat.packedLength]=e._granularity,i};const j=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),K=new g.VertexFormat,z={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:j,vertexFormat:K,granularity:void 0};return b.unpack=function(e,i,o){let a;i=s.defaultValue(i,0);let n=e[i++];const m=new Array(n);for(a=0;a<n;++a,i+=t.Cartesian3.packedLength)m[a]=t.Cartesian3.unpack(e,i);let l,r;if(n=e[i++],n>0)for(l=new Array(n),a=0;a<n;++a)l[a]=e[i++];if(n=e[i++],n>0)for(r=new Array(n),a=0;a<n;++a)r[a]=e[i++];const A=t.Ellipsoid.unpack(e,i,j);i+=t.Ellipsoid.packedLength;const p=g.VertexFormat.unpack(e,i,K),O=e[i+=g.VertexFormat.packedLength];return s.defined(o)?(o._positions=m,o._minimumHeights=l,o._maximumHeights=r,o._ellipsoid=t.Ellipsoid.clone(A,o._ellipsoid),o._vertexFormat=g.VertexFormat.clone(p,o._vertexFormat),o._granularity=O,o):(z.positions=m,z.minimumHeights=l,z.maximumHeights=r,z.granularity=O,new b(z))},b.fromConstantHeights=function(e){const i=(e=s.defaultValue(e,s.defaultValue.EMPTY_OBJECT)).positions;let o,a;const n=e.minimumHeight,m=e.maximumHeight,l=s.defined(n),r=s.defined(m);if(l||r){const A=i.length;o=l?new Array(A):void 0,a=r?new Array(A):void 0;for(let p=0;p<A;++p)l&&(o[p]=n),r&&(a[p]=m)}return new b({positions:i,maximumHeights:a,minimumHeights:o,ellipsoid:e.ellipsoid,vertexFormat:e.vertexFormat})},b.createGeometry=function(e){const i=e._positions,o=e._minimumHeights,a=e._maximumHeights,n=e._vertexFormat,m=e._granularity,l=e._ellipsoid,r=te.WallGeometryLibrary.computePositions(l,i,a,o,m,!0);if(!s.defined(r))return;const A=r.bottomPositions,p=r.topPositions,O=r.numCorners;let R=p.length,C=2*R;const d=n.position?new Float64Array(C):void 0,_=n.normal?new Float32Array(C):void 0,E=n.tangent?new Float32Array(C):void 0,w=n.bitangent?new Float32Array(C):void 0,S=n.st?new Float32Array(C/3*2):void 0;let u,L=0,V=0,k=0,H=0,N=0,y=oe,f=ae,h=ie,q=!0;R/=3;let J=0;const re=1/(R-O-1);for(u=0;u<R;++u){const v=3*u,c=t.Cartesian3.fromArray(p,v,U),I=t.Cartesian3.fromArray(A,v,M);if(n.position&&(d[L++]=I.x,d[L++]=I.y,d[L++]=I.z,d[L++]=c.x,d[L++]=c.y,d[L++]=c.z),n.st&&(S[N++]=J,S[N++]=0,S[N++]=J,S[N++]=1),n.normal||n.tangent||n.bitangent){let P=t.Cartesian3.clone(t.Cartesian3.ZERO,Z);const Y=t.Cartesian3.subtract(c,l.geodeticSurfaceNormal(c,M),M);if(u+1<R&&(P=t.Cartesian3.fromArray(p,v+3,Z)),q){const W=t.Cartesian3.subtract(P,c,ne),se=t.Cartesian3.subtract(Y,c,U);y=t.Cartesian3.normalize(t.Cartesian3.cross(se,W,y),y),q=!1}t.Cartesian3.equalsEpsilon(c,P,B.CesiumMath.EPSILON10)?q=!0:(J+=re,n.tangent&&(f=t.Cartesian3.normalize(t.Cartesian3.subtract(P,c,f),f)),n.bitangent&&(h=t.Cartesian3.normalize(t.Cartesian3.cross(y,f,h),h))),n.normal&&(_[V++]=y.x,_[V++]=y.y,_[V++]=y.z,_[V++]=y.x,_[V++]=y.y,_[V++]=y.z),n.tangent&&(E[H++]=f.x,E[H++]=f.y,E[H++]=f.z,E[H++]=f.x,E[H++]=f.y,E[H++]=f.z),n.bitangent&&(w[k++]=h.x,w[k++]=h.y,w[k++]=h.z,w[k++]=h.x,w[k++]=h.y,w[k++]=h.z)}}const G=new $.GeometryAttributes;n.position&&(G.position=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:d})),n.normal&&(G.normal=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:_})),n.tangent&&(G.tangent=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:E})),n.bitangent&&(G.bitangent=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:w})),n.st&&(G.st=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:S}));const Q=C/3;C-=6*(O+1);const F=ee.IndexDatatype.createTypedArray(Q,C);let D=0;for(u=0;u<Q-2;u+=2){const v=u,c=u+2,I=t.Cartesian3.fromArray(d,3*v,U),P=t.Cartesian3.fromArray(d,3*c,M);if(t.Cartesian3.equalsEpsilon(I,P,B.CesiumMath.EPSILON10))continue;const Y=u+1,W=u+3;F[D++]=Y,F[D++]=v,F[D++]=W,F[D++]=W,F[D++]=v,F[D++]=c}return new x.Geometry({attributes:G,indices:F,primitiveType:x.PrimitiveType.TRIANGLES,boundingSphere:new X.BoundingSphere.fromVertices(d)})},function(e,i){return s.defined(i)&&(e=b.unpack(e,i)),e._ellipsoid=t.Ellipsoid.clone(e._ellipsoid),b.createGeometry(e)}});
