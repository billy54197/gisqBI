/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./arrayRemoveDuplicates-cadb0e8e","./Transforms-5b74e989","./Matrix3-2955527a","./ComponentDatatype-f9ac3ed8","./PolylineVolumeGeometryLibrary-65969b57","./CorridorGeometryLibrary-95558a86","./defaultValue-ebbd2e4d","./GeometryAttribute-9c756444","./GeometryAttributes-ca309b71","./GeometryOffsetAttribute-739bec2c","./IndexDatatype-7ccfd280","./Math-1fe079f3","./PolygonPipeline-4fdc8b4f","./Matrix2-462b83d3","./RuntimeError-38a08050","./combine-55e9f355","./WebGLConstants-544672c2","./EllipsoidTangentPlane-da4fdd19","./AxisAlignedBoundingBox-a26a3fb6","./IntersectionTests-2a07bba4","./Plane-7e97483e","./PolylinePipeline-0a87fb90","./EllipsoidGeodesic-7acc6014","./EllipsoidRhumbLine-8bc8a516"],function(Z,$,d,U,F,x,m,B,ee,Y,j,q,W,ie,oe,re,ne,ae,se,le,de,ue,pe,ce){"use strict";const z=new d.Cartesian3,K=new d.Cartesian3,te=new d.Cartesian3;function Q(e,o){const t=[],c=e.positions,f=e.corners,E=e.endPositions,V=new ee.GeometryAttributes;let L,i,p,v=0,T=0,u=0;for(i=0;i<c.length;i+=2)p=c[i].length-3,v+=p,u+=p/3*4,T+=c[i+1].length-3;for(v+=3,T+=3,i=0;i<f.length;i++){L=f[i];const l=f[i].leftPositions;m.defined(l)?(p=l.length,v+=p,u+=p/3*2):(p=f[i].rightPositions.length,T+=p,u+=p/3*2)}const w=m.defined(E);let h;w&&(h=E[0].length-3,v+=h,T+=h,h/=3,u+=4*h);const H=v+T,C=new Float64Array(H);let P,_,A,y,g,G,a=0,r=H-1;const N=h/2,n=j.IndexDatatype.createTypedArray(H/3,u+4);let s=0;if(n[s++]=a/3,n[s++]=(r-2)/3,w){t.push(a/3),G=z,g=K;const l=E[0];for(i=0;i<N;i++)G=d.Cartesian3.fromArray(l,3*(N-1-i),G),g=d.Cartesian3.fromArray(l,3*(N+i),g),x.CorridorGeometryLibrary.addAttribute(C,g,a),x.CorridorGeometryLibrary.addAttribute(C,G,void 0,r),_=a/3,y=_+1,P=(r-2)/3,A=P-1,n[s++]=P,n[s++]=A,n[s++]=_,n[s++]=y,a+=3,r-=3}let I=0,D=c[I++],b=c[I++];for(C.set(D,a),C.set(b,r-b.length+1),p=b.length-3,t.push(a/3,(r-2)/3),i=0;i<p;i+=3)_=a/3,y=_+1,P=(r-2)/3,A=P-1,n[s++]=P,n[s++]=A,n[s++]=_,n[s++]=y,a+=3,r-=3;for(i=0;i<f.length;i++){let l;L=f[i];const R=L.leftPositions,J=L.rightPositions;let O,S=te;if(m.defined(R)){for(r-=3,O=A,t.push(y),l=0;l<R.length/3;l++)S=d.Cartesian3.fromArray(R,3*l,S),n[s++]=O-l-1,n[s++]=O-l,x.CorridorGeometryLibrary.addAttribute(C,S,void 0,r),r-=3;t.push(O-Math.floor(R.length/6)),o===F.CornerType.BEVELED&&t.push((r-2)/3+1),a+=3}else{for(a+=3,O=y,t.push(A),l=0;l<J.length/3;l++)S=d.Cartesian3.fromArray(J,3*l,S),n[s++]=O+l,n[s++]=O+l+1,x.CorridorGeometryLibrary.addAttribute(C,S,a),a+=3;t.push(O+Math.floor(J.length/6)),o===F.CornerType.BEVELED&&t.push(a/3-1),r-=3}for(D=c[I++],b=c[I++],D.splice(0,3),b.splice(b.length-3,3),C.set(D,a),C.set(b,r-b.length+1),p=b.length-3,l=0;l<b.length;l+=3)y=a/3,_=y-1,A=(r-2)/3,P=A+1,n[s++]=P,n[s++]=A,n[s++]=_,n[s++]=y,a+=3,r-=3;a-=3,r+=3,t.push(a/3,(r-2)/3)}if(w){a+=3,r-=3,G=z,g=K;const l=E[1];for(i=0;i<N;i++)G=d.Cartesian3.fromArray(l,3*(h-i-1),G),g=d.Cartesian3.fromArray(l,3*i,g),x.CorridorGeometryLibrary.addAttribute(C,G,void 0,r),x.CorridorGeometryLibrary.addAttribute(C,g,a),y=a/3,_=y-1,A=(r-2)/3,P=A+1,n[s++]=P,n[s++]=A,n[s++]=_,n[s++]=y,a+=3,r-=3;t.push(a/3)}else t.push(a/3,(r-2)/3);return n[s++]=a/3,n[s++]=(r-2)/3,V.position=new B.GeometryAttribute({componentDatatype:U.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:C}),{attributes:V,indices:n,wallIndices:t}}function M(e){const o=(e=m.defaultValue(e,m.defaultValue.EMPTY_OBJECT)).positions,t=e.width,c=m.defaultValue(e.height,0),f=m.defaultValue(e.extrudedHeight,c);this._positions=o,this._ellipsoid=d.Ellipsoid.clone(m.defaultValue(e.ellipsoid,d.Ellipsoid.WGS84)),this._width=t,this._height=Math.max(c,f),this._extrudedHeight=Math.min(c,f),this._cornerType=m.defaultValue(e.cornerType,F.CornerType.ROUNDED),this._granularity=m.defaultValue(e.granularity,q.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+o.length*d.Cartesian3.packedLength+d.Ellipsoid.packedLength+6}M.pack=function(e,o,t){t=m.defaultValue(t,0);const c=e._positions,f=c.length;o[t++]=f;for(let E=0;E<f;++E,t+=d.Cartesian3.packedLength)d.Cartesian3.pack(c[E],o,t);return d.Ellipsoid.pack(e._ellipsoid,o,t),t+=d.Ellipsoid.packedLength,o[t++]=e._width,o[t++]=e._height,o[t++]=e._extrudedHeight,o[t++]=e._cornerType,o[t++]=e._granularity,o[t]=m.defaultValue(e._offsetAttribute,-1),o};const X=d.Ellipsoid.clone(d.Ellipsoid.UNIT_SPHERE),k={positions:void 0,ellipsoid:X,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};return M.unpack=function(e,o,t){o=m.defaultValue(o,0);const c=e[o++],f=new Array(c);for(let u=0;u<c;++u,o+=d.Cartesian3.packedLength)f[u]=d.Cartesian3.unpack(e,o);const E=d.Ellipsoid.unpack(e,o,X);o+=d.Ellipsoid.packedLength;const V=e[o++],L=e[o++],i=e[o++],p=e[o++],v=e[o++],T=e[o];return m.defined(t)?(t._positions=f,t._ellipsoid=d.Ellipsoid.clone(E,t._ellipsoid),t._width=V,t._height=L,t._extrudedHeight=i,t._cornerType=p,t._granularity=v,t._offsetAttribute=T===-1?void 0:T,t):(k.positions=f,k.width=V,k.height=L,k.extrudedHeight=i,k.cornerType=p,k.granularity=v,k.offsetAttribute=T===-1?void 0:T,new M(k))},M.createGeometry=function(e){let o=e._positions;const t=e._width,c=e._ellipsoid;o=function(u,w){for(let h=0;h<u.length;h++)u[h]=w.scaleToGeodeticSurface(u[h],u[h]);return u}(o,c);const f=Z.arrayRemoveDuplicates(o,d.Cartesian3.equalsEpsilon);if(f.length<2||t<=0)return;const E=e._height,V=e._extrudedHeight,L=!q.CesiumMath.equalsEpsilon(E,V,0,q.CesiumMath.EPSILON2),i={ellipsoid:c,positions:f,width:t,cornerType:e._cornerType,granularity:e._granularity,saveAttributes:!1};let p;if(L)i.height=E,i.extrudedHeight=V,i.offsetAttribute=e._offsetAttribute,p=function(u){const w=u.ellipsoid,h=Q(x.CorridorGeometryLibrary.computePositions(u),u.cornerType),H=h.wallIndices,C=u.height,P=u.extrudedHeight,_=h.attributes,A=h.indices;let y=_.position.values,g=y.length,G=new Float64Array(g);G.set(y);const a=new Float64Array(2*g);if(y=W.PolygonPipeline.scaleToGeodeticHeight(y,C,w),G=W.PolygonPipeline.scaleToGeodeticHeight(G,P,w),a.set(y),a.set(G,g),_.position.values=a,g/=3,m.defined(u.offsetAttribute)){let b=new Uint8Array(2*g);if(u.offsetAttribute===Y.GeometryOffsetAttribute.TOP)b=b.fill(1,0,g);else{const l=u.offsetAttribute===Y.GeometryOffsetAttribute.NONE?0:1;b=b.fill(l)}_.applyOffset=new B.GeometryAttribute({componentDatatype:U.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:b})}let r;const N=A.length,n=j.IndexDatatype.createTypedArray(a.length/3,2*(N+H.length));n.set(A);let s,I,D=N;for(r=0;r<N;r+=2){const b=A[r],l=A[r+1];n[D++]=b+g,n[D++]=l+g}for(r=0;r<H.length;r++)s=H[r],I=s+g,n[D++]=s,n[D++]=I;return{attributes:_,indices:n}}(i);else if(p=Q(x.CorridorGeometryLibrary.computePositions(i),i.cornerType),p.attributes.position.values=W.PolygonPipeline.scaleToGeodeticHeight(p.attributes.position.values,E,c),m.defined(e._offsetAttribute)){const u=p.attributes.position.values.length,w=e._offsetAttribute===Y.GeometryOffsetAttribute.NONE?0:1,h=new Uint8Array(u/3).fill(w);p.attributes.applyOffset=new B.GeometryAttribute({componentDatatype:U.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:h})}const v=p.attributes,T=$.BoundingSphere.fromVertices(v.position.values,void 0,3);return new B.Geometry({attributes:v,indices:p.indices,primitiveType:B.PrimitiveType.LINES,boundingSphere:T,offsetAttribute:e._offsetAttribute})},function(e,o){return m.defined(o)&&(e=M.unpack(e,o)),e._ellipsoid=d.Ellipsoid.clone(e._ellipsoid),M.createGeometry(e)}});
