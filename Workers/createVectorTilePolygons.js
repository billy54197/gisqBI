/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./AttributeCompression-6f93ad0c","./Matrix3-2955527a","./Color-3cef7e8d","./defaultValue-ebbd2e4d","./IndexDatatype-7ccfd280","./Math-1fe079f3","./OrientedBoundingBox-48eb7862","./Matrix2-462b83d3","./createTaskProcessorWorker","./ComponentDatatype-f9ac3ed8","./WebGLConstants-544672c2","./Transforms-5b74e989","./combine-55e9f355","./RuntimeError-38a08050","./EllipsoidTangentPlane-da4fdd19","./AxisAlignedBoundingBox-a26a3fb6","./IntersectionTests-2a07bba4","./Plane-7e97483e"],function(Ie,t,D,k,W,ee,R,z,xe,Oe,Ue,Pe,Fe,Me,Se,De,Re,_e){"use strict";const ne=new t.Cartesian3,te=new t.Ellipsoid,ae=new z.Rectangle,T={min:void 0,max:void 0,indexBytesPerElement:void 0};function we(p,_,x){const E=_.length,w=2+E*R.OrientedBoundingBox.packedLength+1+function(h){const C=h.length;let m=0;for(let r=0;r<C;++r)m+=D.Color.packedLength+3+h[r].batchIds.length;return m}(x),i=new Float64Array(w);let u=0;i[u++]=p,i[u++]=E;for(let h=0;h<E;++h)R.OrientedBoundingBox.pack(_[h],i,u),u+=R.OrientedBoundingBox.packedLength;const L=x.length;i[u++]=L;for(let h=0;h<L;++h){const C=x[h];D.Color.pack(C.color,i,u),u+=D.Color.packedLength,i[u++]=C.offset,i[u++]=C.count;const m=C.batchIds,r=m.length;i[u++]=r;for(let B=0;B<r;++B)i[u++]=m[B]}return i}const re=new t.Cartesian3,Ae=new t.Cartesian3,Ee=new t.Cartesian3,Ne=new t.Cartesian3,Te=new t.Cartesian3,oe=new t.Cartographic,Be=new z.Rectangle;return xe(function(p,_){let x;(function(n){const a=new Float64Array(n);let s=0;T.indexBytesPerElement=a[s++],T.min=a[s++],T.max=a[s++],t.Cartesian3.unpack(a,s,ne),s+=t.Cartesian3.packedLength,t.Ellipsoid.unpack(a,s,te),s+=t.Ellipsoid.packedLength,z.Rectangle.unpack(a,s,ae)})(p.packedBuffer),x=T.indexBytesPerElement===2?new Uint16Array(p.indices):new Uint32Array(p.indices);const E=new Uint16Array(p.positions),w=new Uint32Array(p.counts),i=new Uint32Array(p.indexCounts),u=new Uint32Array(p.batchIds),L=new Uint32Array(p.batchTableColors),h=new Array(w.length),C=ne,m=te;let r=ae;const B=T.min,se=T.max;let e,f,d,O=p.minimumHeights,U=p.maximumHeights;k.defined(O)&&k.defined(U)&&(O=new Float32Array(O),U=new Float32Array(U));const N=E.length/2,ie=E.subarray(0,N),ce=E.subarray(N,2*N);Ie.AttributeCompression.zigZagDeltaDecode(ie,ce);const fe=new Float64Array(3*N);for(e=0;e<N;++e){const n=ie[e],a=ce[e],s=ee.CesiumMath.lerp(r.west,r.east,n/32767),A=ee.CesiumMath.lerp(r.south,r.north,a/32767),y=t.Cartographic.fromRadians(s,A,0,oe),v=m.cartographicToCartesian(y,re);t.Cartesian3.pack(v,fe,3*e)}const P=w.length,de=new Array(P),Z=new Array(P);let le=0,ue=0;for(e=0;e<P;++e)de[e]=le,Z[e]=ue,le+=w[e],ue+=i[e];const F=new Float32Array(3*N*2),G=new Uint16Array(2*N),V=new Uint32Array(Z.length),Y=new Uint32Array(i.length);let o=[];const b={};for(e=0;e<P;++e)d=L[e],k.defined(b[d])?(b[d].positionLength+=w[e],b[d].indexLength+=i[e],b[d].batchIds.push(e)):b[d]={positionLength:w[e],indexLength:i[e],offset:0,indexOffset:0,batchIds:[e]};let c,he=0,ge=0;for(d in b)if(b.hasOwnProperty(d)){c=b[d],c.offset=he,c.indexOffset=ge;const n=2*c.positionLength,a=2*c.indexLength+6*c.positionLength;he+=n,ge+=a,c.indexLength=a}const M=[];for(d in b)b.hasOwnProperty(d)&&(c=b[d],M.push({color:D.Color.fromRgba(parseInt(d)),offset:c.indexOffset,count:c.indexLength,batchIds:c.batchIds}));for(e=0;e<P;++e){d=L[e],c=b[d];const n=c.offset;let a=3*n,s=n;const A=de[e],y=w[e],v=u[e];let be=B,me=se;k.defined(O)&&k.defined(U)&&(be=O[e],me=U[e]);let j=Number.POSITIVE_INFINITY,q=Number.NEGATIVE_INFINITY,J=Number.POSITIVE_INFINITY,K=Number.NEGATIVE_INFINITY;for(f=0;f<y;++f){const g=t.Cartesian3.unpack(fe,3*A+3*f,re);m.scaleToGeodeticSurface(g,g);const I=m.cartesianToCartographic(g,oe),S=I.latitude,ye=I.longitude;j=Math.min(S,j),q=Math.max(S,q),J=Math.min(ye,J),K=Math.max(ye,K);const Ce=m.geodeticSurfaceNormal(g,Ae);let H=t.Cartesian3.multiplyByScalar(Ce,be,Ee);const X=t.Cartesian3.add(g,H,Ne);H=t.Cartesian3.multiplyByScalar(Ce,me,H);const $=t.Cartesian3.add(g,H,Te);t.Cartesian3.subtract($,C,$),t.Cartesian3.subtract(X,C,X),t.Cartesian3.pack($,F,a),t.Cartesian3.pack(X,F,a+3),G[s]=v,G[s+1]=v,a+=6,s+=2}r=Be,r.west=J,r.east=K,r.south=j,r.north=q,h[e]=R.OrientedBoundingBox.fromRectangle(r,B,se,m);let l=c.indexOffset;const Q=Z[e],Le=i[e];for(V[e]=l,f=0;f<Le;f+=3){const g=x[Q+f]-A,I=x[Q+f+1]-A,S=x[Q+f+2]-A;o[l++]=2*g+n,o[l++]=2*I+n,o[l++]=2*S+n,o[l++]=2*S+1+n,o[l++]=2*I+1+n,o[l++]=2*g+1+n}for(f=0;f<y;++f){const g=f,I=(f+1)%y;o[l++]=2*g+1+n,o[l++]=2*I+n,o[l++]=2*g+n,o[l++]=2*g+1+n,o[l++]=2*I+1+n,o[l++]=2*I+n}c.offset+=2*y,c.indexOffset=l,Y[e]=l-V[e]}o=W.IndexDatatype.createTypedArray(F.length/3,o);const ke=M.length;for(let n=0;n<ke;++n){const a=M[n].batchIds;let s=0;const A=a.length;for(let y=0;y<A;++y)s+=Y[a[y]];M[n].count=s}const pe=we(o.BYTES_PER_ELEMENT===2?W.IndexDatatype.UNSIGNED_SHORT:W.IndexDatatype.UNSIGNED_INT,h,M);return _.push(F.buffer,o.buffer,V.buffer,Y.buffer,G.buffer,pe.buffer),{positions:F.buffer,indices:o.buffer,indexOffsets:V.buffer,indexCounts:Y.buffer,batchIds:G.buffer,packedBuffer:pe.buffer}})});
