/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.99.9
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */define(["./AxisAlignedBoundingBox-a26a3fb6","./Transforms-5b74e989","./Matrix2-462b83d3","./Matrix3-2955527a","./defaultValue-ebbd2e4d","./TerrainEncoding-519593e1","./Math-1fe079f3","./OrientedBoundingBox-48eb7862","./RuntimeError-38a08050","./WebMercatorProjection-3d5b0545","./createTaskProcessorWorker","./combine-55e9f355","./AttributeCompression-6f93ad0c","./ComponentDatatype-f9ac3ed8","./WebGLConstants-544672c2","./EllipsoidTangentPlane-da4fdd19","./IntersectionTests-2a07bba4","./Plane-7e97483e"],function(Ht,wt,S,r,it,Bt,o,Lt,Dt,mt,Gt,ne,ie,oe,ae,re,se,ce){"use strict";const jt=Uint16Array.BYTES_PER_ELEMENT,ot=Int32Array.BYTES_PER_ELEMENT,pt=Uint32Array.BYTES_PER_ELEMENT,zt=Float32Array.BYTES_PER_ELEMENT,w=Float64Array.BYTES_PER_ELEMENT;function Q(i,H,n){n=it.defaultValue(n,o.CesiumMath);const x=i.length;for(let h=0;h<x;++h)if(n.equalsEpsilon(i[h],H,o.CesiumMath.EPSILON12))return h;return-1}const s=new r.Cartographic,k=new r.Cartesian3,qt=new r.Cartesian3,Jt=new r.Cartesian3,Kt=new S.Matrix4;function at(i,H,n,x,h,It,d,I,l,B,X){const rt=I.length;for(let P=0;P<rt;++P){const f=I[P],Z=f.cartographic,L=f.index,m=i.length,E=Z.longitude;let T=Z.latitude;T=o.CesiumMath.clamp(T,-o.CesiumMath.PI_OVER_TWO,o.CesiumMath.PI_OVER_TWO);const p=Z.height-d.skirtHeight;d.hMin=Math.min(d.hMin,p),r.Cartographic.fromRadians(E,T,p,s),B&&(s.longitude+=l),B?P===rt-1?s.latitude+=X:P===0&&(s.latitude-=X):s.latitude+=l;const A=d.ellipsoid.cartographicToCartesian(s);i.push(A),H.push(p),n.push(S.Cartesian2.clone(n[L])),x.length>0&&x.push(x[L]),h.length>0&&h.push(h[L]),S.Matrix4.multiplyByPoint(d.toENU,A,k);const C=d.minimum,D=d.maximum;r.Cartesian3.minimumByComponent(k,C,C),r.Cartesian3.maximumByComponent(k,D,D);const G=d.lastBorderPoint;if(it.defined(G)){const $=G.index;It.push($,m-1,m,m,L,$)}d.lastBorderPoint=f}}return Gt(function(i,H){i.ellipsoid=r.Ellipsoid.clone(i.ellipsoid),i.rectangle=S.Rectangle.clone(i.rectangle);const n=function(It,d,I,l,B,X,rt,P,f,Z,L){let m,E,T,p,A,C;it.defined(l)?(m=l.west,E=l.south,T=l.east,p=l.north,A=l.width,C=l.height):(m=o.CesiumMath.toRadians(B.west),E=o.CesiumMath.toRadians(B.south),T=o.CesiumMath.toRadians(B.east),p=o.CesiumMath.toRadians(B.north),A=o.CesiumMath.toRadians(l.width),C=o.CesiumMath.toRadians(l.height));const D=[E,p],G=[m,T],$=wt.Transforms.eastNorthUpToFixedFrame(d,I),Pt=S.Matrix4.inverseTransformation($,Kt);let ft,At;f&&(ft=mt.WebMercatorProjection.geodeticLatitudeToMercatorAngle(E),At=1/(mt.WebMercatorProjection.geodeticLatitudeToMercatorAngle(p)-ft));const st=X!==1,c=new DataView(It);let j=Number.POSITIVE_INFINITY,tt=Number.NEGATIVE_INFINITY;const R=qt;R.x=Number.POSITIVE_INFINITY,R.y=Number.POSITIVE_INFINITY,R.z=Number.POSITIVE_INFINITY;const y=Jt;y.x=Number.NEGATIVE_INFINITY,y.y=Number.NEGATIVE_INFINITY,y.z=Number.NEGATIVE_INFINITY;let ct,z,e=0,M=0,Rt=0;for(z=0;z<4;++z){let t=e;ct=c.getUint32(t,!0),t+=pt;const u=o.CesiumMath.toRadians(180*c.getFloat64(t,!0));t+=w,Q(G,u)===-1&&G.push(u);const Y=o.CesiumMath.toRadians(180*c.getFloat64(t,!0));t+=w,Q(D,Y)===-1&&D.push(Y),t+=2*w;let N=c.getInt32(t,!0);t+=ot,M+=N,N=c.getInt32(t,!0),Rt+=3*N,e+=ct+pt}const yt=[],Wt=[],g=new Array(M),W=new Array(M),_=new Array(M),v=f?new Array(M):[],F=st?new Array(M):[],O=new Array(Rt),q=[],ut=[],dt=[],V=[];let a=0,Et=0;for(e=0,z=0;z<4;++z){ct=c.getUint32(e,!0),e+=pt;const t=e,u=o.CesiumMath.toRadians(180*c.getFloat64(e,!0));e+=w;const Y=o.CesiumMath.toRadians(180*c.getFloat64(e,!0));e+=w;const N=o.CesiumMath.toRadians(180*c.getFloat64(e,!0)),Vt=.5*N;e+=w;const Yt=o.CesiumMath.toRadians(180*c.getFloat64(e,!0)),Ut=.5*Yt;e+=w;const kt=c.getInt32(e,!0);e+=ot;const te=c.getInt32(e,!0);e+=ot,e+=ot;const xt=new Array(kt);for(let U=0;U<kt;++U){const nt=u+c.getUint8(e++)*N;s.longitude=nt;const K=Y+c.getUint8(e++)*Yt;s.latitude=K;let b=c.getFloat32(e,!0);if(e+=zt,b!==0&&b<L&&(b*=-Math.pow(2,Z)),b*=6371010,s.height=b,Q(G,nt)!==-1||Q(D,K)!==-1){const gt=Q(yt,s,r.Cartographic);if(gt!==-1){xt[U]=Wt[gt];continue}yt.push(r.Cartographic.clone(s)),Wt.push(a)}xt[U]=a,Math.abs(nt-m)<Vt?q.push({index:a,cartographic:r.Cartographic.clone(s)}):Math.abs(nt-T)<Vt?dt.push({index:a,cartographic:r.Cartographic.clone(s)}):Math.abs(K-E)<Ut?ut.push({index:a,cartographic:r.Cartographic.clone(s)}):Math.abs(K-p)<Ut&&V.push({index:a,cartographic:r.Cartographic.clone(s)}),j=Math.min(b,j),tt=Math.max(b,tt),_[a]=b;const Nt=I.cartographicToCartesian(s);if(g[a]=Nt,f&&(v[a]=(mt.WebMercatorProjection.geodeticLatitudeToMercatorAngle(K)-ft)*At),st){const gt=I.geodeticSurfaceNormal(Nt);F[a]=gt}S.Matrix4.multiplyByPoint(Pt,Nt,k),r.Cartesian3.minimumByComponent(k,R,R),r.Cartesian3.maximumByComponent(k,y,y);let bt=(nt-m)/(T-m);bt=o.CesiumMath.clamp(bt,0,1);let St=(K-E)/(p-E);St=o.CesiumMath.clamp(St,0,1),W[a]=new S.Cartesian2(bt,St),++a}const ee=3*te;for(let U=0;U<ee;++U,++Et)O[Et]=xt[c.getUint16(e,!0)],e+=jt;if(ct!==e-t)throw new Dt.RuntimeError("Invalid terrain tile.")}g.length=a,W.length=a,_.length=a,f&&(v.length=a),st&&(F.length=a);const _t=a,Qt=Et,et={hMin:j,lastBorderPoint:void 0,skirtHeight:P,toENU:Pt,ellipsoid:I,minimum:R,maximum:y};q.sort(function(t,u){return u.cartographic.latitude-t.cartographic.latitude}),ut.sort(function(t,u){return t.cartographic.longitude-u.cartographic.longitude}),dt.sort(function(t,u){return t.cartographic.latitude-u.cartographic.latitude}),V.sort(function(t,u){return u.cartographic.longitude-t.cartographic.longitude});const J=1e-5;if(at(g,_,W,v,F,O,et,q,-J*A,!0,-J*C),at(g,_,W,v,F,O,et,ut,-J*C,!1),at(g,_,W,v,F,O,et,dt,J*A,!0,J*C),at(g,_,W,v,F,O,et,V,J*C,!1),q.length>0&&V.length>0){const t=q[0].index,u=_t,Y=V[V.length-1].index,N=g.length-1;O.push(Y,N,u,u,t,Y)}M=g.length;const Xt=wt.BoundingSphere.fromPoints(g);let vt;it.defined(l)&&(vt=Lt.OrientedBoundingBox.fromRectangle(l,j,tt,I));const Zt=new Bt.EllipsoidalOccluder(I).computeHorizonCullingPointPossiblyUnderEllipsoid(d,g,j),$t=new Ht.AxisAlignedBoundingBox(R,y,d),Tt=new Bt.TerrainEncoding(d,$t,et.hMin,tt,$,!1,f,st,X,rt),Ft=new Float32Array(M*Tt.stride);let Ot=0;for(let t=0;t<M;++t)Ot=Tt.encode(Ft,Ot,g[t],W[t],_[t],void 0,v[t],F[t]);const lt=q.map(function(t){return t.index}).reverse(),Ct=ut.map(function(t){return t.index}).reverse(),ht=dt.map(function(t){return t.index}).reverse(),Mt=V.map(function(t){return t.index}).reverse();return Ct.unshift(ht[ht.length-1]),Ct.push(lt[0]),Mt.unshift(lt[lt.length-1]),Mt.push(ht[0]),{vertices:Ft,indices:new Uint16Array(O),maximumHeight:tt,minimumHeight:j,encoding:Tt,boundingSphere3D:Xt,orientedBoundingBox:vt,occludeePointInScaledSpace:Zt,vertexCountWithoutSkirts:_t,indexCountWithoutSkirts:Qt,westIndicesSouthToNorth:lt,southIndicesEastToWest:Ct,eastIndicesNorthToSouth:ht,northIndicesWestToEast:Mt}}(i.buffer,i.relativeToCenter,i.ellipsoid,i.rectangle,i.nativeRectangle,i.exaggeration,i.exaggerationRelativeHeight,i.skirtHeight,i.includeWebMercatorT,i.negativeAltitudeExponentBias,i.negativeElevationThreshold),x=n.vertices;H.push(x.buffer);const h=n.indices;return H.push(h.buffer),{vertices:x.buffer,indices:h.buffer,numberOfAttributes:n.encoding.stride,minimumHeight:n.minimumHeight,maximumHeight:n.maximumHeight,boundingSphere3D:n.boundingSphere3D,orientedBoundingBox:n.orientedBoundingBox,occludeePointInScaledSpace:n.occludeePointInScaledSpace,encoding:n.encoding,vertexCountWithoutSkirts:n.vertexCountWithoutSkirts,indexCountWithoutSkirts:n.indexCountWithoutSkirts,westIndicesSouthToNorth:n.westIndicesSouthToNorth,southIndicesEastToWest:n.southIndicesEastToWest,eastIndicesNorthToSouth:n.eastIndicesNorthToSouth,northIndicesWestToEast:n.northIndicesWestToEast}})});
