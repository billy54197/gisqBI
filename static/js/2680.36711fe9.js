"use strict";(self.webpackChunkdatavisual=self.webpackChunkdatavisual||[]).push([[2680],{93963:function(w,f,r){r.d(f,{Z:function(){return _}});function i(t,n){let o=t.length-n,u=0;do{for(let a=n;a>0;a--)t[u+n]+=t[u],u++;o-=n}while(o>0)}function h(t,n,o){let u=0,a=t.length;const d=a/o;for(;a>n;){for(let e=n;e>0;--e)t[u+n]+=t[u],++u;a-=n}const s=t.slice();for(let e=0;e<d;++e)for(let c=0;c<o;++c)t[o*e+c]=s[(o-c-1)*d+e]}function g(t,n,o,u,a,d){if(!n||n===1)return t;for(let c=0;c<a.length;++c){if(a[c]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(a[c]!==a[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const s=a[0]/8,e=d===2?1:a.length;for(let c=0;c<u&&!(c*e*o*s>=t.byteLength);++c){let l;if(n===2){switch(a[0]){case 8:l=new Uint8Array(t,c*e*o*s,e*o*s);break;case 16:l=new Uint16Array(t,c*e*o*s,e*o*s/2);break;case 32:l=new Uint32Array(t,c*e*o*s,e*o*s/4);break;default:throw new Error(`Predictor 2 not allowed with ${a[0]} bits per sample.`)}i(l,e,s)}else n===3&&(l=new Uint8Array(t,c*e*o*s,e*o*s),h(l,e,s))}return t}class _{async decode(n,o){const u=await this.decodeBlock(o),a=n.Predictor||1;if(a!==1){const d=!n.StripOffsets,s=d?n.TileWidth:n.ImageWidth,e=d?n.TileLength:n.RowsPerStrip||n.ImageLength;return g(u,a,s,e,n.BitsPerSample,n.PlanarConfiguration)}return u}}},22680:function(w,f,r){r.r(f),r.d(f,{default:function(){return g}});var i=r(50189),h=r(93963);class g extends h.Z{decodeBlock(t){return(0,i.rr)(new Uint8Array(t)).buffer}}}}]);
