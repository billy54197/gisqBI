"use strict";(self.webpackChunkdatavisual=self.webpackChunkdatavisual||[]).push([[3225],{93963:function(_,i,r){r.d(i,{Z:function(){return g}});function f(o,n){let t=o.length-n,u=0;do{for(let a=n;a>0;a--)o[u+n]+=o[u],u++;t-=n}while(t>0)}function h(o,n,t){let u=0,a=o.length;const d=a/t;for(;a>n;){for(let e=n;e>0;--e)o[u+n]+=o[u],++u;a-=n}const s=o.slice();for(let e=0;e<d;++e)for(let c=0;c<t;++c)o[t*e+c]=s[(t-c-1)*d+e]}function w(o,n,t,u,a,d){if(!n||n===1)return o;for(let c=0;c<a.length;++c){if(a[c]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(a[c]!==a[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const s=a[0]/8,e=d===2?1:a.length;for(let c=0;c<u&&!(c*e*t*s>=o.byteLength);++c){let l;if(n===2){switch(a[0]){case 8:l=new Uint8Array(o,c*e*t*s,e*t*s);break;case 16:l=new Uint16Array(o,c*e*t*s,e*t*s/2);break;case 32:l=new Uint32Array(o,c*e*t*s,e*t*s/4);break;default:throw new Error(`Predictor 2 not allowed with ${a[0]} bits per sample.`)}f(l,e,s)}else n===3&&(l=new Uint8Array(o,c*e*t*s,e*t*s),h(l,e,s))}return o}class g{async decode(n,t){const u=await this.decodeBlock(t),a=n.Predictor||1;if(a!==1){const d=!n.StripOffsets,s=d?n.TileWidth:n.ImageWidth,e=d?n.TileLength:n.RowsPerStrip||n.ImageLength;return w(u,a,s,e,n.BitsPerSample,n.PlanarConfiguration)}return u}}},13225:function(_,i,r){r.r(i),r.d(i,{default:function(){return h}});var f=r(93963);class h extends f.Z{decodeBlock(g){return g}}}}]);
