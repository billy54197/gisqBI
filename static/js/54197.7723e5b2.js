"use strict";(self.webpackChunkdatavisual=self.webpackChunkdatavisual||[]).push([[54197],{261397:function(U,r,l){l.d(r,{Z:function(){return f}});function h(o,e){let n=o.length-e,s=0;do{for(let t=e;t>0;t--)o[s+e]+=o[s],s++;n-=e}while(n>0)}function g(o,e,n){let s=0,t=o.length;const d=t/n;for(;t>e;){for(let a=e;a>0;--a)o[s+e]+=o[s],++s;t-=e}const u=o.slice();for(let a=0;a<d;++a)for(let c=0;c<n;++c)o[n*a+c]=u[(n-c-1)*d+a]}function w(o,e,n,s,t,d){if(!e||e===1)return o;for(let c=0;c<t.length;++c){if(t[c]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(t[c]!==t[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const u=t[0]/8,a=d===2?1:t.length;for(let c=0;c<s&&!(c*a*n*u>=o.byteLength);++c){let i;if(e===2){switch(t[0]){case 8:i=new Uint8Array(o,c*a*n*u,a*n*u);break;case 16:i=new Uint16Array(o,c*a*n*u,a*n*u/2);break;case 32:i=new Uint32Array(o,c*a*n*u,a*n*u/4);break;default:throw new Error(`Predictor 2 not allowed with ${t[0]} bits per sample.`)}h(i,a,u)}else e===3&&(i=new Uint8Array(o,c*a*n*u,a*n*u),g(i,a,u))}return o}class f{async decode(e,n){const s=await this.decodeBlock(n),t=e.Predictor||1;if(t!==1){const d=!e.StripOffsets,u=d?e.TileWidth:e.ImageWidth,a=d?e.TileLength:e.RowsPerStrip||e.ImageLength;return w(s,t,u,a,e.BitsPerSample,e.PlanarConfiguration)}return s}}},554197:function(U,r,l){l.r(r),l.d(r,{default:function(){return g}});var h=l(261397);class g extends h.Z{decodeBlock(f){const o=new DataView(f),e=[];for(let n=0;n<f.byteLength;++n){let s=o.getInt8(n);if(s<0){const t=o.getUint8(n+1);s=-s;for(let d=0;d<=s;++d)e.push(t);n+=1}else{for(let t=0;t<=s;++t)e.push(o.getUint8(n+t+1));n+=s+1}}return new Uint8Array(e).buffer}}}}]);
