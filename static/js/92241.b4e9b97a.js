"use strict";(self.webpackChunkdatavisual=self.webpackChunkdatavisual||[]).push([[92241],{261397:function(E,f,r){r.d(f,{Z:function(){return w}});function i(t,n){let o=t.length-n,u=0;do{for(let a=n;a>0;a--)t[u+n]+=t[u],u++;o-=n}while(o>0)}function h(t,n,o){let u=0,a=t.length;const d=a/o;for(;a>n;){for(let e=n;e>0;--e)t[u+n]+=t[u],++u;a-=n}const c=t.slice();for(let e=0;e<d;++e)for(let s=0;s<o;++s)t[o*e+s]=c[(o-s-1)*d+e]}function g(t,n,o,u,a,d){if(!n||n===1)return t;for(let s=0;s<a.length;++s){if(a[s]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(a[s]!==a[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const c=a[0]/8,e=d===2?1:a.length;for(let s=0;s<u&&!(s*e*o*c>=t.byteLength);++s){let l;if(n===2){switch(a[0]){case 8:l=new Uint8Array(t,s*e*o*c,e*o*c);break;case 16:l=new Uint16Array(t,s*e*o*c,e*o*c/2);break;case 32:l=new Uint32Array(t,s*e*o*c,e*o*c/4);break;default:throw new Error(`Predictor 2 not allowed with ${a[0]} bits per sample.`)}i(l,e,c)}else n===3&&(l=new Uint8Array(t,s*e*o*c,e*o*c),h(l,e,c))}return t}class w{async decode(n,o){const u=await this.decodeBlock(o),a=n.Predictor||1;if(a!==1){const d=!n.StripOffsets,c=d?n.TileWidth:n.ImageWidth,e=d?n.TileLength:n.RowsPerStrip||n.ImageLength;return g(u,a,c,e,n.BitsPerSample,n.PlanarConfiguration)}return u}}},992241:function(E,f,r){r.r(f),r.d(f,{default:function(){return g}});var i=r(450189),h=r(261397);class g extends h.Z{decodeBlock(t){return(0,i.rr)(new Uint8Array(t)).buffer}}}}]);
