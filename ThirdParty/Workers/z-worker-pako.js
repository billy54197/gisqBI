(function(){"use strict";const{Array:G,Object:y,Math:k,Error:m,Uint8Array:p,Uint16Array:vt,Uint32Array:M,Int32Array:zt,DataView:j,TextEncoder:x,crypto:b,postMessage:A}=globalThis,F=[];for(let s=0;256>s;s++){let t=s;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;F[s]=t}class R{constructor(t){this.crc=t||-1}append(t){let e=0|this.crc;for(let n=0,r=0|t.length;r>n;n++)e=e>>>8^F[255&(e^t[n])];this.crc=e}get(){return~this.crc}}const u={concat(s,t){if(s.length===0||t.length===0)return s.concat(t);const e=s[s.length-1],n=u.getPartial(e);return n===32?s.concat(t):u._shiftRight(t,n,0|e,s.slice(0,s.length-1))},bitLength(s){const t=s.length;if(t===0)return 0;const e=s[t-1];return 32*(t-1)+u.getPartial(e)},clamp(s,t){if(32*s.length<t)return s;const e=(s=s.slice(0,k.ceil(t/32))).length;return t&=31,e>0&&t&&(s[e-1]=u.partial(t,s[e-1]&2147483648>>t-1,1)),s},partial:(s,t,e)=>s===32?t:(e?0|t:t<<32-s)+1099511627776*s,getPartial:s=>k.round(s/1099511627776)||32,_shiftRight(s,t,e,n){for(n===void 0&&(n=[]);t>=32;t-=32)n.push(e),e=0;if(t===0)return n.concat(s);for(let i=0;i<s.length;i++)n.push(e|s[i]>>>t),e=s[i]<<32-t;const r=s.length?s[s.length-1]:0,a=u.getPartial(r);return n.push(u.partial(t+a&31,t+a>32?e:n.pop(),1)),n}},W={bytes:{fromBits(s){const t=u.bitLength(s)/8,e=new p(t);let n;for(let r=0;t>r;r++)!(3&r)&&(n=s[r/4]),e[r]=n>>>24,n<<=8;return e},toBits(s){const t=[];let e,n=0;for(e=0;e<s.length;e++)n=n<<8|s[e],(3&e)==3&&(t.push(n),n=0);return 3&e&&t.push(u.partial(8*(3&e),n)),t}}},O={sha1:function(s){s?(this._h=s._h.slice(0),this._buffer=s._buffer.slice(0),this._length=s._length):this.reset()}};O.sha1.prototype={blockSize:512,reset:function(){const s=this;return s._h=this._init.slice(0),s._buffer=[],s._length=0,s},update:function(s){const t=this;typeof s=="string"&&(s=W.utf8String.toBits(s));const e=t._buffer=u.concat(t._buffer,s),n=t._length,r=t._length=n+u.bitLength(s);if(r>9007199254740991)throw new m("Cannot hash more than 2^53 - 1 bits");const a=new M(e);let i=0;for(let c=t.blockSize+n-(t.blockSize+n&t.blockSize-1);r>=c;c+=t.blockSize)t._block(a.subarray(16*i,16*(i+1))),i+=1;return e.splice(0,16*i),t},finalize:function(){const s=this;let t=s._buffer;const e=s._h;t=u.concat(t,[u.partial(1,1)]);for(let n=t.length+2;15&n;n++)t.push(0);for(t.push(k.floor(s._length/4294967296)),t.push(0|s._length);t.length;)s._block(t.splice(0,16));return s.reset(),e},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:(s,t,e,n)=>s>19?s>39?s>59?s>79?void 0:t^e^n:t&e|t&n|e&n:t^e^n:t&e|~t&n,_S:(s,t)=>t<<s|t>>>32-s,_block:function(s){const t=this,e=t._h,n=G(80);for(let o=0;16>o;o++)n[o]=s[o];let r=e[0],a=e[1],i=e[2],c=e[3],l=e[4];for(let o=0;79>=o;o++){16>o||(n[o]=t._S(1,n[o-3]^n[o-8]^n[o-14]^n[o-16]));const h=t._S(5,r)+t._f(o,a,i,c)+l+n[o]+t._key[k.floor(o/20)]|0;l=c,c=i,i=t._S(30,a),a=r,r=h}e[0]=e[0]+r|0,e[1]=e[1]+a|0,e[2]=e[2]+i|0,e[3]=e[3]+c|0,e[4]=e[4]+l|0}};const dt={getRandomValues(s){const t=new M(s.buffer),e=n=>{let r=987654321;const a=4294967295;return()=>(r=36969*(65535&r)+(r>>16)&a,(((r<<16)+(n=18e3*(65535&n)+(n>>16)&a)&a)/4294967296+.5)*(k.random()>.5?1:-1))};for(let n,r=0;r<s.length;r+=4){const a=e(4294967296*(n||k.random()));n=987654071*a(),t[r/4]=4294967296*a()|0}return s}},T={importKey:s=>new T.hmacSha1(W.bytes.toBits(s)),pbkdf2(s,t,e,n){if(e=e||1e4,0>n||0>e)throw new m("invalid params to pbkdf2");const r=1+(n>>5)<<2;let a,i,c,l,o;const h=new ArrayBuffer(r),d=new j(h);let w=0;const z=u;for(t=W.bytes.toBits(t),o=1;(r||1)>w;o++){for(a=i=s.encrypt(z.concat(t,[o])),c=1;e>c;c++)for(i=s.encrypt(i),l=0;l<i.length;l++)a[l]^=i[l];for(c=0;(r||1)>w&&c<a.length;c++)d.setInt32(w,a[c]),w+=4}return h.slice(0,n/8)},hmacSha1:class{constructor(s){const t=this,e=t._hash=O.sha1,n=[[],[]],r=e.prototype.blockSize/32;t._baseHash=[new e,new e],s.length>r&&(s=e.hash(s));for(let a=0;r>a;a++)n[0][a]=909522486^s[a],n[1][a]=1549556828^s[a];t._baseHash[0].update(n[0]),t._baseHash[1].update(n[1]),t._resultHash=new e(t._baseHash[0])}reset(){const s=this;s._resultHash=new s._hash(s._baseHash[0]),s._updated=!1}update(s){this._updated=!0,this._resultHash.update(s)}digest(){const s=this,t=s._resultHash.finalize(),e=new s._hash(s._baseHash[1]).update(t).finalize();return s.reset(),e}encrypt(s){if(this._updated)throw new m("encrypt on already updated hmac called!");return this.update(s),this.digest(s)}}},q="Invalid pasword",D=16,J={name:"PBKDF2"},ut=y.assign({hash:{name:"HMAC"}},J),N=y.assign({iterations:1e3,hash:{name:"SHA-1"}},J),ft=["deriveBits"],H=[8,12,16],K=[16,24,32],v=10,Q=[0,0,0,0],U=b!==void 0,X=U&&b.subtle!==void 0,_=W.bytes,Y=class{constructor(s){const t=this;t._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],t._tables[0][0][0]||t._precompute();const e=t._tables[0][4],n=t._tables[1],r=s.length;let a,i,c,l=1;if(r!==4&&r!==6&&r!==8)throw new m("invalid aes key size");for(t._key=[i=s.slice(0),c=[]],a=r;4*r+28>a;a++){let o=i[a-1];(a%r==0||r===8&&a%r==4)&&(o=e[o>>>24]<<24^e[o>>16&255]<<16^e[o>>8&255]<<8^e[255&o],a%r==0&&(o=o<<8^o>>>24^l<<24,l=l<<1^283*(l>>7))),i[a]=i[a-r]^o}for(let o=0;a;o++,a--){const h=i[3&o?a:a-4];c[o]=4>=a||4>o?h:n[0][e[h>>>24]]^n[1][e[h>>16&255]]^n[2][e[h>>8&255]]^n[3][e[255&h]]}}encrypt(s){return this._crypt(s,0)}decrypt(s){return this._crypt(s,1)}_precompute(){const s=this._tables[0],t=this._tables[1],e=s[4],n=t[4],r=[],a=[];let i,c,l,o;for(let h=0;256>h;h++)a[(r[h]=h<<1^283*(h>>7))^h]=h;for(let h=i=0;!e[h];h^=c||1,i=a[i]||1){let d=i^i<<1^i<<2^i<<3^i<<4;d=d>>8^255&d^99,e[h]=d,n[d]=h,o=r[l=r[c=r[h]]];let w=16843009*o^65537*l^257*c^16843008*h,z=257*r[d]^16843008*d;for(let g=0;4>g;g++)s[g][h]=z=z<<24^z>>>8,t[g][d]=w=w<<24^w>>>8}for(let h=0;5>h;h++)s[h]=s[h].slice(0),t[h]=t[h].slice(0)}_crypt(s,t){if(s.length!==4)throw new m("invalid aes block size");const e=this._key[t],n=e.length/4-2,r=[0,0,0,0],a=this._tables[t],i=a[0],c=a[1],l=a[2],o=a[3],h=a[4];let d,w,z,g=s[0]^e[0],C=s[t?3:1]^e[1],S=s[2]^e[2],I=s[t?1:3]^e[3],V=4;for(let B=0;n>B;B++)d=i[g>>>24]^c[C>>16&255]^l[S>>8&255]^o[255&I]^e[V],w=i[C>>>24]^c[S>>16&255]^l[I>>8&255]^o[255&g]^e[V+1],z=i[S>>>24]^c[I>>16&255]^l[g>>8&255]^o[255&C]^e[V+2],I=i[I>>>24]^c[g>>16&255]^l[C>>8&255]^o[255&S]^e[V+3],V+=4,g=d,C=w,S=z;for(let B=0;4>B;B++)r[t?3&-B:B]=h[g>>>24]<<24^h[C>>16&255]<<16^h[S>>8&255]<<8^h[255&I]^e[V++],d=g,g=C,C=S,S=I,I=d;return r}},Z=class{constructor(s,t){this._prf=s,this._initIv=t,this._iv=t}reset(){this._iv=this._initIv}update(s){return this.calculate(this._prf,s,this._iv)}incWord(s){if((s>>24&255)==255){let t=s>>16&255,e=s>>8&255,n=255&s;t===255?(t=0,e===255?(e=0,n===255?n=0:++n):++e):++t,s=0,s+=t<<16,s+=e<<8,s+=n}else s+=1<<24;return s}incCounter(s){(s[0]=this.incWord(s[0]))===0&&(s[1]=this.incWord(s[1]))}calculate(s,t,e){let n;if(!(n=t.length))return[];const r=u.bitLength(t);for(let a=0;n>a;a+=4){this.incCounter(e);const i=s.encrypt(e);t[a]^=i[0],t[a+1]^=i[1],t[a+2]^=i[2],t[a+3]^=i[3]}return u.clamp(t,r)}},$=T.hmacSha1;class gt{constructor(t,e,n){y.assign(this,{password:t,signed:e,strength:n-1,pendingInput:new p(0)})}async append(t){const e=this;if(e.password){const n=f(t,0,H[e.strength]+2);await(async(r,a,i)=>{await et(r,i,f(a,0,H[r.strength]));const c=f(a,H[r.strength]),l=r.keys.passwordVerification;if(l[0]!=c[0]||l[1]!=c[1])throw new m(q)})(e,n,e.password),e.password=null,e.aesCtrGladman=new Z(new Y(e.keys.key),G.from(Q)),e.hmac=new $(e.keys.authentication),t=f(t,H[e.strength]+2)}return tt(e,t,new p(t.length-v-(t.length-v)%D),0,v,!0)}flush(){const t=this,e=t.pendingInput,n=f(e,0,e.length-v),r=f(e,e.length-v);let a=new p(0);if(n.length){const c=_.toBits(n);t.hmac.update(c);const l=t.aesCtrGladman.update(c);a=_.fromBits(l)}let i=!0;if(t.signed){const c=f(_.fromBits(t.hmac.digest()),0,v);for(let l=0;v>l;l++)c[l]!=r[l]&&(i=!1)}return{valid:i,data:a}}}class wt{constructor(t,e){y.assign(this,{password:t,strength:e-1,pendingInput:new p(0)})}async append(t){const e=this;let n=new p(0);e.password&&(n=await(async(a,i)=>{const c=(l=new p(H[a.strength]),U&&typeof b.getRandomValues=="function"?b.getRandomValues(l):dt.getRandomValues(l));var l;return await et(a,i,c),L(c,a.keys.passwordVerification)})(e,e.password),e.password=null,e.aesCtrGladman=new Z(new Y(e.keys.key),G.from(Q)),e.hmac=new $(e.keys.authentication));const r=new p(n.length+t.length-t.length%D);return r.set(n,0),tt(e,t,r,n.length,0)}flush(){const t=this;let e=new p(0);if(t.pendingInput.length){const r=t.aesCtrGladman.update(_.toBits(t.pendingInput));t.hmac.update(r),e=_.fromBits(r)}const n=f(_.fromBits(t.hmac.digest()),0,v);return{data:L(e,n),signature:n}}}function tt(s,t,e,n,r,a){const i=t.length-r;let c;for(s.pendingInput.length&&(t=L(s.pendingInput,t),e=((l,o)=>{if(o&&o>l.length){const h=l;(l=new p(o)).set(h,0)}return l})(e,i-i%D)),c=0;i-D>=c;c+=D){const l=_.toBits(f(t,c,c+D));a&&s.hmac.update(l);const o=s.aesCtrGladman.update(l);a||s.hmac.update(o),e.set(_.fromBits(o),c+n)}return s.pendingInput=f(t,c),e}async function et(s,t,e){const n=(c=>{if(x===void 0){const l=new p((c=unescape(encodeURIComponent(c))).length);for(let o=0;o<l.length;o++)l[o]=c.charCodeAt(o);return l}return new x().encode(c)})(t),r=await((c,l,o,h,d)=>U&&X&&typeof b.subtle.importKey=="function"?b.subtle.importKey("raw",l,o,!1,d):T.importKey(l))(0,n,ut,0,ft),a=await(async(c,l,o)=>U&&X&&typeof b.subtle.deriveBits=="function"?await b.subtle.deriveBits(c,l,o):T.pbkdf2(l,c.salt,N.iterations,o))(y.assign({salt:e},N),r,8*(2*K[s.strength]+2)),i=new p(a);s.keys={key:_.toBits(f(i,0,K[s.strength])),authentication:_.toBits(f(i,K[s.strength],2*K[s.strength])),passwordVerification:f(i,2*K[s.strength])}}function L(s,t){let e=s;return s.length+t.length&&(e=new p(s.length+t.length),e.set(s,0),e.set(t,s.length)),e}function f(s,t,e){return s.subarray(t,e)}class yt{constructor(t,e){y.assign(this,{password:t,passwordVerification:e}),rt(this,t)}append(t){const e=this;if(e.password){const n=st(e,t.subarray(0,12));if(e.password=null,n[11]!=e.passwordVerification)throw new m(q);t=t.subarray(12)}return st(e,t)}flush(){return{valid:!0,data:new p(0)}}}class _t{constructor(t,e){y.assign(this,{password:t,passwordVerification:e}),rt(this,t)}append(t){const e=this;let n,r;if(e.password){e.password=null;const a=b.getRandomValues(new p(12));a[11]=e.passwordVerification,n=new p(t.length+a.length),n.set(nt(e,a),0),r=12}else n=new p(t.length),r=0;return n.set(nt(e,t),r),n}flush(){return{data:new p(0)}}}function st(s,t){const e=new p(t.length);for(let n=0;n<t.length;n++)e[n]=at(s)^t[n],P(s,e[n]);return e}function nt(s,t){const e=new p(t.length);for(let n=0;n<t.length;n++)e[n]=at(s)^t[n],P(s,t[n]);return e}function rt(s,t){s.keys=[305419896,591751049,878082192],s.crcKey0=new R(s.keys[0]),s.crcKey2=new R(s.keys[2]);for(let e=0;e<t.length;e++)P(s,t.charCodeAt(e))}function P(s,t){s.crcKey0.append([t]),s.keys[0]=~s.crcKey0.get(),s.keys[1]=ct(s.keys[1]+it(s.keys[0])),s.keys[1]=ct(k.imul(s.keys[1],134775813)+1),s.crcKey2.append([s.keys[1]>>>24]),s.keys[2]=~s.crcKey2.get()}function at(s){const t=2|s.keys[2];return it(k.imul(t,1^t)>>>8)}function it(s){return 255&s}function ct(s){return 4294967295&s}const ot="deflate",lt="inflate",ht="Invalid signature";class mt{constructor(t,{signature:e,password:n,signed:r,compressed:a,zipCrypto:i,passwordVerification:c,encryptionStrength:l},{chunkSize:o}){const h=!!n;y.assign(this,{signature:e,encrypted:h,signed:r,compressed:a,inflate:a&&new t({chunkSize:o}),crc32:r&&new R,zipCrypto:i,decrypt:h&&i?new yt(n,c):new gt(n,r,l)})}async append(t){const e=this;return e.encrypted&&t.length&&(t=await e.decrypt.append(t)),e.compressed&&t.length&&(t=await e.inflate.append(t)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),t}async flush(){const t=this;let e,n=new p(0);if(t.encrypted){const r=t.decrypt.flush();if(!r.valid)throw new m(ht);n=r.data}if((!t.encrypted||t.zipCrypto)&&t.signed){const r=new j(new p(4).buffer);if(e=t.crc32.get(),r.setUint32(0,e),t.signature!=r.getUint32(0,!1))throw new m(ht)}return t.compressed&&(n=await t.inflate.append(n)||new p(0),await t.inflate.flush()),{data:n,signature:e}}}class bt{constructor(t,{encrypted:e,signed:n,compressed:r,level:a,zipCrypto:i,password:c,passwordVerification:l,encryptionStrength:o},{chunkSize:h}){y.assign(this,{encrypted:e,signed:n,compressed:r,deflate:r&&new t({level:a||5,chunkSize:h}),crc32:n&&new R,zipCrypto:i,encrypt:e&&i?new _t(c,l):new wt(c,o)})}async append(t){const e=this;let n=t;return e.compressed&&t.length&&(n=await e.deflate.append(t)),e.encrypted&&n.length&&(n=await e.encrypt.append(n)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),n}async flush(){const t=this;let e,n=new p(0);if(t.compressed&&(n=await t.deflate.flush()||new p(0)),t.encrypted){n=await t.encrypt.append(n);const r=t.encrypt.flush();e=r.signature;const a=new p(n.length+r.data.length);a.set(n,0),a.set(r.data,n.length),n=a}return t.encrypted&&!t.zipCrypto||!t.signed||(e=t.crc32.get()),{data:n,signature:e}}}const kt={init(s){s.scripts&&s.scripts.length&&importScripts.apply(void 0,s.scripts);const t=s.options;let e;self.initCodec&&self.initCodec(),t.codecType.startsWith(ot)?e=self.Deflate:t.codecType.startsWith(lt)&&(e=self.Inflate),E=((n,r,a)=>r.codecType.startsWith(ot)?new bt(n,r,a):r.codecType.startsWith(lt)?new mt(n,r,a):void 0)(e,t,s.config)},append:async s=>({data:await E.append(s.data)}),flush:()=>E.flush()};let E;function pt(s,t,e){return class{constructor(r){const a=this;a.codec=new s(y.assign({},t,r)),e(a.codec,i=>{if(a.pendingData){const c=a.pendingData;a.pendingData=new p(c.length+i.length),a.pendingData.set(c,0),a.pendingData.set(i,c.length)}else a.pendingData=new p(i)})}append(r){return this.codec.push(r),n(this)}flush(){return this.codec.push(new p(0),!0),n(this)}};function n(r){if(r.pendingData){const a=r.pendingData;return r.pendingData=null,a}return new p(0)}}addEventListener("message",async s=>{const t=s.data,e=t.type,n=kt[e];if(n)try{t.data&&(t.data=new p(t.data));const r=await n(t)||{};if(r.type=e,r.data)try{r.data=r.data.buffer,A(r,[r.data])}catch{A(r)}else A(r)}catch(r){A({type:e,error:{message:r.message,stack:r.stack}})}}),self.initCodec=()=>{const{Deflate:s,Inflate:t}=((e,n={},r)=>({Deflate:pt(e.Deflate,n.deflate,r),Inflate:pt(e.Inflate,n.inflate,r)}))(pako,{deflate:{raw:!0},inflate:{raw:!0}},(e,n)=>e.onData=n);self.Deflate=s,self.Inflate=t}})();
